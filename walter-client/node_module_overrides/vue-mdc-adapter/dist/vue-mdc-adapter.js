/**
* @module vue-mdc-adapter 0.17.0
* @exports VueMDCAdapter
* @copyright (c) 2017-present, Sebastien Tasson
* @license https://opensource.org/licenses/MIT
* @implements {"material-components-web":"^0.37.0"}
* @requires {"vue":"^2.5.6"}
* @see https://github.com/stasson/vue-mdc-adapter
*/

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.VueMDCAdapter = factory());
}(this, (function () { 'use strict';

  var supportsPassive_ = void 0;

  /**
   * Determine whether the current browser supports passive event listeners, and if so, use them.
   * @param {!Window=} globalObj
   * @param {boolean=} forceRefresh
   * @return {boolean|{passive: boolean}}
   */
  function applyPassive() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (supportsPassive_ === undefined || forceRefresh) {
      var isSupported = false;
      try {
        globalObj.document.addEventListener('test', null, {
          get passive() {
            isSupported = { passive: true };
          }
        });
      } catch (e) {
        //empty
      }

      supportsPassive_ = isSupported;
    }

    return supportsPassive_;
  }

  function autoInit(plugin) {
    // Auto-install
    var _Vue = null;
    if (typeof window !== 'undefined') {
      _Vue = window.Vue;
    } else if (typeof global !== 'undefined') {
      /*global global*/
      _Vue = global.Vue;
    }
    if (_Vue) {
      _Vue.use(plugin);
    }
  }

  function BasePlugin(components) {
    return {
      version: '0.17.0',
      install: function install(vm) {
        for (var key in components) {
          var component = components[key];
          vm.component(component.name, component);
        }
      },
      components: components
    };
  }

  var CustomElement = {
    functional: true,
    render: function render(createElement, context) {
      return createElement(context.props.is || context.props.tag || 'div', context.data, context.children);
    }
  };

  var CustomElementMixin = {
    components: {
      CustomElement: CustomElement
    }
  };

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var defineProperty = function (obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  var inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  var possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  var toConsumableArray = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    } else {
      return Array.from(arr);
    }
  };

  var CustomLink = {
    name: 'custom-link',
    functional: true,
    props: {
      tag: { type: String, default: 'a' },
      link: Object
    },
    render: function render(h, context) {
      var element = void 0;
      var data = _extends({}, context.data);

      if (context.props.link && context.parent.$router) {
        // router-link case
        element = context.parent.$root.$options.components['router-link'];
        data.props = _extends({ tag: context.props.tag }, context.props.link);
        if (data.on.click) {
          data.nativeOn = { click: data.on.click };
        }
      } else {
        // element fallback
        element = context.props.tag;
      }

      return h(element, data, context.children);
    }
  };

  var CustomLinkMixin = {
    props: {
      to: [String, Object],
      exact: Boolean,
      append: Boolean,
      replace: Boolean,
      activeClass: String,
      exactActiveClass: String
    },
    computed: {
      link: function link() {
        return this.to && {
          to: this.to,
          exact: this.exact,
          append: this.append,
          replace: this.replace,
          activeClass: this.activeClass,
          exactActiveClass: this.exactActiveClass
        };
      }
    },
    components: {
      CustomLink: CustomLink
    }
  };

  /* global CustomEvent */

  function emitCustomEvent(el, evtType, evtData) {
    var shouldBubble = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

    var evt = void 0;
    if (typeof CustomEvent === 'function') {
      evt = new CustomEvent(evtType, {
        detail: evtData,
        bubbles: shouldBubble
      });
    } else {
      evt = document.createEvent('CustomEvent');
      evt.initCustomEvent(evtType, shouldBubble, false, evtData);
    }
    el.dispatchEvent(evt);
  }

  var CustomButton = {
    name: 'custom-button',
    functional: true,
    props: {
      link: Object
    },
    render: function render(h, context) {
      var element = void 0;
      var data = _extends({}, context.data);

      if (context.props.link && context.parent.$router) {
        // router-link case
        element = context.parent.$root.$options.components['router-link'];
        data.props = _extends({ tag: context.props.tag }, context.props.link);
        data.attrs.role = 'button';
        if (data.on.click) {
          data.nativeOn = { click: data.on.click };
        }
      } else if (data.attrs && data.attrs.href) {
        // href case
        element = 'a';
        data.attrs.role = 'button';
      } else {
        // button fallback
        element = 'button';
      }

      return h(element, data, context.children);
    }
  };

  var CustomButtonMixin = {
    props: {
      href: String,
      disabled: Boolean,
      to: [String, Object],
      exact: Boolean,
      append: Boolean,
      replace: Boolean,
      activeClass: String,
      exactActiveClass: String
    },
    computed: {
      link: function link() {
        return this.to && {
          to: this.to,
          exact: this.exact,
          append: this.append,
          replace: this.replace,
          activeClass: this.activeClass,
          exactActiveClass: this.exactActiveClass
        };
      }
    },
    components: {
      CustomButton: CustomButton
    }
  };

  function extractIconProp(iconProp) {
    if (typeof iconProp === 'string') {
      return {
        classes: { 'material-icons': true },
        content: iconProp
      };
    } else if (iconProp instanceof Array) {
      return {
        classes: iconProp.reduce(function (result, value) {
          return _extends(result, defineProperty({}, value, true));
        }, {})
      };
    } else if ((typeof iconProp === 'undefined' ? 'undefined' : _typeof(iconProp)) === 'object') {
      return {
        classes: iconProp.className.split(' ').reduce(function (result, value) {
          return _extends(result, defineProperty({}, value, true));
        }, {}),
        content: iconProp.textContent
      };
    }
  }

  var DispatchEventMixin = {
    props: {
      event: String,
      'event-target': Object,
      'event-args': Array
    },
    methods: {
      dispatchEvent: function dispatchEvent(evt) {
        evt && this.$emit(evt.type, evt);
        if (this.event) {
          var target = this.eventTarget || this.$root;
          var args = this.eventArgs || [];
          target.$emit.apply(target, [this.event].concat(toConsumableArray(args)));
        }
      }
    },
    computed: {
      listeners: function listeners() {
        var _this = this;

        return _extends({}, this.$listeners, {
          click: function click(e) {
            return _this.dispatchEvent(e);
          }
        });
      }
    }
  };

  var DispatchFocusMixin = {
    data: function data() {
      return { hasFocus: false };
    },

    methods: {
      onMouseDown: function onMouseDown() {
        this._active = true;
      },
      onMouseUp: function onMouseUp() {
        this._active = false;
      },
      onFocusEvent: function onFocusEvent() {
        var _this = this;

        // dispatch async to let time to other focus event to propagate
        setTimeout(function () {
          return _this.dispatchFocusEvent();
        }, 0);
      },
      onBlurEvent: function onBlurEvent() {
        var _this2 = this;

        // dispatch async to let time to other focus event to propagate
        // also filtur blur if mousedown
        this._active || setTimeout(function () {
          return _this2.dispatchFocusEvent();
        }, 0);
      },
      dispatchFocusEvent: function dispatchFocusEvent() {
        var hasFocus = this.$el === document.activeElement || this.$el.contains(document.activeElement);
        if (hasFocus != this.hasFocus) {
          this.$emit(hasFocus ? 'focus' : 'blur');
          this.hasFocus = hasFocus;
        }
      }
    },
    mounted: function mounted() {
      this.$el.addEventListener('focusin', this.onFocusEvent);
      this.$el.addEventListener('focusout', this.onBlurEvent);
      this.$el.addEventListener('mousedown', this.onMouseDown);
      this.$el.addEventListener('mouseup', this.onMouseUp);
    },
    beforeDestroy: function beforeDestroy() {
      this.$el.removeEventListener('focusin', this.onFocusEvent);
      this.$el.removeEventListener('focusout', this.onBlurEvent);
      this.$el.removeEventListener('mousedown', this.onMouseDown);
      this.$el.removeEventListener('mouseup', this.onMouseUp);
    }
  };

  var scope = Math.floor(Math.random() * Math.floor(0x10000000)).toString() + '-';

  var VMAUniqueIdMixin = {
    beforeCreate: function beforeCreate() {
      this.vma_uid_ = scope + this._uid;
    }
  };

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @template A
   */
  var MDCFoundation = function () {
    createClass(MDCFoundation, null, [{
      key: "cssClasses",

      /** @return enum{cssClasses} */
      get: function get$$1() {
        // Classes extending MDCFoundation should implement this method to return an object which exports every
        // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
        return {};
      }

      /** @return enum{strings} */

    }, {
      key: "strings",
      get: function get$$1() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
        return {};
      }

      /** @return enum{numbers} */

    }, {
      key: "numbers",
      get: function get$$1() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
        return {};
      }

      /** @return {!Object} */

    }, {
      key: "defaultAdapter",
      get: function get$$1() {
        // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
        // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
        // validation.
        return {};
      }

      /**
       * @param {A=} adapter
       */

    }]);

    function MDCFoundation() {
      var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      classCallCheck(this, MDCFoundation);

      /** @protected {!A} */
      this.adapter_ = adapter;
    }

    createClass(MDCFoundation, [{
      key: "init",
      value: function init() {
        // Subclasses should override this method to perform initialization routines (registering events, etc.)
      }
    }, {
      key: "destroy",
      value: function destroy() {
        // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
      }
    }]);
    return MDCFoundation;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Ripple. Provides an interface for managing
   * - classes
   * - dom
   * - CSS variables
   * - position
   * - dimensions
   * - scroll position
   * - event handlers
   * - unbounded, active and disabled states
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCRippleAdapter = function () {
    function MDCRippleAdapter() {
      classCallCheck(this, MDCRippleAdapter);
    }

    createClass(MDCRippleAdapter, [{
      key: "browserSupportsCssVars",

      /** @return {boolean} */
      value: function browserSupportsCssVars() {}

      /** @return {boolean} */

    }, {
      key: "isUnbounded",
      value: function isUnbounded() {}

      /** @return {boolean} */

    }, {
      key: "isSurfaceActive",
      value: function isSurfaceActive() {}

      /** @return {boolean} */

    }, {
      key: "isSurfaceDisabled",
      value: function isSurfaceDisabled() {}

      /** @param {string} className */

    }, {
      key: "addClass",
      value: function addClass(className) {}

      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /** @param {!EventTarget} target */

    }, {
      key: "containsEventTarget",
      value: function containsEventTarget(target) {}

      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(evtType, handler) {}

      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(evtType, handler) {}

      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "registerDocumentInteractionHandler",
      value: function registerDocumentInteractionHandler(evtType, handler) {}

      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "deregisterDocumentInteractionHandler",
      value: function deregisterDocumentInteractionHandler(evtType, handler) {}

      /**
       * @param {!Function} handler
       */

    }, {
      key: "registerResizeHandler",
      value: function registerResizeHandler(handler) {}

      /**
       * @param {!Function} handler
       */

    }, {
      key: "deregisterResizeHandler",
      value: function deregisterResizeHandler(handler) {}

      /**
       * @param {string} varName
       * @param {?number|string} value
       */

    }, {
      key: "updateCssVariable",
      value: function updateCssVariable(varName, value) {}

      /** @return {!ClientRect} */

    }, {
      key: "computeBoundingRect",
      value: function computeBoundingRect() {}

      /** @return {{x: number, y: number}} */

    }, {
      key: "getWindowPageOffset",
      value: function getWindowPageOffset() {}
    }]);
    return MDCRippleAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses = {
    // Ripple is a special case where the "root" component is really a "mixin" of sorts,
    // given that it's an 'upgrade' to an existing component. That being said it is the root
    // CSS class that all other CSS classes derive from.
    ROOT: 'mdc-ripple-upgraded',
    UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
    BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
    FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
    FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
  };

  var strings = {
    VAR_LEFT: '--mdc-ripple-left',
    VAR_TOP: '--mdc-ripple-top',
    VAR_FG_SIZE: '--mdc-ripple-fg-size',
    VAR_FG_SCALE: '--mdc-ripple-fg-scale',
    VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
    VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
  };

  var numbers = {
    PADDING: 10,
    INITIAL_ORIGIN_SCALE: 0.6,
    DEACTIVATION_TIMEOUT_MS: 225, // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
    FG_DEACTIVATION_MS: 150, // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
    TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
   * @private {boolean|undefined}
   */
  var supportsCssVariables_ = void 0;

  /**
   * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
   * @private {boolean|undefined}
   */
  var supportsPassive_$1 = void 0;

  /**
   * @param {!Window} windowObj
   * @return {boolean}
   */
  function detectEdgePseudoVarBug(windowObj) {
    // Detect versions of Edge with buggy var() support
    // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
    var document = windowObj.document;
    var node = document.createElement('div');
    node.className = 'mdc-ripple-surface--test-edge-var-bug';
    document.body.appendChild(node);

    // The bug exists if ::before style ends up propagating to the parent element.
    // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
    // but Firefox is known to support CSS custom properties correctly.
    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397
    var computedStyle = windowObj.getComputedStyle(node);
    var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
    node.remove();
    return hasPseudoVarBug;
  }

  /**
   * @param {!Window} windowObj
   * @param {boolean=} forceRefresh
   * @return {boolean|undefined}
   */

  function supportsCssVariables(windowObj) {
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var supportsCssVariables = supportsCssVariables_;
    if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {
      return supportsCssVariables;
    }

    var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';
    if (!supportsFunctionPresent) {
      return;
    }

    var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes');
    // See: https://bugs.webkit.org/show_bug.cgi?id=154669
    // See: README section on Safari
    var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

    if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
      supportsCssVariables = !detectEdgePseudoVarBug(windowObj);
    } else {
      supportsCssVariables = false;
    }

    if (!forceRefresh) {
      supportsCssVariables_ = supportsCssVariables;
    }
    return supportsCssVariables;
  }

  //
  /**
   * Determine whether the current browser supports passive event listeners, and if so, use them.
   * @param {!Window=} globalObj
   * @param {boolean=} forceRefresh
   * @return {boolean|{passive: boolean}}
   */
  function applyPassive$1() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (supportsPassive_$1 === undefined || forceRefresh) {
      var isSupported = false;
      try {
        globalObj.document.addEventListener('test', null, { get passive() {
            isSupported = true;
          } });
      } catch (e) {}

      supportsPassive_$1 = isSupported;
    }

    return supportsPassive_$1 ? { passive: true } : false;
  }

  /**
   * @param {!Object} HTMLElementPrototype
   * @return {!Array<string>}
   */
  function getMatchesProperty(HTMLElementPrototype) {
    return ['webkitMatchesSelector', 'msMatchesSelector', 'matches'].filter(function (p) {
      return p in HTMLElementPrototype;
    }).pop();
  }

  /**
   * @param {!Event} ev
   * @param {{x: number, y: number}} pageOffset
   * @param {!ClientRect} clientRect
   * @return {{x: number, y: number}}
   */
  function getNormalizedEventCoords(ev, pageOffset, clientRect) {
    var x = pageOffset.x,
        y = pageOffset.y;

    var documentX = x + clientRect.left;
    var documentY = y + clientRect.top;

    var normalizedX = void 0;
    var normalizedY = void 0;
    // Determine touch point relative to the ripple container.
    if (ev.type === 'touchstart') {
      normalizedX = ev.changedTouches[0].pageX - documentX;
      normalizedY = ev.changedTouches[0].pageY - documentY;
    } else {
      normalizedX = ev.pageX - documentX;
      normalizedY = ev.pageY - documentY;
    }

    return { x: normalizedX, y: normalizedY };
  }

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  // Activation events registered on the root element of each instance for activation
  var ACTIVATION_EVENT_TYPES = ['touchstart', 'pointerdown', 'mousedown', 'keydown'];

  // Deactivation events registered on documentElement when a pointer-related down event occurs
  var POINTER_DEACTIVATION_EVENT_TYPES = ['touchend', 'pointerup', 'mouseup'];

  // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations
  /** @type {!Array<!EventTarget>} */
  var activatedTargets = [];

  /**
   * @extends {MDCFoundation<!MDCRippleAdapter>}
   */

  var MDCRippleFoundation = function (_MDCFoundation) {
    inherits(MDCRippleFoundation, _MDCFoundation);
    createClass(MDCRippleFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings;
      }
    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          browserSupportsCssVars: function browserSupportsCssVars() /* boolean - cached */{},
          isUnbounded: function isUnbounded() /* boolean */{},
          isSurfaceActive: function isSurfaceActive() /* boolean */{},
          isSurfaceDisabled: function isSurfaceDisabled() /* boolean */{},
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          containsEventTarget: function containsEventTarget() /* target: !EventTarget */{},
          registerInteractionHandler: function registerInteractionHandler() /* evtType: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* evtType: string, handler: EventListener */{},
          registerDocumentInteractionHandler: function registerDocumentInteractionHandler() /* evtType: string, handler: EventListener */{},
          deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler() /* evtType: string, handler: EventListener */{},
          registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
          deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
          updateCssVariable: function updateCssVariable() /* varName: string, value: string */{},
          computeBoundingRect: function computeBoundingRect() /* ClientRect */{},
          getWindowPageOffset: function getWindowPageOffset() /* {x: number, y: number} */{}
        };
      }
    }]);

    function MDCRippleFoundation(adapter) {
      classCallCheck(this, MDCRippleFoundation);

      /** @private {number} */
      var _this = possibleConstructorReturn(this, (MDCRippleFoundation.__proto__ || Object.getPrototypeOf(MDCRippleFoundation)).call(this, _extends(MDCRippleFoundation.defaultAdapter, adapter)));

      _this.layoutFrame_ = 0;

      /** @private {!ClientRect} */
      _this.frame_ = /** @type {!ClientRect} */{ width: 0, height: 0 };

      /** @private {!ActivationStateType} */
      _this.activationState_ = _this.defaultActivationState_();

      /** @private {number} */
      _this.initialSize_ = 0;

      /** @private {number} */
      _this.maxRadius_ = 0;

      /** @private {function(!Event)} */
      _this.activateHandler_ = function (e) {
        return _this.activate_(e);
      };

      /** @private {function(!Event)} */
      _this.deactivateHandler_ = function (e) {
        return _this.deactivate_(e);
      };

      /** @private {function(?Event=)} */
      _this.focusHandler_ = function () {
        return _this.handleFocus();
      };

      /** @private {function(?Event=)} */
      _this.blurHandler_ = function () {
        return _this.handleBlur();
      };

      /** @private {!Function} */
      _this.resizeHandler_ = function () {
        return _this.layout();
      };

      /** @private {{left: number, top:number}} */
      _this.unboundedCoords_ = {
        left: 0,
        top: 0
      };

      /** @private {number} */
      _this.fgScale_ = 0;

      /** @private {number} */
      _this.activationTimer_ = 0;

      /** @private {number} */
      _this.fgDeactivationRemovalTimer_ = 0;

      /** @private {boolean} */
      _this.activationAnimationHasEnded_ = false;

      /** @private {!Function} */
      _this.activationTimerCallback_ = function () {
        _this.activationAnimationHasEnded_ = true;
        _this.runDeactivationUXLogicIfReady_();
      };

      /** @private {?Event} */
      _this.previousActivationEvent_ = null;
      return _this;
    }

    /**
     * We compute this property so that we are not querying information about the client
     * until the point in time where the foundation requests it. This prevents scenarios where
     * client-side feature-detection may happen too early, such as when components are rendered on the server
     * and then initialized at mount time on the client.
     * @return {boolean}
     * @private
     */


    createClass(MDCRippleFoundation, [{
      key: 'isSupported_',
      value: function isSupported_() {
        return this.adapter_.browserSupportsCssVars();
      }

      /**
       * @return {!ActivationStateType}
       */

    }, {
      key: 'defaultActivationState_',
      value: function defaultActivationState_() {
        return {
          isActivated: false,
          hasDeactivationUXRun: false,
          wasActivatedByPointer: false,
          wasElementMadeActive: false,
          activationEvent: null,
          isProgrammatic: false
        };
      }
    }, {
      key: 'init',
      value: function init() {
        var _this2 = this;

        if (!this.isSupported_()) {
          return;
        }
        this.registerRootHandlers_();

        var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
            ROOT = _MDCRippleFoundation$.ROOT,
            UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;

        requestAnimationFrame(function () {
          _this2.adapter_.addClass(ROOT);
          if (_this2.adapter_.isUnbounded()) {
            _this2.adapter_.addClass(UNBOUNDED);
            // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple
            _this2.layoutInternal_();
          }
        });
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this3 = this;

        if (!this.isSupported_()) {
          return;
        }

        if (this.activationTimer_) {
          clearTimeout(this.activationTimer_);
          this.activationTimer_ = 0;
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;

          this.adapter_.removeClass(FG_ACTIVATION);
        }

        this.deregisterRootHandlers_();
        this.deregisterDeactivationHandlers_();

        var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
            ROOT = _MDCRippleFoundation$2.ROOT,
            UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;

        requestAnimationFrame(function () {
          _this3.adapter_.removeClass(ROOT);
          _this3.adapter_.removeClass(UNBOUNDED);
          _this3.removeCssVars_();
        });
      }

      /** @private */

    }, {
      key: 'registerRootHandlers_',
      value: function registerRootHandlers_() {
        var _this4 = this;

        ACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
        });
        this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
        this.adapter_.registerInteractionHandler('blur', this.blurHandler_);

        if (this.adapter_.isUnbounded()) {
          this.adapter_.registerResizeHandler(this.resizeHandler_);
        }
      }

      /**
       * @param {!Event} e
       * @private
       */

    }, {
      key: 'registerDeactivationHandlers_',
      value: function registerDeactivationHandlers_(e) {
        var _this5 = this;

        if (e.type === 'keydown') {
          this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
        } else {
          POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
            _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
          });
        }
      }

      /** @private */

    }, {
      key: 'deregisterRootHandlers_',
      value: function deregisterRootHandlers_() {
        var _this6 = this;

        ACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
        });
        this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
        this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

        if (this.adapter_.isUnbounded()) {
          this.adapter_.deregisterResizeHandler(this.resizeHandler_);
        }
      }

      /** @private */

    }, {
      key: 'deregisterDeactivationHandlers_',
      value: function deregisterDeactivationHandlers_() {
        var _this7 = this;

        this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
        POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
        });
      }

      /** @private */

    }, {
      key: 'removeCssVars_',
      value: function removeCssVars_() {
        var _this8 = this;

        var strings$$1 = MDCRippleFoundation.strings;

        Object.keys(strings$$1).forEach(function (k) {
          if (k.indexOf('VAR_') === 0) {
            _this8.adapter_.updateCssVariable(strings$$1[k], null);
          }
        });
      }

      /**
       * @param {?Event} e
       * @private
       */

    }, {
      key: 'activate_',
      value: function activate_(e) {
        var _this9 = this;

        if (this.adapter_.isSurfaceDisabled()) {
          return;
        }

        var activationState = this.activationState_;
        if (activationState.isActivated) {
          return;
        }

        // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction
        var previousActivationEvent = this.previousActivationEvent_;
        var isSameInteraction = previousActivationEvent && e && previousActivationEvent.type !== e.type;
        if (isSameInteraction) {
          return;
        }

        activationState.isActivated = true;
        activationState.isProgrammatic = e === null;
        activationState.activationEvent = e;
        activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown';

        var hasActivatedChild = e && activatedTargets.length > 0 && activatedTargets.some(function (target) {
          return _this9.adapter_.containsEventTarget(target);
        });
        if (hasActivatedChild) {
          // Immediately reset activation state, while preserving logic that prevents touch follow-on events
          this.resetActivationState_();
          return;
        }

        if (e) {
          activatedTargets.push( /** @type {!EventTarget} */e.target);
          this.registerDeactivationHandlers_(e);
        }

        activationState.wasElementMadeActive = this.checkElementMadeActive_(e);
        if (activationState.wasElementMadeActive) {
          this.animateActivation_();
        }

        requestAnimationFrame(function () {
          // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
          activatedTargets = [];

          if (!activationState.wasElementMadeActive && (e.key === ' ' || e.keyCode === 32)) {
            // If space was pressed, try again within an rAF call to detect :active, because different UAs report
            // active states inconsistently when they're called within event handling code:
            // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
            // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
            // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
            // variable is set within a rAF callback for a submit button interaction (#2241).
            activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);
            if (activationState.wasElementMadeActive) {
              _this9.animateActivation_();
            }
          }

          if (!activationState.wasElementMadeActive) {
            // Reset activation state immediately if element was not made active.
            _this9.activationState_ = _this9.defaultActivationState_();
          }
        });
      }

      /**
       * @param {?Event} e
       * @private
       */

    }, {
      key: 'checkElementMadeActive_',
      value: function checkElementMadeActive_(e) {
        return e && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
      }

      /**
       * @param {?Event=} event Optional event containing position information.
       */

    }, {
      key: 'activate',
      value: function activate() {
        var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        this.activate_(event);
      }

      /** @private */

    }, {
      key: 'animateActivation_',
      value: function animateActivation_() {
        var _this10 = this;

        var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
            VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
            VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
        var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
            FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
            FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
        var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;


        this.layoutInternal_();

        var translateStart = '';
        var translateEnd = '';

        if (!this.adapter_.isUnbounded()) {
          var _getFgTranslationCoor = this.getFgTranslationCoordinates_(),
              startPoint = _getFgTranslationCoor.startPoint,
              endPoint = _getFgTranslationCoor.endPoint;

          translateStart = startPoint.x + 'px, ' + startPoint.y + 'px';
          translateEnd = endPoint.x + 'px, ' + endPoint.y + 'px';
        }

        this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
        this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
        // Cancel any ongoing activation/deactivation animations
        clearTimeout(this.activationTimer_);
        clearTimeout(this.fgDeactivationRemovalTimer_);
        this.rmBoundedActivationClasses_();
        this.adapter_.removeClass(FG_DEACTIVATION);

        // Force layout in order to re-trigger the animation.
        this.adapter_.computeBoundingRect();
        this.adapter_.addClass(FG_ACTIVATION);
        this.activationTimer_ = setTimeout(function () {
          return _this10.activationTimerCallback_();
        }, DEACTIVATION_TIMEOUT_MS);
      }

      /**
       * @private
       * @return {{startPoint: PointType, endPoint: PointType}}
       */

    }, {
      key: 'getFgTranslationCoordinates_',
      value: function getFgTranslationCoordinates_() {
        var _activationState_ = this.activationState_,
            activationEvent = _activationState_.activationEvent,
            wasActivatedByPointer = _activationState_.wasActivatedByPointer;


        var startPoint = void 0;
        if (wasActivatedByPointer) {
          startPoint = getNormalizedEventCoords(
          /** @type {!Event} */activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
        } else {
          startPoint = {
            x: this.frame_.width / 2,
            y: this.frame_.height / 2
          };
        }
        // Center the element around the start point.
        startPoint = {
          x: startPoint.x - this.initialSize_ / 2,
          y: startPoint.y - this.initialSize_ / 2
        };

        var endPoint = {
          x: this.frame_.width / 2 - this.initialSize_ / 2,
          y: this.frame_.height / 2 - this.initialSize_ / 2
        };

        return { startPoint: startPoint, endPoint: endPoint };
      }

      /** @private */

    }, {
      key: 'runDeactivationUXLogicIfReady_',
      value: function runDeactivationUXLogicIfReady_() {
        var _this11 = this;

        // This method is called both when a pointing device is released, and when the activation animation ends.
        // The deactivation animation should only run after both of those occur.
        var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
        var _activationState_2 = this.activationState_,
            hasDeactivationUXRun = _activationState_2.hasDeactivationUXRun,
            isActivated = _activationState_2.isActivated;

        var activationHasEnded = hasDeactivationUXRun || !isActivated;

        if (activationHasEnded && this.activationAnimationHasEnded_) {
          this.rmBoundedActivationClasses_();
          this.adapter_.addClass(FG_DEACTIVATION);
          this.fgDeactivationRemovalTimer_ = setTimeout(function () {
            _this11.adapter_.removeClass(FG_DEACTIVATION);
          }, numbers.FG_DEACTIVATION_MS);
        }
      }

      /** @private */

    }, {
      key: 'rmBoundedActivationClasses_',
      value: function rmBoundedActivationClasses_() {
        var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;

        this.adapter_.removeClass(FG_ACTIVATION);
        this.activationAnimationHasEnded_ = false;
        this.adapter_.computeBoundingRect();
      }
    }, {
      key: 'resetActivationState_',
      value: function resetActivationState_() {
        var _this12 = this;

        this.previousActivationEvent_ = this.activationState_.activationEvent;
        this.activationState_ = this.defaultActivationState_();
        // Touch devices may fire additional events for the same interaction within a short time.
        // Store the previous event until it's safe to assume that subsequent events are for new interactions.
        setTimeout(function () {
          return _this12.previousActivationEvent_ = null;
        }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
      }

      /**
       * @param {?Event} e
       * @private
       */

    }, {
      key: 'deactivate_',
      value: function deactivate_(e) {
        var _this13 = this;

        var activationState = this.activationState_;
        // This can happen in scenarios such as when you have a keyup event that blurs the element.
        if (!activationState.isActivated) {
          return;
        }

        var state = /** @type {!ActivationStateType} */_extends({}, activationState);

        if (activationState.isProgrammatic) {
          var evtObject = null;
          requestAnimationFrame(function () {
            return _this13.animateDeactivation_(evtObject, state);
          });
          this.resetActivationState_();
        } else {
          this.deregisterDeactivationHandlers_();
          requestAnimationFrame(function () {
            _this13.activationState_.hasDeactivationUXRun = true;
            _this13.animateDeactivation_(e, state);
            _this13.resetActivationState_();
          });
        }
      }

      /**
       * @param {?Event=} event Optional event containing position information.
       */

    }, {
      key: 'deactivate',
      value: function deactivate() {
        var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        this.deactivate_(event);
      }

      /**
       * @param {Event} e
       * @param {!ActivationStateType} options
       * @private
       */

    }, {
      key: 'animateDeactivation_',
      value: function animateDeactivation_(e, _ref) {
        var wasActivatedByPointer = _ref.wasActivatedByPointer,
            wasElementMadeActive = _ref.wasElementMadeActive;

        if (wasActivatedByPointer || wasElementMadeActive) {
          this.runDeactivationUXLogicIfReady_();
        }
      }
    }, {
      key: 'layout',
      value: function layout() {
        var _this14 = this;

        if (this.layoutFrame_) {
          cancelAnimationFrame(this.layoutFrame_);
        }
        this.layoutFrame_ = requestAnimationFrame(function () {
          _this14.layoutInternal_();
          _this14.layoutFrame_ = 0;
        });
      }

      /** @private */

    }, {
      key: 'layoutInternal_',
      value: function layoutInternal_() {
        var _this15 = this;

        this.frame_ = this.adapter_.computeBoundingRect();
        var maxDim = Math.max(this.frame_.height, this.frame_.width);

        // Surface diameter is treated differently for unbounded vs. bounded ripples.
        // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
        // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
        // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
        // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
        // `overflow: hidden`.
        var getBoundedRadius = function getBoundedRadius() {
          var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
          return hypotenuse + MDCRippleFoundation.numbers.PADDING;
        };

        this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius();

        // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform
        this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;
        this.fgScale_ = this.maxRadius_ / this.initialSize_;

        this.updateLayoutCssVars_();
      }

      /** @private */

    }, {
      key: 'updateLayoutCssVars_',
      value: function updateLayoutCssVars_() {
        var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
            VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
            VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
            VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
            VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;


        this.adapter_.updateCssVariable(VAR_FG_SIZE, this.initialSize_ + 'px');
        this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

        if (this.adapter_.isUnbounded()) {
          this.unboundedCoords_ = {
            left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
            top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
          };

          this.adapter_.updateCssVariable(VAR_LEFT, this.unboundedCoords_.left + 'px');
          this.adapter_.updateCssVariable(VAR_TOP, this.unboundedCoords_.top + 'px');
        }
      }

      /** @param {boolean} unbounded */

    }, {
      key: 'setUnbounded',
      value: function setUnbounded(unbounded) {
        var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

        if (unbounded) {
          this.adapter_.addClass(UNBOUNDED);
        } else {
          this.adapter_.removeClass(UNBOUNDED);
        }
      }
    }, {
      key: 'handleFocus',
      value: function handleFocus() {
        var _this16 = this;

        requestAnimationFrame(function () {
          return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
        });
      }
    }, {
      key: 'handleBlur',
      value: function handleBlur() {
        var _this17 = this;

        requestAnimationFrame(function () {
          return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
        });
      }
    }]);
    return MDCRippleFoundation;
  }(MDCFoundation);

  var RippleBase = function (_MDCRippleFoundation) {
    inherits(RippleBase, _MDCRippleFoundation);
    createClass(RippleBase, null, [{
      key: 'isSurfaceActive',
      value: function isSurfaceActive(ref) {
        return ref[RippleBase.MATCHES](':active');
      }
    }, {
      key: 'MATCHES',
      get: function get$$1() {
        /* global HTMLElement */
        return RippleBase._matches || (RippleBase._matches = getMatchesProperty(HTMLElement.prototype));
      }
    }]);

    function RippleBase(vm, options) {
      classCallCheck(this, RippleBase);
      return possibleConstructorReturn(this, (RippleBase.__proto__ || Object.getPrototypeOf(RippleBase)).call(this, _extends({
        browserSupportsCssVars: function browserSupportsCssVars() {
          return supportsCssVariables(window);
        },
        isUnbounded: function isUnbounded() {
          return false;
        },
        isSurfaceActive: function isSurfaceActive() {
          return vm.$el[RippleBase.MATCHES](':active');
        },
        isSurfaceDisabled: function isSurfaceDisabled() {
          return vm.disabled;
        },
        addClass: function addClass(className) {
          vm.$set(vm.classes, className, true);
        },
        removeClass: function removeClass(className) {
          vm.$delete(vm.classes, className);
        },

        containsEventTarget: function containsEventTarget(target) {
          return vm.$el.contains(target);
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          vm.$el.addEventListener(evt, handler, applyPassive$1());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          vm.$el.removeEventListener(evt, handler, applyPassive$1());
        },
        registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
          return document.documentElement.addEventListener(evtType, handler, applyPassive$1());
        },
        deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
          return document.documentElement.removeEventListener(evtType, handler, applyPassive$1());
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          return window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          return window.removeEventListener('resize', handler);
        },
        updateCssVariable: function updateCssVariable(varName, value) {
          vm.$set(vm.styles, varName, value);
        },
        computeBoundingRect: function computeBoundingRect() {
          return vm.$el.getBoundingClientRect();
        },
        getWindowPageOffset: function getWindowPageOffset() {
          return { x: window.pageXOffset, y: window.pageYOffset };
        }
      }, options)));
    }

    return RippleBase;
  }(MDCRippleFoundation);

  var RippleMixin = {
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },
    mounted: function mounted() {
      this.ripple = new RippleBase(this);
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.ripple.destroy();
    }
  };

  var mdcRipple = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-element', { staticClass: "mdc-ripple", attrs: { "tag": _vm.tag, "classes": _vm.classes, "styles": _vm.styles } }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-ripple',
    mixins: [CustomElementMixin, RippleMixin],
    props: {
      tag: String
    }
  };

  var VueMDCRipple = BasePlugin({
    mdcRipple: mdcRipple
  });

  var mdcButtonBase = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-button', _vm._g({ ref: "root", class: _vm.classes, style: _vm.styles, attrs: { "href": _vm.href, "link": _vm.link, "disabled": _vm.disabled } }, _vm.listeners), [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-button-base',
    mixins: [DispatchEventMixin, CustomButtonMixin, RippleMixin],
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    }
  };

  var mdcButton = {
    name: 'mdc-button',
    extends: mdcButtonBase,
    props: {
      raised: Boolean,
      unelevated: Boolean,
      outlined: Boolean,
      dense: Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-button': true,
          'mdc-button--raised': this.raised,
          'mdc-button--unelevated': this.unelevated,
          'mdc-button--outlined': this.outlined,
          'mdc-button--dense': this.dense
        }
      };
    },

    watch: {
      raised: function raised() {
        this.$set(this.classes, 'mdc-button--raised', this.raised);
      },
      unelevated: function unelevated() {
        this.$set(this.classes, 'mdc-button--unelevated', this.unelevated);
      },
      outlined: function outlined() {
        this.$set(this.classes, 'mdc-button--outlined', this.outlined);
      },
      dense: function dense() {
        this.$set(this.classes, 'mdc-button--dense', this.dense);
      }
    }
  };

  var VueMDCButton = BasePlugin({
    mdcButton: mdcButton
  });

  var mdcCard = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-card", class: { 'mdc-card--outlined': _vm.outlined } }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-card',
    props: {
      outlined: Boolean
    }
  };

  var mdcCardPrimaryAction = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-link', _vm._g({ staticClass: "mdc-card-primary-action mdc-card__primary-action", class: _vm.classes, style: _vm.styles, attrs: { "link": _vm.link } }, _vm.listeners), [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-card-primary-action',
    mixins: [DispatchEventMixin, CustomLinkMixin, RippleMixin],
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    }
  };

  var mdcCardMedia = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('section', { staticClass: "mdc-card-media mdc-card__media", class: _vm.classes, style: _vm.styles }, [_vm.$slots.default ? _c('div', { staticClass: "mdc-card__media-content" }, [_vm._t("default")], 2) : _vm._e()]);
    }, staticRenderFns: [],
    name: 'mdc-card-media',
    props: {
      src: String,
      square: Boolean
    },
    computed: {
      styles: function styles() {
        var styles = {
          backgroundImage: 'url(' + this.src + ')'
        };

        return styles;
      },
      classes: function classes() {
        return this.square ? 'mdc-card__media--square' : 'mdc-card__media--16-9';
      }
    }
  };

  var mdcCardHeader = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('section', { staticClass: "mdc-card-header mdc-card__primary" }, [_vm._t("default", [_vm.title ? _c('h1', { staticClass: "mdc-card__title", class: { 'mdc-card__title--large': _vm.largeTitle } }, [_vm._v(" " + _vm._s(_vm.title) + " ")]) : _vm._e(), _vm._v(" "), _vm.subtitle ? _c('h2', { staticClass: "mdc-card__subtitle" }, [_vm._v(" " + _vm._s(_vm.subtitle) + " ")]) : _vm._e()])], 2);
    }, staticRenderFns: [],
    name: 'mdc-card-header',
    props: {
      title: String,
      subtitle: String,
      'large-title': { type: Boolean, default: true }
    }
  };

  var mdcCardTitle = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('h1', { staticClass: "mdc-card-title mdc-card__title", class: { 'mdc-card__title--large': _vm.large } }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-card-title',
    props: {
      large: Boolean
    }
  };

  var mdcCardSubtitle = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('h2', { staticClass: "mdc-card-subtitle mdc-card__subtitle" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-card-subtitle'
  };

  var mdcCardText = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('section', { staticClass: "mdc-card-text mdc-card__supporting-text" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-card-text'
  };

  var mdcCardActions = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('section', { staticClass: "mdc-card-actions mdc-card__actions", class: _vm.classes }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-card-actions',
    props: {
      fullBleed: Boolean
    },
    computed: {
      classes: function classes() {
        return {
          'mdc-card__actions--full-bleed': this.fullBleed
        };
      }
    }
  };

  var mdcCardActionButtons = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-card-action-buttons mdc-card__action-buttons" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-card-action-buttons'
  };

  var mdcCardActionButton = {
    name: 'mdc-card-action-button',
    extends: mdcButtonBase,
    data: function data() {
      return {
        classes: {
          'mdc-button': true,
          'mdc-card__action': true,
          'mdc-card-action-button': true
        }
      };
    }
  };

  var mdcCardActionIcons = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-card-action-icons mdc-card__action-icons" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-card-action-icons'
  };

  var mdcCardActionIcon = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('span', _vm._g({ class: _vm.classes, style: _vm.styles }, _vm.listeners), [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2);
    }, staticRenderFns: [],
    name: 'mdc-card-action-icon',
    mixins: [DispatchEventMixin],
    props: {
      icon: String
    },
    data: function data() {
      return {
        classes: {
          'mdc-card-action-icon': true,
          'material-icons': !!this.icon,
          'mdc-card__action': true,
          'mdc-card__action--icon': true,
          'mdc-icon-toggle': true
        },
        styles: {}
      };
    },

    watch: {
      icon: function icon() {
        this.$set(this.classes, 'material-icons', !!this.icon);
      }
    },
    mounted: function mounted() {
      this.ripple = new RippleBase(this, {
        isUnbounded: function isUnbounded() {
          return true;
        }
      });
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.ripple.destroy();
    }
  };

  var VueMDCCard = BasePlugin({
    mdcCard: mdcCard,
    mdcCardPrimaryAction: mdcCardPrimaryAction,
    mdcCardMedia: mdcCardMedia,
    mdcCardHeader: mdcCardHeader,
    mdcCardTitle: mdcCardTitle,
    mdcCardSubtitle: mdcCardSubtitle,
    mdcCardText: mdcCardText,
    mdcCardActions: mdcCardActions,
    mdcCardActionButtons: mdcCardActionButtons,
    mdcCardActionButton: mdcCardActionButton,
    mdcCardActionIcons: mdcCardActionIcons,
    mdcCardActionIcon: mdcCardActionIcon
  });

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @template F
   */

  var MDCComponent = function () {
    createClass(MDCComponent, null, [{
      key: 'attachTo',

      /**
       * @param {!Element} root
       * @return {!MDCComponent}
       */
      value: function attachTo(root) {
        // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
        // returns an instantiated component with its root set to that element. Also note that in the cases of
        // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
        // from getDefaultFoundation().
        return new MDCComponent(root, new MDCFoundation());
      }

      /**
       * @param {!Element} root
       * @param {F=} foundation
       * @param {...?} args
       */

    }]);

    function MDCComponent(root) {
      var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      classCallCheck(this, MDCComponent);

      /** @protected {!Element} */
      this.root_ = root;

      for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      this.initialize.apply(this, args);
      // Note that we initialize foundation here and not within the constructor's default param so that
      // this.root_ is defined and can be used within the foundation class.
      /** @protected {!F} */
      this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
      this.foundation_.init();
      this.initialSyncWithDOM();
    }

    createClass(MDCComponent, [{
      key: 'initialize',
      value: function initialize() /* ...args */{}
      // Subclasses can override this to do any additional setup work that would be considered part of a
      // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
      // initialized. Any additional arguments besides root and foundation will be passed in here.


      /**
       * @return {!F} foundation
       */

    }, {
      key: 'getDefaultFoundation',
      value: function getDefaultFoundation() {
        // Subclasses must override this method to return a properly configured foundation class for the
        // component.
        throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
      }
    }, {
      key: 'initialSyncWithDOM',
      value: function initialSyncWithDOM() {
        // Subclasses should override this method if they need to perform work to synchronize with a host DOM
        // object. An example of this would be a form control wrapper that needs to synchronize its internal state
        // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
        // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        // Subclasses may implement this method to release any resources / deregister any listeners they have
        // attached. An example of this might be deregistering a resize event from the window object.
        this.foundation_.destroy();
      }

      /**
       * Wrapper method to add an event listener to the component's root element. This is most useful when
       * listening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: 'listen',
      value: function listen(evtType, handler) {
        this.root_.addEventListener(evtType, handler);
      }

      /**
       * Wrapper method to remove an event listener to the component's root element. This is most useful when
       * unlistening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: 'unlisten',
      value: function unlisten(evtType, handler) {
        this.root_.removeEventListener(evtType, handler);
      }

      /**
       * Fires a cross-browser-compatible custom event from the component root of the given type,
       * with the given data.
       * @param {string} evtType
       * @param {!Object} evtData
       * @param {boolean=} shouldBubble
       */

    }, {
      key: 'emit',
      value: function emit(evtType, evtData) {
        var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        var evt = void 0;
        if (typeof CustomEvent === 'function') {
          evt = new CustomEvent(evtType, {
            detail: evtData,
            bubbles: shouldBubble
          });
        } else {
          evt = document.createEvent('CustomEvent');
          evt.initCustomEvent(evtType, shouldBubble, false, evtData);
        }

        this.root_.dispatchEvent(evt);
      }
    }]);
    return MDCComponent;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends MDCComponent<!MDCRippleFoundation>
   */

  var MDCRipple = function (_MDCComponent) {
    inherits(MDCRipple, _MDCComponent);

    /** @param {...?} args */
    function MDCRipple() {
      var _ref;

      classCallCheck(this, MDCRipple);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      /** @type {boolean} */
      var _this = possibleConstructorReturn(this, (_ref = MDCRipple.__proto__ || Object.getPrototypeOf(MDCRipple)).call.apply(_ref, [this].concat(args)));

      _this.disabled = false;

      /** @private {boolean} */
      _this.unbounded_;
      return _this;
    }

    /**
     * @param {!Element} root
     * @param {{isUnbounded: (boolean|undefined)}=} options
     * @return {!MDCRipple}
     */


    createClass(MDCRipple, [{
      key: 'setUnbounded_',


      /**
       * Closure Compiler throws an access control error when directly accessing a
       * protected or private property inside a getter/setter, like unbounded above.
       * By accessing the protected property inside a method, we solve that problem.
       * That's why this function exists.
       * @private
       */
      value: function setUnbounded_() {
        this.foundation_.setUnbounded(this.unbounded_);
      }
    }, {
      key: 'activate',
      value: function activate() {
        this.foundation_.activate();
      }
    }, {
      key: 'deactivate',
      value: function deactivate() {
        this.foundation_.deactivate();
      }
    }, {
      key: 'layout',
      value: function layout() {
        this.foundation_.layout();
      }

      /** @return {!MDCRippleFoundation} */

    }, {
      key: 'getDefaultFoundation',
      value: function getDefaultFoundation() {
        return new MDCRippleFoundation(MDCRipple.createAdapter(this));
      }
    }, {
      key: 'initialSyncWithDOM',
      value: function initialSyncWithDOM() {
        this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
      }
    }, {
      key: 'unbounded',


      /** @return {boolean} */
      get: function get$$1() {
        return this.unbounded_;
      }

      /** @param {boolean} unbounded */
      ,
      set: function set$$1(unbounded) {
        this.unbounded_ = Boolean(unbounded);
        this.setUnbounded_();
      }
    }], [{
      key: 'attachTo',
      value: function attachTo(root) {
        var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            _ref2$isUnbounded = _ref2.isUnbounded,
            isUnbounded = _ref2$isUnbounded === undefined ? undefined : _ref2$isUnbounded;

        var ripple = new MDCRipple(root);
        // Only override unbounded behavior if option is explicitly specified
        if (isUnbounded !== undefined) {
          ripple.unbounded = /** @type {boolean} */isUnbounded;
        }
        return ripple;
      }

      /**
       * @param {!RippleCapableSurface} instance
       * @return {!MDCRippleAdapter}
       */

    }, {
      key: 'createAdapter',
      value: function createAdapter(instance) {
        var MATCHES = getMatchesProperty(HTMLElement.prototype);

        return {
          browserSupportsCssVars: function browserSupportsCssVars() {
            return supportsCssVariables(window);
          },
          isUnbounded: function isUnbounded() {
            return instance.unbounded;
          },
          isSurfaceActive: function isSurfaceActive() {
            return instance.root_[MATCHES](':active');
          },
          isSurfaceDisabled: function isSurfaceDisabled() {
            return instance.disabled;
          },
          addClass: function addClass(className) {
            return instance.root_.classList.add(className);
          },
          removeClass: function removeClass(className) {
            return instance.root_.classList.remove(className);
          },
          containsEventTarget: function containsEventTarget(target) {
            return instance.root_.contains(target);
          },
          registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
            return instance.root_.addEventListener(evtType, handler, applyPassive$1());
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
            return instance.root_.removeEventListener(evtType, handler, applyPassive$1());
          },
          registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
            return document.documentElement.addEventListener(evtType, handler, applyPassive$1());
          },
          deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
            return document.documentElement.removeEventListener(evtType, handler, applyPassive$1());
          },
          registerResizeHandler: function registerResizeHandler(handler) {
            return window.addEventListener('resize', handler);
          },
          deregisterResizeHandler: function deregisterResizeHandler(handler) {
            return window.removeEventListener('resize', handler);
          },
          updateCssVariable: function updateCssVariable(varName, value) {
            return instance.root_.style.setProperty(varName, value);
          },
          computeBoundingRect: function computeBoundingRect() {
            return instance.root_.getBoundingClientRect();
          },
          getWindowPageOffset: function getWindowPageOffset() {
            return { x: window.pageXOffset, y: window.pageYOffset };
          }
        };
      }
    }]);
    return MDCRipple;
  }(MDCComponent);

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @record
   */

  var MDCSelectionControl = function () {
    function MDCSelectionControl() {
      classCallCheck(this, MDCSelectionControl);
    }

    createClass(MDCSelectionControl, [{
      key: 'ripple',

      /** @return {?MDCRipple} */
      get: function get$$1() {}
    }]);
    return MDCSelectionControl;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Checkbox. Provides an interface for managing
   * - classes
   * - dom
   * - event handlers
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */

  var MDCCheckboxAdapter = function () {
    function MDCCheckboxAdapter() {
      classCallCheck(this, MDCCheckboxAdapter);
    }

    createClass(MDCCheckboxAdapter, [{
      key: 'addClass',

      /** @param {string} className */
      value: function addClass(className) {}

      /** @param {string} className */

    }, {
      key: 'removeClass',
      value: function removeClass(className) {}

      /**
       * Sets an attribute with a given value on the input element.
       * @param {string} attr
       * @param {string} value
       */

    }, {
      key: 'setNativeControlAttr',
      value: function setNativeControlAttr(attr, value) {}

      /**
       * Removes an attribute from the input element.
       * @param {string} attr
       */

    }, {
      key: 'removeNativeControlAttr',
      value: function removeNativeControlAttr(attr) {}

      /** @param {!EventListener} handler */

    }, {
      key: 'registerAnimationEndHandler',
      value: function registerAnimationEndHandler(handler) {}

      /** @param {!EventListener} handler */

    }, {
      key: 'deregisterAnimationEndHandler',
      value: function deregisterAnimationEndHandler(handler) {}

      /** @param {!EventListener} handler */

    }, {
      key: 'registerChangeHandler',
      value: function registerChangeHandler(handler) {}

      /** @param {!EventListener} handler */

    }, {
      key: 'deregisterChangeHandler',
      value: function deregisterChangeHandler(handler) {}

      /** @return {!MDCSelectionControlState} */

    }, {
      key: 'getNativeControl',
      value: function getNativeControl() {}
    }, {
      key: 'forceLayout',
      value: function forceLayout() {}

      /** @return {boolean} */

    }, {
      key: 'isAttachedToDOM',
      value: function isAttachedToDOM() {}
    }]);
    return MDCCheckboxAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @const {string} */
  var ROOT = 'mdc-checkbox';

  /** @enum {string} */
  var cssClasses$1 = {
    UPGRADED: 'mdc-checkbox--upgraded',
    CHECKED: 'mdc-checkbox--checked',
    INDETERMINATE: 'mdc-checkbox--indeterminate',
    DISABLED: 'mdc-checkbox--disabled',
    ANIM_UNCHECKED_CHECKED: 'mdc-checkbox--anim-unchecked-checked',
    ANIM_UNCHECKED_INDETERMINATE: 'mdc-checkbox--anim-unchecked-indeterminate',
    ANIM_CHECKED_UNCHECKED: 'mdc-checkbox--anim-checked-unchecked',
    ANIM_CHECKED_INDETERMINATE: 'mdc-checkbox--anim-checked-indeterminate',
    ANIM_INDETERMINATE_CHECKED: 'mdc-checkbox--anim-indeterminate-checked',
    ANIM_INDETERMINATE_UNCHECKED: 'mdc-checkbox--anim-indeterminate-unchecked'
  };

  /** @enum {string} */
  var strings$1 = {
    NATIVE_CONTROL_SELECTOR: '.' + ROOT + '__native-control',
    TRANSITION_STATE_INIT: 'init',
    TRANSITION_STATE_CHECKED: 'checked',
    TRANSITION_STATE_UNCHECKED: 'unchecked',
    TRANSITION_STATE_INDETERMINATE: 'indeterminate',
    ARIA_CHECKED_ATTR: 'aria-checked',
    ARIA_CHECKED_INDETERMINATE_VALUE: 'mixed'
  };

  /** @enum {number} */
  var numbers$1 = {
    ANIM_END_LATCH_MS: 250
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @const {!Array<string>} */
  var CB_PROTO_PROPS = ['checked', 'indeterminate'];

  /**
   * @extends {MDCFoundation<!MDCCheckboxAdapter>}
   */

  var MDCCheckboxFoundation = function (_MDCFoundation) {
    inherits(MDCCheckboxFoundation, _MDCFoundation);
    createClass(MDCCheckboxFoundation, null, [{
      key: 'cssClasses',

      /** @return enum {cssClasses} */
      get: function get$$1() {
        return cssClasses$1;
      }

      /** @return enum {strings} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$1;
      }

      /** @return enum {numbers} */

    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers$1;
      }

      /** @return {!MDCCheckboxAdapter} */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCCheckboxAdapter} */{
            addClass: function addClass() /* className: string */{},
            removeClass: function removeClass() /* className: string */{},
            setNativeControlAttr: function setNativeControlAttr() /* attr: string, value: string */{},
            removeNativeControlAttr: function removeNativeControlAttr() /* attr: string */{},
            registerAnimationEndHandler: function registerAnimationEndHandler() /* handler: EventListener */{},
            deregisterAnimationEndHandler: function deregisterAnimationEndHandler() /* handler: EventListener */{},
            registerChangeHandler: function registerChangeHandler() /* handler: EventListener */{},
            deregisterChangeHandler: function deregisterChangeHandler() /* handler: EventListener */{},
            getNativeControl: function getNativeControl() /* !MDCSelectionControlState */{},
            forceLayout: function forceLayout() {},
            isAttachedToDOM: function isAttachedToDOM() /* boolean */{}
          }
        );
      }
    }]);

    function MDCCheckboxFoundation(adapter) {
      classCallCheck(this, MDCCheckboxFoundation);

      /** @private {string} */
      var _this = possibleConstructorReturn(this, (MDCCheckboxFoundation.__proto__ || Object.getPrototypeOf(MDCCheckboxFoundation)).call(this, _extends(MDCCheckboxFoundation.defaultAdapter, adapter)));

      _this.currentCheckState_ = strings$1.TRANSITION_STATE_INIT;

      /** @private {string} */
      _this.currentAnimationClass_ = '';

      /** @private {number} */
      _this.animEndLatchTimer_ = 0;

      _this.animEndHandler_ = /** @private {!EventListener} */function () {
        return _this.handleAnimationEnd();
      };

      _this.changeHandler_ = /** @private {!EventListener} */function () {
        return _this.handleChange();
      };
      return _this;
    }

    createClass(MDCCheckboxFoundation, [{
      key: 'init',
      value: function init() {
        this.currentCheckState_ = this.determineCheckState_(this.getNativeControl_());
        this.updateAriaChecked_();
        this.adapter_.addClass(cssClasses$1.UPGRADED);
        this.adapter_.registerChangeHandler(this.changeHandler_);
        this.installPropertyChangeHooks_();
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterChangeHandler(this.changeHandler_);
        this.uninstallPropertyChangeHooks_();
      }

      /** @return {boolean} */

    }, {
      key: 'isChecked',
      value: function isChecked() {
        return this.getNativeControl_().checked;
      }

      /** @param {boolean} checked */

    }, {
      key: 'setChecked',
      value: function setChecked(checked) {
        this.getNativeControl_().checked = checked;
      }

      /** @return {boolean} */

    }, {
      key: 'isIndeterminate',
      value: function isIndeterminate() {
        return this.getNativeControl_().indeterminate;
      }

      /** @param {boolean} indeterminate */

    }, {
      key: 'setIndeterminate',
      value: function setIndeterminate(indeterminate) {
        this.getNativeControl_().indeterminate = indeterminate;
      }

      /** @return {boolean} */

    }, {
      key: 'isDisabled',
      value: function isDisabled() {
        return this.getNativeControl_().disabled;
      }

      /** @param {boolean} disabled */

    }, {
      key: 'setDisabled',
      value: function setDisabled(disabled) {
        this.getNativeControl_().disabled = disabled;
        if (disabled) {
          this.adapter_.addClass(cssClasses$1.DISABLED);
        } else {
          this.adapter_.removeClass(cssClasses$1.DISABLED);
        }
      }

      /** @return {?string} */

    }, {
      key: 'getValue',
      value: function getValue() {
        return this.getNativeControl_().value;
      }

      /** @param {?string} value */

    }, {
      key: 'setValue',
      value: function setValue(value) {
        this.getNativeControl_().value = value;
      }

      /**
       * Handles the animationend event for the checkbox
       */

    }, {
      key: 'handleAnimationEnd',
      value: function handleAnimationEnd() {
        var _this2 = this;

        clearTimeout(this.animEndLatchTimer_);
        this.animEndLatchTimer_ = setTimeout(function () {
          _this2.adapter_.removeClass(_this2.currentAnimationClass_);
          _this2.adapter_.deregisterAnimationEndHandler(_this2.animEndHandler_);
        }, numbers$1.ANIM_END_LATCH_MS);
      }

      /**
       * Handles the change event for the checkbox
       */

    }, {
      key: 'handleChange',
      value: function handleChange() {
        this.transitionCheckState_();
      }

      /** @private */

    }, {
      key: 'installPropertyChangeHooks_',
      value: function installPropertyChangeHooks_() {
        var _this3 = this;

        var nativeCb = this.getNativeControl_();
        var cbProto = Object.getPrototypeOf(nativeCb);

        CB_PROTO_PROPS.forEach(function (controlState) {
          var desc = Object.getOwnPropertyDescriptor(cbProto, controlState);
          // We have to check for this descriptor, since some browsers (Safari) don't support its return.
          // See: https://bugs.webkit.org/show_bug.cgi?id=49739
          if (validDescriptor(desc)) {
            var nativeCbDesc = /** @type {!ObjectPropertyDescriptor} */{
              get: desc.get,
              set: function set$$1(state) {
                desc.set.call(nativeCb, state);
                _this3.transitionCheckState_();
              },
              configurable: desc.configurable,
              enumerable: desc.enumerable
            };
            Object.defineProperty(nativeCb, controlState, nativeCbDesc);
          }
        });
      }

      /** @private */

    }, {
      key: 'uninstallPropertyChangeHooks_',
      value: function uninstallPropertyChangeHooks_() {
        var nativeCb = this.getNativeControl_();
        var cbProto = Object.getPrototypeOf(nativeCb);

        CB_PROTO_PROPS.forEach(function (controlState) {
          var desc = /** @type {!ObjectPropertyDescriptor} */Object.getOwnPropertyDescriptor(cbProto, controlState);
          if (validDescriptor(desc)) {
            Object.defineProperty(nativeCb, controlState, desc);
          }
        });
      }

      /** @private */

    }, {
      key: 'transitionCheckState_',
      value: function transitionCheckState_() {
        var nativeCb = this.adapter_.getNativeControl();
        if (!nativeCb) {
          return;
        }
        var oldState = this.currentCheckState_;
        var newState = this.determineCheckState_(nativeCb);
        if (oldState === newState) {
          return;
        }

        this.updateAriaChecked_();

        // Check to ensure that there isn't a previously existing animation class, in case for example
        // the user interacted with the checkbox before the animation was finished.
        if (this.currentAnimationClass_.length > 0) {
          clearTimeout(this.animEndLatchTimer_);
          this.adapter_.forceLayout();
          this.adapter_.removeClass(this.currentAnimationClass_);
        }

        this.currentAnimationClass_ = this.getTransitionAnimationClass_(oldState, newState);
        this.currentCheckState_ = newState;

        // Check for parentNode so that animations are only run when the element is attached
        // to the DOM.
        if (this.adapter_.isAttachedToDOM() && this.currentAnimationClass_.length > 0) {
          this.adapter_.addClass(this.currentAnimationClass_);
          this.adapter_.registerAnimationEndHandler(this.animEndHandler_);
        }
      }

      /**
       * @param {!MDCSelectionControlState} nativeCb
       * @return {string}
       * @private
       */

    }, {
      key: 'determineCheckState_',
      value: function determineCheckState_(nativeCb) {
        var TRANSITION_STATE_INDETERMINATE = strings$1.TRANSITION_STATE_INDETERMINATE,
            TRANSITION_STATE_CHECKED = strings$1.TRANSITION_STATE_CHECKED,
            TRANSITION_STATE_UNCHECKED = strings$1.TRANSITION_STATE_UNCHECKED;


        if (nativeCb.indeterminate) {
          return TRANSITION_STATE_INDETERMINATE;
        }
        return nativeCb.checked ? TRANSITION_STATE_CHECKED : TRANSITION_STATE_UNCHECKED;
      }

      /**
       * @param {string} oldState
       * @param {string} newState
       * @return {string}
       */

    }, {
      key: 'getTransitionAnimationClass_',
      value: function getTransitionAnimationClass_(oldState, newState) {
        var TRANSITION_STATE_INIT = strings$1.TRANSITION_STATE_INIT,
            TRANSITION_STATE_CHECKED = strings$1.TRANSITION_STATE_CHECKED,
            TRANSITION_STATE_UNCHECKED = strings$1.TRANSITION_STATE_UNCHECKED;
        var _MDCCheckboxFoundatio = MDCCheckboxFoundation.cssClasses,
            ANIM_UNCHECKED_CHECKED = _MDCCheckboxFoundatio.ANIM_UNCHECKED_CHECKED,
            ANIM_UNCHECKED_INDETERMINATE = _MDCCheckboxFoundatio.ANIM_UNCHECKED_INDETERMINATE,
            ANIM_CHECKED_UNCHECKED = _MDCCheckboxFoundatio.ANIM_CHECKED_UNCHECKED,
            ANIM_CHECKED_INDETERMINATE = _MDCCheckboxFoundatio.ANIM_CHECKED_INDETERMINATE,
            ANIM_INDETERMINATE_CHECKED = _MDCCheckboxFoundatio.ANIM_INDETERMINATE_CHECKED,
            ANIM_INDETERMINATE_UNCHECKED = _MDCCheckboxFoundatio.ANIM_INDETERMINATE_UNCHECKED;


        switch (oldState) {
          case TRANSITION_STATE_INIT:
            if (newState === TRANSITION_STATE_UNCHECKED) {
              return '';
            }
          // fallthrough
          case TRANSITION_STATE_UNCHECKED:
            return newState === TRANSITION_STATE_CHECKED ? ANIM_UNCHECKED_CHECKED : ANIM_UNCHECKED_INDETERMINATE;
          case TRANSITION_STATE_CHECKED:
            return newState === TRANSITION_STATE_UNCHECKED ? ANIM_CHECKED_UNCHECKED : ANIM_CHECKED_INDETERMINATE;
          // TRANSITION_STATE_INDETERMINATE
          default:
            return newState === TRANSITION_STATE_CHECKED ? ANIM_INDETERMINATE_CHECKED : ANIM_INDETERMINATE_UNCHECKED;
        }
      }
    }, {
      key: 'updateAriaChecked_',
      value: function updateAriaChecked_() {
        // Ensure aria-checked is set to mixed if checkbox is in indeterminate state.
        if (this.isIndeterminate()) {
          this.adapter_.setNativeControlAttr(strings$1.ARIA_CHECKED_ATTR, strings$1.ARIA_CHECKED_INDETERMINATE_VALUE);
        } else {
          this.adapter_.removeNativeControlAttr(strings$1.ARIA_CHECKED_ATTR);
        }
      }

      /**
       * @return {!MDCSelectionControlState}
       * @private
       */

    }, {
      key: 'getNativeControl_',
      value: function getNativeControl_() {
        return this.adapter_.getNativeControl() || {
          checked: false,
          indeterminate: false,
          disabled: false,
          value: null
        };
      }
    }]);
    return MDCCheckboxFoundation;
  }(MDCFoundation);

  /**
   * @param {ObjectPropertyDescriptor|undefined} inputPropDesc
   * @return {boolean}
   */


  function validDescriptor(inputPropDesc) {
    return !!inputPropDesc && typeof inputPropDesc.set === 'function';
  }

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Form Field. Provides an interface for managing
   * - event handlers
   * - ripple activation
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCFormFieldAdapter = function () {
    function MDCFormFieldAdapter() {
      classCallCheck(this, MDCFormFieldAdapter);
    }

    createClass(MDCFormFieldAdapter, [{
      key: "registerInteractionHandler",

      /**
       * @param {string} type
       * @param {!EventListener} handler
       */
      value: function registerInteractionHandler(type, handler) {}

      /**
       * @param {string} type
       * @param {!EventListener} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(type, handler) {}
    }, {
      key: "activateInputRipple",
      value: function activateInputRipple() {}
    }, {
      key: "deactivateInputRipple",
      value: function deactivateInputRipple() {}
    }]);
    return MDCFormFieldAdapter;
  }();

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses$2 = {
    ROOT: 'mdc-form-field'
  };

  /** @enum {string} */
  var strings$2 = {
    LABEL_SELECTOR: '.mdc-form-field > label'
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCFormFieldAdapter>}
   */

  var MDCFormFieldFoundation = function (_MDCFoundation) {
    inherits(MDCFormFieldFoundation, _MDCFoundation);
    createClass(MDCFormFieldFoundation, null, [{
      key: 'cssClasses',

      /** @return enum {cssClasses} */
      get: function get$$1() {
        return cssClasses$2;
      }

      /** @return enum {strings} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$2;
      }

      /** @return {!MDCFormFieldAdapter} */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
          activateInputRipple: function activateInputRipple() {},
          deactivateInputRipple: function deactivateInputRipple() {}
        };
      }
    }]);

    function MDCFormFieldFoundation(adapter) {
      classCallCheck(this, MDCFormFieldFoundation);

      /** @private {!EventListener} */
      var _this = possibleConstructorReturn(this, (MDCFormFieldFoundation.__proto__ || Object.getPrototypeOf(MDCFormFieldFoundation)).call(this, _extends(MDCFormFieldFoundation.defaultAdapter, adapter)));

      _this.clickHandler_ = /** @type {!EventListener} */function () {
        return _this.handleClick_();
      };
      return _this;
    }

    createClass(MDCFormFieldFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.registerInteractionHandler('click', this.clickHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
      }

      /** @private */

    }, {
      key: 'handleClick_',
      value: function handleClick_() {
        var _this2 = this;

        this.adapter_.activateInputRipple();
        requestAnimationFrame(function () {
          return _this2.adapter_.deactivateInputRipple();
        });
      }
    }]);
    return MDCFormFieldFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @const {Object<string, !VendorPropertyMapType>} */
  var eventTypeMap = {
    'animationstart': {
      noPrefix: 'animationstart',
      webkitPrefix: 'webkitAnimationStart',
      styleProperty: 'animation'
    },
    'animationend': {
      noPrefix: 'animationend',
      webkitPrefix: 'webkitAnimationEnd',
      styleProperty: 'animation'
    },
    'animationiteration': {
      noPrefix: 'animationiteration',
      webkitPrefix: 'webkitAnimationIteration',
      styleProperty: 'animation'
    },
    'transitionend': {
      noPrefix: 'transitionend',
      webkitPrefix: 'webkitTransitionEnd',
      styleProperty: 'transition'
    }
  };

  /** @const {Object<string, !VendorPropertyMapType>} */
  var cssPropertyMap = {
    'animation': {
      noPrefix: 'animation',
      webkitPrefix: '-webkit-animation'
    },
    'transform': {
      noPrefix: 'transform',
      webkitPrefix: '-webkit-transform'
    },
    'transition': {
      noPrefix: 'transition',
      webkitPrefix: '-webkit-transition'
    }
  };

  /**
   * @param {!Object} windowObj
   * @return {boolean}
   */
  function hasProperShape(windowObj) {
    return windowObj['document'] !== undefined && typeof windowObj['document']['createElement'] === 'function';
  }

  /**
   * @param {string} eventType
   * @return {boolean}
   */
  function eventFoundInMaps(eventType) {
    return eventType in eventTypeMap || eventType in cssPropertyMap;
  }

  /**
   * @param {string} eventType
   * @param {!Object<string, !VendorPropertyMapType>} map
   * @param {!Element} el
   * @return {string}
   */
  function getJavaScriptEventName(eventType, map, el) {
    return map[eventType].styleProperty in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
  }

  /**
   * Helper function to determine browser prefix for CSS3 animation events
   * and property names.
   * @param {!Object} windowObj
   * @param {string} eventType
   * @return {string}
   */
  function getAnimationName(windowObj, eventType) {
    if (!hasProperShape(windowObj) || !eventFoundInMaps(eventType)) {
      return eventType;
    }

    var map = /** @type {!Object<string, !VendorPropertyMapType>} */eventType in eventTypeMap ? eventTypeMap : cssPropertyMap;
    var el = windowObj['document']['createElement']('div');
    var eventName = '';

    if (map === eventTypeMap) {
      eventName = getJavaScriptEventName(eventType, map, el);
    } else {
      eventName = map[eventType].noPrefix in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
    }

    return eventName;
  }

  // Public functions to access getAnimationName() for JavaScript events or CSS
  // property names.

  var transformStyleProperties = ['transform', 'WebkitTransform', 'MozTransform', 'OTransform', 'MSTransform'];

  /**
   * @param {!Object} windowObj
   * @param {string} eventType
   * @return {string}
   */
  function getCorrectEventName(windowObj, eventType) {
    return getAnimationName(windowObj, eventType);
  }

  /**
   * @param {!Object} windowObj
   * @param {string} eventType
   * @return {string}
   */
  function getCorrectPropertyName(windowObj, eventType) {
    return getAnimationName(windowObj, eventType);
  }

  var mdcCheckbox = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-checkbox-wrapper", class: _vm.formFieldClasses }, [_c('div', { ref: "root", staticClass: "mdc-checkbox", class: _vm.classes, style: _vm.styles }, [_c('input', { ref: "control", staticClass: "mdc-checkbox__native-control", attrs: { "id": _vm.vma_uid_, "name": _vm.name, "type": "checkbox" }, domProps: { "value": _vm.value }, on: { "change": _vm.onChange } }), _vm._v(" "), _c('div', { staticClass: "mdc-checkbox__background" }, [_c('svg', { staticClass: "mdc-checkbox__checkmark", attrs: { "viewBox": "0 0 24 24" } }, [_c('path', { staticClass: "mdc-checkbox__checkmark-path", attrs: { "fill": "none", "stroke": "white", "d": "M1.73,12.91 8.1,19.28 22.79,4.59" } })]), _vm._v(" "), _c('div', { staticClass: "mdc-checkbox__mixedmark" })])]), _vm._v(" "), _c('label', { ref: "label", attrs: { "for": _vm.vma_uid_ } }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2)]);
    }, staticRenderFns: [],
    name: 'mdc-checkbox',
    mixins: [DispatchFocusMixin, VMAUniqueIdMixin],
    model: {
      prop: 'checked',
      event: 'change'
    },
    props: {
      checked: [Boolean, Array],
      indeterminate: Boolean,
      disabled: Boolean,
      label: String,
      'align-end': Boolean,
      value: {
        type: [String, Number],
        default: function _default() {
          return 'on';
        }
      },
      name: String
    },
    data: function data() {
      return {
        styles: {},
        classes: {}
      };
    },

    computed: {
      hasLabel: function hasLabel() {
        return this.label || this.$slots.default;
      },
      formFieldClasses: function formFieldClasses() {
        return {
          'mdc-form-field': this.hasLabel,
          'mdc-form-field--align-end': this.hasLabel && this.alignEnd
        };
      }
    },
    watch: {
      checked: 'setChecked',
      disabled: function disabled(value) {
        this.foundation.setDisabled(value);
      },
      indeterminate: function indeterminate(value) {
        this.foundation.setIndeterminate(value);
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCCheckboxFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        setNativeControlAttr: function setNativeControlAttr(attr, value) {
          _this.$refs.control.setAttribute(attr, value);
        },
        removeNativeControlAttr: function removeNativeControlAttr(attr) {
          _this.$refs.control.removeAttribute(attr);
        },
        registerAnimationEndHandler: function registerAnimationEndHandler(handler) {
          return _this.$refs.root.addEventListener(getCorrectEventName(window, 'animationend'), handler);
        },
        deregisterAnimationEndHandler: function deregisterAnimationEndHandler(handler) {
          return _this.$refs.root.removeEventListener(getCorrectEventName(window, 'animationend'), handler);
        },
        registerChangeHandler: function registerChangeHandler(handler) {
          return _this.$refs.control.addEventListener('change', handler);
        },
        deregisterChangeHandler: function deregisterChangeHandler(handler) {
          return _this.$refs.control.removeEventListener('change', handler);
        },
        getNativeControl: function getNativeControl() {
          return _this.$refs.control;
        },
        forceLayout: function forceLayout() {
          return _this.$refs.root.offsetWidth;
        },
        isAttachedToDOM: function isAttachedToDOM() {
          return Boolean(_this.$el.parentNode);
        }
      });

      this.ripple = new RippleBase(this, {
        isUnbounded: function isUnbounded() {
          return true;
        },
        isSurfaceActive: function isSurfaceActive() {
          return RippleBase.isSurfaceActive(_this.$refs.control);
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          _this.$refs.control.addEventListener(evt, handler, applyPassive());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          _this.$refs.control.removeEventListener(evt, handler, applyPassive());
        },
        computeBoundingRect: function computeBoundingRect() {
          return _this.$refs.root.getBoundingClientRect();
        }
      });

      this.formField = new MDCFormFieldFoundation({
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          _this.$refs.label.addEventListener(type, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          _this.$refs.label.removeEventListener(type, handler);
        },
        activateInputRipple: function activateInputRipple() {
          _this.ripple && _this.ripple.activate();
        },
        deactivateInputRipple: function deactivateInputRipple() {
          _this.ripple && _this.ripple.deactivate();
        }
      });

      this.foundation.init();
      this.ripple.init();
      this.formField.init();
      this.setChecked(this.checked);
      this.foundation.setDisabled(this.disabled);
      this.foundation.setIndeterminate(this.indeterminate);
    },
    beforeDestroy: function beforeDestroy() {
      this.formField.destroy();
      this.ripple.destroy();
      this.foundation.destroy();
    },

    methods: {
      setChecked: function setChecked(checked) {
        this.foundation.setChecked(Array.isArray(checked) ? checked.indexOf(this.value) > -1 : checked);
      },
      onChange: function onChange() {
        this.$emit('update:indeterminate', this.foundation.isIndeterminate());
        var isChecked = this.foundation.isChecked();

        if (Array.isArray(this.checked)) {
          var idx = this.checked.indexOf(this.value);
          if (isChecked) {
            idx < 0 && this.$emit('change', this.checked.concat(this.value));
          } else {
            idx > -1 && this.$emit('change', this.checked.slice(0, idx).concat(this.checked.slice(idx + 1)));
          }
        } else {
          this.$emit('change', isChecked);
        }
      }
    }
  };

  var VueMDCCheckbox = BasePlugin({
    mdcCheckbox: mdcCheckbox
  });

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Chip.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Chip into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCChipAdapter = function () {
    function MDCChipAdapter() {
      classCallCheck(this, MDCChipAdapter);
    }

    createClass(MDCChipAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the root element.
       * @param {string} className
       */
      value: function addClass(className) {}

      /**
       * Removes a class from the root element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * Returns true if the root element contains the given class.
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}

      /**
       * Adds a class to the leading icon element.
       * @param {string} className
       */

    }, {
      key: "addClassToLeadingIcon",
      value: function addClassToLeadingIcon(className) {}

      /**
       * Removes a class from the leading icon element.
       * @param {string} className
       */

    }, {
      key: "removeClassFromLeadingIcon",
      value: function removeClassFromLeadingIcon(className) {}

      /**
       * Returns true if target has className, false otherwise.
       * @param {!EventTarget} target
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "eventTargetHasClass",
      value: function eventTargetHasClass(target, className) {}

      /**
       * Registers an event listener on the root element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerEventHandler",
      value: function registerEventHandler(evtType, handler) {}

      /**
       * Deregisters an event listener on the root element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterEventHandler",
      value: function deregisterEventHandler(evtType, handler) {}

      /**
       * Registers an event listener on the trailing icon element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerTrailingIconInteractionHandler",
      value: function registerTrailingIconInteractionHandler(evtType, handler) {}

      /**
       * Deregisters an event listener on the trailing icon element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterTrailingIconInteractionHandler",
      value: function deregisterTrailingIconInteractionHandler(evtType, handler) {}

      /**
       * Emits a custom "MDCChip:interaction" event denoting the chip has been
       * interacted with (typically on click or keydown).
       */

    }, {
      key: "notifyInteraction",
      value: function notifyInteraction() {}

      /**
       * Emits a custom "MDCChip:trailingIconInteraction" event denoting the trailing icon has been
       * interacted with (typically on click or keydown).
       */

    }, {
      key: "notifyTrailingIconInteraction",
      value: function notifyTrailingIconInteraction() {}

      /**
       * Emits a custom event "MDCChip:removal" denoting the chip will be removed.
       */

    }, {
      key: "notifyRemoval",
      value: function notifyRemoval() {}

      /**
       * Returns the computed property value of the given style property on the root element.
       * @param {string} propertyName
       * @return {string}
       */

    }, {
      key: "getComputedStyleValue",
      value: function getComputedStyleValue(propertyName) {}

      /**
       * Sets the property value of the given style property on the root element.
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setStyleProperty",
      value: function setStyleProperty(propertyName, value) {}
    }]);
    return MDCChipAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings$3 = {
    ENTRY_ANIMATION_NAME: 'mdc-chip-entry',
    INTERACTION_EVENT: 'MDCChip:interaction',
    TRAILING_ICON_INTERACTION_EVENT: 'MDCChip:trailingIconInteraction',
    REMOVAL_EVENT: 'MDCChip:removal',
    CHECKMARK_SELECTOR: '.mdc-chip__checkmark',
    LEADING_ICON_SELECTOR: '.mdc-chip__icon--leading',
    TRAILING_ICON_SELECTOR: '.mdc-chip__icon--trailing'
  };

  /** @enum {string} */
  var cssClasses$3 = {
    CHECKMARK: 'mdc-chip__checkmark',
    CHIP_EXIT: 'mdc-chip--exit',
    HIDDEN_LEADING_ICON: 'mdc-chip__icon--leading-hidden',
    LEADING_ICON: 'mdc-chip__icon--leading',
    TRAILING_ICON: 'mdc-chip__icon--trailing',
    SELECTED: 'mdc-chip--selected'
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCChipAdapter>}
   * @final
   */

  var MDCChipFoundation = function (_MDCFoundation) {
    inherits(MDCChipFoundation, _MDCFoundation);
    createClass(MDCChipFoundation, null, [{
      key: 'strings',

      /** @return enum {string} */
      get: function get$$1() {
        return strings$3;
      }

      /** @return enum {string} */

    }, {
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$3;
      }

      /**
       * {@see MDCChipAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCChipAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCChipAdapter} */{
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {},
            addClassToLeadingIcon: function addClassToLeadingIcon() {},
            removeClassFromLeadingIcon: function removeClassFromLeadingIcon() {},
            eventTargetHasClass: function eventTargetHasClass() {},
            registerEventHandler: function registerEventHandler() {},
            deregisterEventHandler: function deregisterEventHandler() {},
            registerTrailingIconInteractionHandler: function registerTrailingIconInteractionHandler() {},
            deregisterTrailingIconInteractionHandler: function deregisterTrailingIconInteractionHandler() {},
            notifyInteraction: function notifyInteraction() {},
            notifyTrailingIconInteraction: function notifyTrailingIconInteraction() {},
            notifyRemoval: function notifyRemoval() {},
            getComputedStyleValue: function getComputedStyleValue() {},
            setStyleProperty: function setStyleProperty() {}
          }
        );
      }

      /**
       * @param {!MDCChipAdapter} adapter
       */

    }]);

    function MDCChipFoundation(adapter) {
      classCallCheck(this, MDCChipFoundation);

      /**
       * Whether a trailing icon click should immediately trigger exit/removal of the chip.
       * @private {boolean}
       * */
      var _this = possibleConstructorReturn(this, (MDCChipFoundation.__proto__ || Object.getPrototypeOf(MDCChipFoundation)).call(this, _extends(MDCChipFoundation.defaultAdapter, adapter)));

      _this.shouldRemoveOnTrailingIconClick_ = true;
      /** @private {function(!Event): undefined} */
      _this.interactionHandler_ = function (evt) {
        return _this.handleInteraction(evt);
      };
      /** @private {function(!Event): undefined} */
      _this.transitionEndHandler_ = function (evt) {
        return _this.handleTransitionEnd(evt);
      };
      /** @private {function(!Event): undefined} */
      _this.trailingIconInteractionHandler_ = function (evt) {
        return _this.handleTrailingIconInteraction(evt);
      };
      return _this;
    }

    createClass(MDCChipFoundation, [{
      key: 'init',
      value: function init() {
        var _this2 = this;

        ['click', 'keydown'].forEach(function (evtType) {
          _this2.adapter_.registerEventHandler(evtType, _this2.interactionHandler_);
        });
        this.adapter_.registerEventHandler('transitionend', this.transitionEndHandler_);
        ['click', 'keydown', 'touchstart', 'pointerdown', 'mousedown'].forEach(function (evtType) {
          _this2.adapter_.registerTrailingIconInteractionHandler(evtType, _this2.trailingIconInteractionHandler_);
        });
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this3 = this;

        ['click', 'keydown'].forEach(function (evtType) {
          _this3.adapter_.deregisterEventHandler(evtType, _this3.interactionHandler_);
        });
        this.adapter_.deregisterEventHandler('transitionend', this.transitionEndHandler_);
        ['click', 'keydown', 'touchstart', 'pointerdown', 'mousedown'].forEach(function (evtType) {
          _this3.adapter_.deregisterTrailingIconInteractionHandler(evtType, _this3.trailingIconInteractionHandler_);
        });
      }

      /**
       * @return {boolean}
       */

    }, {
      key: 'isSelected',
      value: function isSelected() {
        return this.adapter_.hasClass(cssClasses$3.SELECTED);
      }

      /**
       * @param {boolean} selected
       */

    }, {
      key: 'setSelected',
      value: function setSelected(selected) {
        if (selected) {
          this.adapter_.addClass(cssClasses$3.SELECTED);
        } else {
          this.adapter_.removeClass(cssClasses$3.SELECTED);
        }
      }

      /**
       * @return {boolean}
       */

    }, {
      key: 'getShouldRemoveOnTrailingIconClick',
      value: function getShouldRemoveOnTrailingIconClick() {
        return this.shouldRemoveOnTrailingIconClick_;
      }

      /**
       * @param {boolean} shouldRemove
       */

    }, {
      key: 'setShouldRemoveOnTrailingIconClick',
      value: function setShouldRemoveOnTrailingIconClick(shouldRemove) {
        this.shouldRemoveOnTrailingIconClick_ = shouldRemove;
      }

      /**
       * Begins the exit animation which leads to removal of the chip.
       */

    }, {
      key: 'beginExit',
      value: function beginExit() {
        this.adapter_.addClass(cssClasses$3.CHIP_EXIT);
      }

      /**
       * Handles an interaction event on the root element.
       * @param {!Event} evt
       */

    }, {
      key: 'handleInteraction',
      value: function handleInteraction(evt) {
        if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
          this.adapter_.notifyInteraction();
        }
      }

      /**
       * Handles a transition end event on the root element.
       * @param {!Event} evt
       */

    }, {
      key: 'handleTransitionEnd',
      value: function handleTransitionEnd(evt) {
        var _this4 = this;

        // Handle transition end event on the chip when it is about to be removed.
        if (this.adapter_.eventTargetHasClass( /** @type {!EventTarget} */evt.target, cssClasses$3.CHIP_EXIT)) {
          if (evt.propertyName === 'width') {
            this.adapter_.notifyRemoval();
          } else if (evt.propertyName === 'opacity') {
            // See: https://css-tricks.com/using-css-transitions-auto-dimensions/#article-header-id-5
            var chipWidth = this.adapter_.getComputedStyleValue('width');

            // On the next frame (once we get the computed width), explicitly set the chip's width
            // to its current pixel width, so we aren't transitioning out of 'auto'.
            requestAnimationFrame(function () {
              _this4.adapter_.setStyleProperty('width', chipWidth);

              // To mitigate jitter, start transitioning padding and margin before width.
              _this4.adapter_.setStyleProperty('padding', '0');
              _this4.adapter_.setStyleProperty('margin', '0');

              // On the next frame (once width is explicitly set), transition width to 0.
              requestAnimationFrame(function () {
                _this4.adapter_.setStyleProperty('width', '0');
              });
            });
          }
          return;
        }

        // Handle a transition end event on the leading icon or checkmark, since the transition end event bubbles.
        if (evt.propertyName !== 'opacity') {
          return;
        }
        if (this.adapter_.eventTargetHasClass( /** @type {!EventTarget} */evt.target, cssClasses$3.LEADING_ICON) && this.adapter_.hasClass(cssClasses$3.SELECTED)) {
          this.adapter_.addClassToLeadingIcon(cssClasses$3.HIDDEN_LEADING_ICON);
        } else if (this.adapter_.eventTargetHasClass( /** @type {!EventTarget} */evt.target, cssClasses$3.CHECKMARK) && !this.adapter_.hasClass(cssClasses$3.SELECTED)) {
          this.adapter_.removeClassFromLeadingIcon(cssClasses$3.HIDDEN_LEADING_ICON);
        }
      }

      /**
       * Handles an interaction event on the trailing icon element. This is used to
       * prevent the ripple from activating on interaction with the trailing icon.
       * @param {!Event} evt
       */

    }, {
      key: 'handleTrailingIconInteraction',
      value: function handleTrailingIconInteraction(evt) {
        evt.stopPropagation();
        if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
          this.adapter_.notifyTrailingIconInteraction();
          if (this.shouldRemoveOnTrailingIconClick_) {
            this.beginExit();
          }
        }
      }
    }]);
    return MDCChipFoundation;
  }(MDCFoundation);

  var mdcChip = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', _vm._g({ class: _vm.classes, style: _vm.styles, attrs: { "tabindex": "0" } }, _vm.$listeners), [_vm.haveleadingIcon ? _c('i', { ref: "leadingIcon", staticClass: "mdc-chip__icon mdc-chip__icon--leading", class: _vm.leadingClasses }, [_vm._v(_vm._s(_vm.leadingIcon))]) : _vm._e(), _vm._v(" "), _vm.isFilter ? _c('div', { staticClass: "mdc-chip__checkmark" }, [_c('svg', { staticClass: "mdc-chip__checkmark-svg", attrs: { "viewBox": "-2 -3 30 30" } }, [_c('path', { staticClass: "mdc-chip__checkmark-path", attrs: { "fill": "none", "stroke": "black", "d": "M1.73,12.91 8.1,19.28 22.79,4.59" } })])]) : _vm._e(), _vm._v(" "), _c('div', { staticClass: "mdc-chip__text" }, [_vm._t("default")], 2), _vm._v(" "), _vm.havetrailingIcon ? _c('i', { ref: "trailingIcon", staticClass: "mdc-chip__icon mdc-chip__icon--trailing", class: _vm.trailingClasses, attrs: { "tabindex": "0", "role": "button" } }, [_vm._v(_vm._s(_vm.trailingIcon))]) : _vm._e()]);
    }, staticRenderFns: [],
    name: 'mdc-chip',
    mixins: [CustomLinkMixin],
    props: {
      leadingIcon: [String],
      trailingIcon: [String],
      leadingIconClasses: [Object],
      trailingIconClasses: [Object]
    },
    inject: ['mdcChipSet'],
    data: function data() {
      return {
        classes: {
          'mdc-chip': true
        },
        styles: {}
      };
    },

    computed: {
      isFilter: function isFilter() {
        return this.mdcChipSet && this.mdcChipSet.filter;
      },
      haveleadingIcon: function haveleadingIcon() {
        return !!this.leadingIcon || this.leadingIconClasses;
      },
      havetrailingIcon: function havetrailingIcon() {
        return !!this.trailingIcon || this.trailingIconClasses;
      },
      leadingClasses: function leadingClasses() {
        return _extends({}, {
          'material-icons': !!this.leadingIcon
        }, this.leadingIconClasses);
      },
      trailingClasses: function trailingClasses() {
        return _extends({}, {
          'material-icons': !!this.trailingIcon
        }, this.trailingIconClasses);
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCChipFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        hasClass: function hasClass(className) {
          return _this.$el.classList.contains(className);
        },
        addClassToLeadingIcon: function addClassToLeadingIcon(className) {
          if (_this.haveleadingIcon) {
            _this.$refs.leadingIcon.classList.add(className);
          }
        },
        removeClassFromLeadingIcon: function removeClassFromLeadingIcon(className) {
          if (_this.haveleadingIcon) {
            _this.$refs.leadingIcon.classList.remove(className);
          }
        },
        eventTargetHasClass: function eventTargetHasClass(target, className) {
          return target.classList.contains(className);
        },
        registerEventHandler: function registerEventHandler(evtType, handler) {
          return _this.$el.addEventListener(evtType, handler);
        },
        deregisterEventHandler: function deregisterEventHandler(evtType, handler) {
          return _this.$el.removeEventListener(evtType, handler);
        },
        notifyInteraction: function notifyInteraction() {
          emitCustomEvent(_this.$el, MDCChipFoundation.strings.INTERACTION_EVENT, {
            chip: _this
          }, true);
        },
        notifyTrailingIconInteraction: function notifyTrailingIconInteraction() {
          emitCustomEvent(_this.$el, MDCChipFoundation.strings.TRAILING_ICON_INTERACTION_EVENT, {
            chip: _this
          }, true);
        },

        registerTrailingIconInteractionHandler: function registerTrailingIconInteractionHandler(evtType, handler) {
          if (_this.$refs.trailingIcon) {
            _this.$refs.trailingIcon.addEventListener(evtType, handler, applyPassive());
          }
        },
        deregisterTrailingIconInteractionHandler: function deregisterTrailingIconInteractionHandler(evtType, handler) {
          if (_this.$refs.trailingIcon) {
            _this.$refs.trailingIcon.removeEventListener(evtType, handler, applyPassive());
          }
        },
        notifyRemoval: function notifyRemoval() {
          emitCustomEvent(_this.$el, MDCChipFoundation.strings.REMOVAL_EVENT, { chip: _this }, true);
        },
        getComputedStyleValue: function getComputedStyleValue(propertyName) {
          return window.getComputedStyle(_this.$el).getPropertyValue(propertyName);
        },
        setStyleProperty: function setStyleProperty(property, value) {
          return _this.$set(_this.styles, property, value);
        }
      });

      this.foundation.init();

      this.ripple = new RippleBase(this);
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.ripple.destroy();
      this.foundation.destroy();
    },

    methods: {
      toggleSelected: function toggleSelected() {
        this.foundation.toggleSelected();
      },
      isSelected: function isSelected() {
        return this.foundation.isSelected();
      }
    }
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Chip Set.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Chip Set into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */

  var MDCChipSetAdapter = function () {
    function MDCChipSetAdapter() {
      classCallCheck(this, MDCChipSetAdapter);
    }

    createClass(MDCChipSetAdapter, [{
      key: 'hasClass',

      /**
       * Returns true if the root element contains the given class name.
       * @param {string} className
       * @return {boolean}
       */
      value: function hasClass(className) {}

      /**
       * Registers an event handler on the root element for a given event.
       * @param {string} evtType
       * @param {function(!MDCChipInteractionEventType): undefined} handler
       */

    }, {
      key: 'registerInteractionHandler',
      value: function registerInteractionHandler(evtType, handler) {}

      /**
       * Deregisters an event handler on the root element for a given event.
       * @param {string} evtType
       * @param {function(!MDCChipInteractionEventType): undefined} handler
       */

    }, {
      key: 'deregisterInteractionHandler',
      value: function deregisterInteractionHandler(evtType, handler) {}

      /**
       * Removes the chip object from the chip set.
       * @param {!Object} chip
       */

    }, {
      key: 'removeChip',
      value: function removeChip(chip) {}
    }]);
    return MDCChipSetAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings$4 = {
    CHIP_SELECTOR: '.mdc-chip'
  };

  /** @enum {string} */
  var cssClasses$4 = {
    CHOICE: 'mdc-chip-set--choice',
    FILTER: 'mdc-chip-set--filter'
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCChipSetAdapter>}
   * @final
   */

  var MDCChipSetFoundation = function (_MDCFoundation) {
    inherits(MDCChipSetFoundation, _MDCFoundation);
    createClass(MDCChipSetFoundation, null, [{
      key: 'strings',

      /** @return enum {string} */
      get: function get$$1() {
        return strings$4;
      }

      /** @return enum {string} */

    }, {
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$4;
      }

      /**
       * {@see MDCChipSetAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCChipSetAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCChipSetAdapter} */{
            hasClass: function hasClass() {},
            registerInteractionHandler: function registerInteractionHandler() {},
            deregisterInteractionHandler: function deregisterInteractionHandler() {},
            removeChip: function removeChip() {}
          }
        );
      }

      /**
       * @param {!MDCChipSetAdapter} adapter
       */

    }]);

    function MDCChipSetFoundation(adapter) {
      classCallCheck(this, MDCChipSetFoundation);

      /**
       * The selected chips in the set. Only used for choice chip set or filter chip set.
       * @private {!Array<!MDCChipFoundation>}
       */
      var _this = possibleConstructorReturn(this, (MDCChipSetFoundation.__proto__ || Object.getPrototypeOf(MDCChipSetFoundation)).call(this, _extends(MDCChipSetFoundation.defaultAdapter, adapter)));

      _this.selectedChips_ = [];

      /** @private {function(!MDCChipInteractionEventType): undefined} */
      _this.chipInteractionHandler_ = function (evt) {
        return _this.handleChipInteraction_(evt);
      };
      /** @private {function(!MDCChipInteractionEventType): undefined} */
      _this.chipRemovalHandler_ = function (evt) {
        return _this.handleChipRemoval_(evt);
      };
      return _this;
    }

    createClass(MDCChipSetFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.registerInteractionHandler(MDCChipFoundation.strings.INTERACTION_EVENT, this.chipInteractionHandler_);
        this.adapter_.registerInteractionHandler(MDCChipFoundation.strings.REMOVAL_EVENT, this.chipRemovalHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterInteractionHandler(MDCChipFoundation.strings.INTERACTION_EVENT, this.chipInteractionHandler_);
        this.adapter_.deregisterInteractionHandler(MDCChipFoundation.strings.REMOVAL_EVENT, this.chipRemovalHandler_);
      }

      /**
       * Selects the given chip. Deselects all other chips if the chip set is of the choice variant.
       * @param {!MDCChipFoundation} chipFoundation
       */

    }, {
      key: 'select',
      value: function select(chipFoundation) {
        if (this.adapter_.hasClass(cssClasses$4.CHOICE)) {
          this.deselectAll_();
        }
        chipFoundation.setSelected(true);
        this.selectedChips_.push(chipFoundation);
      }

      /**
       * Deselects the given chip.
       * @param {!MDCChipFoundation} chipFoundation
       */

    }, {
      key: 'deselect',
      value: function deselect(chipFoundation) {
        var index = this.selectedChips_.indexOf(chipFoundation);
        if (index >= 0) {
          this.selectedChips_.splice(index, 1);
        }
        chipFoundation.setSelected(false);
      }

      /** Deselects all selected chips. */

    }, {
      key: 'deselectAll_',
      value: function deselectAll_() {
        this.selectedChips_.forEach(function (chipFoundation) {
          chipFoundation.setSelected(false);
        });
        this.selectedChips_.length = 0;
      }

      /**
       * Handles a chip interaction event
       * @param {!MDCChipInteractionEventType} evt
       * @private
       */

    }, {
      key: 'handleChipInteraction_',
      value: function handleChipInteraction_(evt) {
        var chipFoundation = evt.detail.chip.foundation;
        if (this.adapter_.hasClass(cssClasses$4.CHOICE) || this.adapter_.hasClass(cssClasses$4.FILTER)) {
          if (chipFoundation.isSelected()) {
            this.deselect(chipFoundation);
          } else {
            this.select(chipFoundation);
          }
        }
      }

      /**
       * Handles the event when a chip is removed.
       * @param {!MDCChipInteractionEventType} evt
       * @private
       */

    }, {
      key: 'handleChipRemoval_',
      value: function handleChipRemoval_(evt) {
        var chip = evt.detail.chip;

        this.deselect(chip.foundation);
        this.adapter_.removeChip(chip);
      }
    }]);
    return MDCChipSetFoundation;
  }(MDCFoundation);

  var mdcChipSet = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', _vm._g({ class: _vm.classes }, _vm.$listeners), [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-chip-set',
    props: {
      choice: [Boolean],
      filter: [Boolean],
      input: [Boolean]
    },
    provide: function provide() {
      return { mdcChipSet: this };
    },
    data: function data() {
      return {
        classes: {
          'mdc-chip-set': true,
          'mdc-chip-set--choice': this.choice,
          'mdc-chip-set--filter': this.filter,
          'mdc-chip-set--input': this.input
        }
      };
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCChipSetFoundation({
        hasClass: function hasClass(className) {
          return _this.$el.classList.contains(className);
        },
        registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
          _this.$el.addEventListener(evtType, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
          _this.$el.removeEventListener(evtType, handler);
        },
        removeChip: function removeChip(chip) {
          // TODO: may need refactoring
          _this.$nextTick(function () {
            return chip.$destroy();
          });
        }
      });

      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    },

    methods: {}
  };

  var VueMDCChipSet = BasePlugin({
    mdcChip: mdcChip,
    mdcChipSet: mdcChipSet
  });

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$5 = {
    ROOT: 'mdc-dialog',
    OPEN: 'mdc-dialog--open',
    ANIMATING: 'mdc-dialog--animating',
    BACKDROP: 'mdc-dialog__backdrop',
    SCROLL_LOCK: 'mdc-dialog-scroll-lock',
    ACCEPT_BTN: 'mdc-dialog__footer__button--accept',
    CANCEL_BTN: 'mdc-dialog__footer__button--cancel'
  };

  var strings$5 = {
    OPEN_DIALOG_SELECTOR: '.mdc-dialog--open',
    DIALOG_SURFACE_SELECTOR: '.mdc-dialog__surface',
    ACCEPT_SELECTOR: '.mdc-dialog__footer__button--accept',
    ACCEPT_EVENT: 'MDCDialog:accept',
    CANCEL_EVENT: 'MDCDialog:cancel'
  };

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCDialogFoundation = function (_MDCFoundation) {
    inherits(MDCDialogFoundation, _MDCFoundation);
    createClass(MDCDialogFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$5;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$5;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          addBodyClass: function addBodyClass() /* className: string */{},
          removeBodyClass: function removeBodyClass() /* className: string */{},
          eventTargetHasClass: function eventTargetHasClass() {
            return (/* target: EventTarget, className: string */ /* boolean */false
            );
          },
          registerInteractionHandler: function registerInteractionHandler() /* evt: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* evt: string, handler: EventListener */{},
          registerSurfaceInteractionHandler: function registerSurfaceInteractionHandler() /* evt: string, handler: EventListener */{},
          deregisterSurfaceInteractionHandler: function deregisterSurfaceInteractionHandler() /* evt: string, handler: EventListener */{},
          registerDocumentKeydownHandler: function registerDocumentKeydownHandler() /* handler: EventListener */{},
          deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler() /* handler: EventListener */{},
          registerTransitionEndHandler: function registerTransitionEndHandler() /* handler: EventListener */{},
          deregisterTransitionEndHandler: function deregisterTransitionEndHandler() /* handler: EventListener */{},
          notifyAccept: function notifyAccept() {},
          notifyCancel: function notifyCancel() {},
          trapFocusOnSurface: function trapFocusOnSurface() {},
          untrapFocusOnSurface: function untrapFocusOnSurface() {},
          isDialog: function isDialog() {
            return (/* el: Element */ /* boolean */false
            );
          }
        };
      }
    }]);

    function MDCDialogFoundation(adapter) {
      classCallCheck(this, MDCDialogFoundation);

      var _this = possibleConstructorReturn(this, (MDCDialogFoundation.__proto__ || Object.getPrototypeOf(MDCDialogFoundation)).call(this, _extends(MDCDialogFoundation.defaultAdapter, adapter)));

      _this.isOpen_ = false;
      _this.componentClickHandler_ = function (evt) {
        if (_this.adapter_.eventTargetHasClass(evt.target, cssClasses$5.BACKDROP)) {
          _this.cancel(true);
        }
      };
      _this.dialogClickHandler_ = function (evt) {
        return _this.handleDialogClick_(evt);
      };
      _this.documentKeydownHandler_ = function (evt) {
        if (evt.key && evt.key === 'Escape' || evt.keyCode === 27) {
          _this.cancel(true);
        }
      };
      _this.transitionEndHandler_ = function (evt) {
        return _this.handleTransitionEnd_(evt);
      };
      return _this;
    }

    createClass(MDCDialogFoundation, [{
      key: 'destroy',
      value: function destroy() {
        // Ensure that dialog is cleaned up when destroyed
        if (this.isOpen_) {
          this.adapter_.deregisterSurfaceInteractionHandler('click', this.dialogClickHandler_);
          this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
          this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
          this.adapter_.untrapFocusOnSurface();
          this.adapter_.deregisterTransitionEndHandler(this.transitionEndHandler_);
          this.adapter_.removeClass(MDCDialogFoundation.cssClasses.ANIMATING);
          this.adapter_.removeClass(MDCDialogFoundation.cssClasses.OPEN);
          this.enableScroll_();
        }
      }
    }, {
      key: 'open',
      value: function open() {
        this.isOpen_ = true;
        this.disableScroll_();
        this.adapter_.registerDocumentKeydownHandler(this.documentKeydownHandler_);
        this.adapter_.registerSurfaceInteractionHandler('click', this.dialogClickHandler_);
        this.adapter_.registerInteractionHandler('click', this.componentClickHandler_);
        this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
        this.adapter_.addClass(MDCDialogFoundation.cssClasses.ANIMATING);
        this.adapter_.addClass(MDCDialogFoundation.cssClasses.OPEN);
      }
    }, {
      key: 'close',
      value: function close() {
        this.isOpen_ = false;
        this.enableScroll_();
        this.adapter_.deregisterSurfaceInteractionHandler('click', this.dialogClickHandler_);
        this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
        this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
        this.adapter_.untrapFocusOnSurface();
        this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
        this.adapter_.addClass(MDCDialogFoundation.cssClasses.ANIMATING);
        this.adapter_.removeClass(MDCDialogFoundation.cssClasses.OPEN);
      }
    }, {
      key: 'isOpen',
      value: function isOpen() {
        return this.isOpen_;
      }
    }, {
      key: 'accept',
      value: function accept(shouldNotify) {
        if (shouldNotify) {
          this.adapter_.notifyAccept();
        }

        this.close();
      }
    }, {
      key: 'cancel',
      value: function cancel(shouldNotify) {
        if (shouldNotify) {
          this.adapter_.notifyCancel();
        }

        this.close();
      }
    }, {
      key: 'handleDialogClick_',
      value: function handleDialogClick_(evt) {
        var target = evt.target;

        if (this.adapter_.eventTargetHasClass(target, cssClasses$5.ACCEPT_BTN)) {
          this.accept(true);
        } else if (this.adapter_.eventTargetHasClass(target, cssClasses$5.CANCEL_BTN)) {
          this.cancel(true);
        }
      }
    }, {
      key: 'handleTransitionEnd_',
      value: function handleTransitionEnd_(evt) {
        if (this.adapter_.isDialog(evt.target)) {
          this.adapter_.deregisterTransitionEndHandler(this.transitionEndHandler_);
          this.adapter_.removeClass(MDCDialogFoundation.cssClasses.ANIMATING);
          if (this.isOpen_) {
            this.adapter_.trapFocusOnSurface();
          }      }    }
    }, {
      key: 'disableScroll_',
      value: function disableScroll_() {
        this.adapter_.addBodyClass(cssClasses$5.SCROLL_LOCK);
      }
    }, {
      key: 'enableScroll_',
      value: function enableScroll_() {
        this.adapter_.removeBodyClass(cssClasses$5.SCROLL_LOCK);
      }
    }]);
    return MDCDialogFoundation;
  }(MDCFoundation);

  var tabbable = function (el, options) {
    options = options || {};

    var elementDocument = el.ownerDocument || el;
    var basicTabbables = [];
    var orderedTabbables = [];

    // A node is "available" if
    // - it's computed style
    var isUnavailable = createIsUnavailable(elementDocument);

    var candidateSelectors = ['input', 'select', 'a[href]', 'textarea', 'button', '[tabindex]'];

    var candidates = el.querySelectorAll(candidateSelectors.join(','));

    if (options.includeContainer) {
      var matches = Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

      if (candidateSelectors.some(function (candidateSelector) {
        return matches.call(el, candidateSelector);
      })) {
        candidates = Array.prototype.slice.apply(candidates);
        candidates.unshift(el);
      }
    }

    var candidate, candidateIndexAttr, candidateIndex;
    for (var i = 0, l = candidates.length; i < l; i++) {
      candidate = candidates[i];
      candidateIndexAttr = parseInt(candidate.getAttribute('tabindex'), 10);
      candidateIndex = isNaN(candidateIndexAttr) ? candidate.tabIndex : candidateIndexAttr;

      if (candidateIndex < 0 || candidate.tagName === 'INPUT' && candidate.type === 'hidden' || candidate.disabled || isUnavailable(candidate, elementDocument)) {
        continue;
      }

      if (candidateIndex === 0) {
        basicTabbables.push(candidate);
      } else {
        orderedTabbables.push({
          index: i,
          tabIndex: candidateIndex,
          node: candidate
        });
      }
    }

    var tabbableNodes = orderedTabbables.sort(function (a, b) {
      return a.tabIndex === b.tabIndex ? a.index - b.index : a.tabIndex - b.tabIndex;
    }).map(function (a) {
      return a.node;
    });

    Array.prototype.push.apply(tabbableNodes, basicTabbables);

    return tabbableNodes;
  };

  function createIsUnavailable(elementDocument) {
    // Node cache must be refreshed on every check, in case
    // the content of the element has changed
    var isOffCache = [];

    // "off" means `display: none;`, as opposed to "hidden",
    // which means `visibility: hidden;`. getComputedStyle
    // accurately reflects visiblity in context but not
    // "off" state, so we need to recursively check parents.

    function isOff(node, nodeComputedStyle) {
      if (node === elementDocument.documentElement) return false;

      // Find the cached node (Array.prototype.find not available in IE9)
      for (var i = 0, length = isOffCache.length; i < length; i++) {
        if (isOffCache[i][0] === node) return isOffCache[i][1];
      }

      nodeComputedStyle = nodeComputedStyle || elementDocument.defaultView.getComputedStyle(node);

      var result = false;

      if (nodeComputedStyle.display === 'none') {
        result = true;
      } else if (node.parentNode) {
        result = isOff(node.parentNode);
      }

      isOffCache.push([node, result]);

      return result;
    }

    return function isUnavailable(node) {
      if (node === elementDocument.documentElement) return false;

      var computedStyle = elementDocument.defaultView.getComputedStyle(node);

      if (isOff(node, computedStyle)) return true;

      return computedStyle.visibility === 'hidden';
    };
  }

  var listeningFocusTrap = null;

  function focusTrap(element, userOptions) {
    var tabbableNodes = [];
    var firstTabbableNode = null;
    var lastTabbableNode = null;
    var nodeFocusedBeforeActivation = null;
    var active = false;
    var paused = false;
    var tabEvent = null;

    var container = typeof element === 'string' ? document.querySelector(element) : element;

    var config = userOptions || {};
    config.returnFocusOnDeactivate = userOptions && userOptions.returnFocusOnDeactivate !== undefined ? userOptions.returnFocusOnDeactivate : true;
    config.escapeDeactivates = userOptions && userOptions.escapeDeactivates !== undefined ? userOptions.escapeDeactivates : true;

    var trap = {
      activate: activate,
      deactivate: deactivate,
      pause: pause,
      unpause: unpause
    };

    return trap;

    function activate(activateOptions) {
      if (active) return;

      var defaultedActivateOptions = {
        onActivate: activateOptions && activateOptions.onActivate !== undefined ? activateOptions.onActivate : config.onActivate
      };

      active = true;
      paused = false;
      nodeFocusedBeforeActivation = document.activeElement;

      if (defaultedActivateOptions.onActivate) {
        defaultedActivateOptions.onActivate();
      }

      addListeners();
      return trap;
    }

    function deactivate(deactivateOptions) {
      if (!active) return;

      var defaultedDeactivateOptions = {
        returnFocus: deactivateOptions && deactivateOptions.returnFocus !== undefined ? deactivateOptions.returnFocus : config.returnFocusOnDeactivate,
        onDeactivate: deactivateOptions && deactivateOptions.onDeactivate !== undefined ? deactivateOptions.onDeactivate : config.onDeactivate
      };

      removeListeners();

      if (defaultedDeactivateOptions.onDeactivate) {
        defaultedDeactivateOptions.onDeactivate();
      }

      if (defaultedDeactivateOptions.returnFocus) {
        setTimeout(function () {
          tryFocus(nodeFocusedBeforeActivation);
        }, 0);
      }

      active = false;
      paused = false;
      return this;
    }

    function pause() {
      if (paused || !active) return;
      paused = true;
      removeListeners();
    }

    function unpause() {
      if (!paused || !active) return;
      paused = false;
      addListeners();
    }

    function addListeners() {
      if (!active) return;

      // There can be only one listening focus trap at a time
      if (listeningFocusTrap) {
        listeningFocusTrap.pause();
      }
      listeningFocusTrap = trap;

      updateTabbableNodes();
      // Ensure that the focused element doesn't capture the event that caused the focus trap activation
      setTimeout(function () {
        tryFocus(firstFocusNode());
      }, 0);
      document.addEventListener('focus', checkFocus, true);
      document.addEventListener('click', checkClick, true);
      document.addEventListener('mousedown', checkPointerDown, true);
      document.addEventListener('touchstart', checkPointerDown, true);
      document.addEventListener('keydown', checkKey, true);

      return trap;
    }

    function removeListeners() {
      if (!active || listeningFocusTrap !== trap) return;

      document.removeEventListener('focus', checkFocus, true);
      document.removeEventListener('click', checkClick, true);
      document.removeEventListener('mousedown', checkPointerDown, true);
      document.removeEventListener('touchstart', checkPointerDown, true);
      document.removeEventListener('keydown', checkKey, true);

      listeningFocusTrap = null;

      return trap;
    }

    function getNodeForOption(optionName) {
      var optionValue = config[optionName];
      var node = optionValue;
      if (!optionValue) {
        return null;
      }
      if (typeof optionValue === 'string') {
        node = document.querySelector(optionValue);
        if (!node) {
          throw new Error('`' + optionName + '` refers to no known node');
        }
      }
      if (typeof optionValue === 'function') {
        node = optionValue();
        if (!node) {
          throw new Error('`' + optionName + '` did not return a node');
        }
      }
      return node;
    }

    function firstFocusNode() {
      var node;
      if (getNodeForOption('initialFocus') !== null) {
        node = getNodeForOption('initialFocus');
      } else if (container.contains(document.activeElement)) {
        node = document.activeElement;
      } else {
        node = tabbableNodes[0] || getNodeForOption('fallbackFocus');
      }

      if (!node) {
        throw new Error('You can\'t have a focus-trap without at least one focusable element');
      }

      return node;
    }

    // This needs to be done on mousedown and touchstart instead of click
    // so that it precedes the focus event
    function checkPointerDown(e) {
      if (config.clickOutsideDeactivates && !container.contains(e.target)) {
        deactivate({ returnFocus: false });
      }
    }

    function checkClick(e) {
      if (config.clickOutsideDeactivates) return;
      if (container.contains(e.target)) return;
      e.preventDefault();
      e.stopImmediatePropagation();
    }

    function checkFocus(e) {
      if (container.contains(e.target)) return;
      e.preventDefault();
      e.stopImmediatePropagation();
      // Checking for a blur method here resolves a Firefox issue (#15)
      if (typeof e.target.blur === 'function') e.target.blur();

      if (tabEvent) {
        readjustFocus(tabEvent);
      }
    }

    function checkKey(e) {
      if (e.key === 'Tab' || e.keyCode === 9) {
        handleTab(e);
      }

      if (config.escapeDeactivates !== false && isEscapeEvent(e)) {
        deactivate();
      }
    }

    function handleTab(e) {
      updateTabbableNodes();

      if (e.target.hasAttribute('tabindex') && Number(e.target.getAttribute('tabindex')) < 0) {
        return tabEvent = e;
      }

      e.preventDefault();
      var currentFocusIndex = tabbableNodes.indexOf(e.target);

      if (e.shiftKey) {
        if (e.target === firstTabbableNode || tabbableNodes.indexOf(e.target) === -1) {
          return tryFocus(lastTabbableNode);
        }
        return tryFocus(tabbableNodes[currentFocusIndex - 1]);
      }

      if (e.target === lastTabbableNode) return tryFocus(firstTabbableNode);

      tryFocus(tabbableNodes[currentFocusIndex + 1]);
    }

    function updateTabbableNodes() {
      tabbableNodes = tabbable(container);
      firstTabbableNode = tabbableNodes[0];
      lastTabbableNode = tabbableNodes[tabbableNodes.length - 1];
    }

    function readjustFocus(e) {
      if (e.shiftKey) return tryFocus(lastTabbableNode);

      tryFocus(firstTabbableNode);
    }
  }

  function isEscapeEvent(e) {
    return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;
  }

  function tryFocus(node) {
    if (!node || !node.focus) return;
    if (node === document.activeElement) return;

    node.focus();
    if (node.tagName.toLowerCase() === 'input') {
      node.select();
    }
  }

  var focusTrap_1 = focusTrap;

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  function createFocusTrapInstance(surfaceEl, acceptButtonEl) {
    var focusTrapFactory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : focusTrap_1;

    return focusTrapFactory(surfaceEl, {
      initialFocus: acceptButtonEl,
      clickOutsideDeactivates: true
    });
  }

  var mdcDialog = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('aside', { ref: "root", staticClass: "mdc-dialog", class: _vm.classes, style: _vm.styles, attrs: { "aria-labelledby": 'label' + _vm.vma_uid_, "aria-describedby": 'desc' + _vm.vma_uid_, "role": "alertdialog" } }, [_c('div', { ref: "surface", staticClass: "mdc-dialog__surface", class: _vm.surfaceClasses }, [_vm.title ? _c('header', { staticClass: "mdc-dialog__header" }, [_c('h2', { staticClass: "mdc-dialog__header__title", attrs: { "id": 'label' + _vm.vma_uid_ } }, [_vm._v(" " + _vm._s(_vm.title) + " ")])]) : _vm._e(), _vm._v(" "), _c('section', { staticClass: "mdc-dialog__body", class: _vm.bodyClasses, attrs: { "id": 'desc' + _vm.vma_uid_ } }, [_vm._t("default")], 2), _vm._v(" "), _vm.accept || _vm.cancel ? _c('footer', { staticClass: "mdc-dialog__footer" }, [_vm.cancel ? _c('mdcButton', { ref: "cancel", staticClass: "mdc-dialog__footer__button mdc-dialog__footer__button--cancel", class: { 'mdc-dialog__action': _vm.accent }, on: { "click": _vm.onCancel } }, [_vm._v(_vm._s(_vm.cancel))]) : _vm._e(), _vm._v(" "), _c('mdcButton', { ref: "accept", staticClass: "mdc-dialog__footer__button mdc-dialog__footer__button--accept", class: { 'mdc-dialog__action': _vm.accent }, attrs: { "disabled": _vm.acceptDisabled }, on: { "click": _vm.onAccept } }, [_vm._v(_vm._s(_vm.accept))])], 1) : _vm._e()]), _vm._v(" "), _c('div', { staticClass: "mdc-dialog__backdrop" })]);
    }, staticRenderFns: [],
    name: 'mdc-dialog',
    components: {
      mdcButton: mdcButton
    },
    mixins: [VMAUniqueIdMixin],
    model: {
      prop: 'open',
      event: 'change'
    },
    props: {
      title: { type: String },
      accept: { type: String, default: 'Ok' },
      acceptDisabled: Boolean,
      cancel: { type: String },
      accent: Boolean,
      scrollable: Boolean,
      open: Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-theme--dark': this.dark
        },
        styles: {},
        surfaceClasses: {},
        bodyClasses: {
          'mdc-dialog__body--scrollable': this.scrollable
        }
      };
    },

    watch: { open: 'onOpen_' },
    mounted: function mounted() {
      var _this = this;

      if (this.accept) {
        this.focusTrap = createFocusTrapInstance(this.$refs.surface, this.$refs.accept);
      }

      this.foundation = new MDCDialogFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        addBodyClass: function addBodyClass(className) {
          return document.body.classList.add(className);
        },
        removeBodyClass: function removeBodyClass(className) {
          return document.body.classList.remove(className);
        },
        eventTargetHasClass: function eventTargetHasClass(target, className) {
          return target.classList.contains(className);
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          return _this.$refs.root.addEventListener(evt, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          return _this.$refs.root.removeEventListener(evt, handler);
        },
        registerSurfaceInteractionHandler: function registerSurfaceInteractionHandler() /*evt, handler*/{
          // VMA_HACK: handle button clicks ourselves
          // this.$refs.surface.addEventListener(evt, handler)
        },
        deregisterSurfaceInteractionHandler: function deregisterSurfaceInteractionHandler() /*evt, handler*/{
          // VMA_HACK: handle button clicks ourselves
          // this.$refs.surface.removeEventListener(evt, handler)
        },
        registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
          return document.addEventListener('keydown', handler);
        },
        deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
          return document.removeEventListener('keydown', handler);
        },
        registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
          return _this.$refs.surface.addEventListener('transitionend', handler);
        },
        deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
          return _this.$refs.surface.removeEventListener('transitionend', handler);
        },
        notifyAccept: function notifyAccept() {
          _this.$emit('change', false);
          _this.$emit('accept');
        },
        notifyCancel: function notifyCancel() {
          _this.$emit('change', false);
          _this.$emit('cancel');
        },
        trapFocusOnSurface: function trapFocusOnSurface() {
          return _this.focusTrap && _this.focusTrap.activate();
        },
        untrapFocusOnSurface: function untrapFocusOnSurface() {
          return _this.focusTrap && _this.focusTrap.deactivate();
        },
        isDialog: function isDialog(el) {
          return _this.$refs.surface === el;
        }
      });

      this.foundation.init();
      this.open && this.foundation.open();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    },

    methods: {
      onOpen_: function onOpen_(value) {
        if (value) {
          this.foundation.open();
        } else {
          this.foundation.close();
        }
      },
      onCancel: function onCancel() {
        var _this2 = this;

        if (this.$listeners['validateCancel']) {
          this.$emit('validateCancel', {
            cancel: function cancel() {
              var notify = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

              // if notify = false, the dialog will close
              // but the notifyAccept method will not be called
              // so we need to notify listeners the open state
              // is changing.
              if (!notify) {
                _this2.$emit('change', false);
              }
              _this2.foundation.cancel(notify);
            }
          });
        } else {
          this.foundation.cancel(true);
        }
      },
      onAccept: function onAccept() {
        var _this3 = this;

        if (this.$listeners['validate']) {
          this.$emit('validate', {
            accept: function accept() {
              var notify = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

              // if notify = false, the dialog will close
              // but the notifyAccept method will not be called
              // so we need to notify listeners the open state
              // is changing.
              if (!notify) {
                _this3.$emit('change', false);
              }
              _this3.foundation.accept(notify);
            }
          });
        } else {
          this.foundation.accept(true);
        }
      },
      show: function show() {
        this.foundation.open();
      },
      close: function close() {
        this.foundation.close();
      }
    }
  };

  var VueMDCDialog = BasePlugin({
    mdcDialog: mdcDialog
  });

  var mdcPermanentDrawer = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('nav', { staticClass: "mdc-permanent-drawer mdc-drawer--permanent mdc-typography" }, [_c('nav', { staticClass: "mdc-drawer__content" }, [_vm.toolbarSpacer ? _c('div', { staticClass: "mdc-drawer__toolbar-spacer" }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2)]);
    }, staticRenderFns: [],
    name: 'mdc-permanent-drawer',
    props: {
      'toolbar-spacer': Boolean
    }
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var FOCUSABLE_ELEMENTS = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), ' + 'button:not([disabled]), iframe, object, embed, [tabindex], [contenteditable]';

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCSlidableDrawerFoundation = function (_MDCFoundation) {
    inherits(MDCSlidableDrawerFoundation, _MDCFoundation);
    createClass(MDCSlidableDrawerFoundation, null, [{
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          hasClass: function hasClass() /* className: string */{},
          hasNecessaryDom: function hasNecessaryDom() {
            return (/* boolean */false
            );
          },
          registerInteractionHandler: function registerInteractionHandler() /* evt: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* evt: string, handler: EventListener */{},
          registerDrawerInteractionHandler: function registerDrawerInteractionHandler() /* evt: string, handler: EventListener */{},
          deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler() /* evt: string, handler: EventListener */{},
          registerTransitionEndHandler: function registerTransitionEndHandler() /* handler: EventListener */{},
          deregisterTransitionEndHandler: function deregisterTransitionEndHandler() /* handler: EventListener */{},
          registerDocumentKeydownHandler: function registerDocumentKeydownHandler() /* handler: EventListener */{},
          deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler() /* handler: EventListener */{},
          setTranslateX: function setTranslateX() /* value: number | null */{},
          getFocusableElements: function getFocusableElements() /* NodeList */{},
          saveElementTabState: function saveElementTabState() /* el: Element */{},
          restoreElementTabState: function restoreElementTabState() /* el: Element */{},
          makeElementUntabbable: function makeElementUntabbable() /* el: Element */{},
          notifyOpen: function notifyOpen() {},
          notifyClose: function notifyClose() {},
          isRtl: function isRtl() {
            return (/* boolean */false
            );
          },
          getDrawerWidth: function getDrawerWidth() {
            return (/* number */0
            );
          }
        };
      }
    }]);

    function MDCSlidableDrawerFoundation(adapter, rootCssClass, animatingCssClass, openCssClass) {
      classCallCheck(this, MDCSlidableDrawerFoundation);

      var _this = possibleConstructorReturn(this, (MDCSlidableDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCSlidableDrawerFoundation)).call(this, _extends(MDCSlidableDrawerFoundation.defaultAdapter, adapter)));

      _this.rootCssClass_ = rootCssClass;
      _this.animatingCssClass_ = animatingCssClass;
      _this.openCssClass_ = openCssClass;

      _this.transitionEndHandler_ = function (evt) {
        return _this.handleTransitionEnd_(evt);
      };

      _this.inert_ = false;

      _this.componentTouchStartHandler_ = function (evt) {
        return _this.handleTouchStart_(evt);
      };
      _this.componentTouchMoveHandler_ = function (evt) {
        return _this.handleTouchMove_(evt);
      };
      _this.componentTouchEndHandler_ = function (evt) {
        return _this.handleTouchEnd_(evt);
      };
      _this.documentKeydownHandler_ = function (evt) {
        if (evt.key && evt.key === 'Escape' || evt.keyCode === 27) {
          _this.close();
        }
      };
      return _this;
    }

    createClass(MDCSlidableDrawerFoundation, [{
      key: 'init',
      value: function init() {
        var ROOT = this.rootCssClass_;
        var OPEN = this.openCssClass_;

        if (!this.adapter_.hasClass(ROOT)) {
          throw new Error(ROOT + ' class required in root element.');
        }

        if (!this.adapter_.hasNecessaryDom()) {
          throw new Error('Required DOM nodes missing in ' + ROOT + ' component.');
        }

        if (this.adapter_.hasClass(OPEN)) {
          this.isOpen_ = true;
        } else {
          this.detabinate_();
          this.isOpen_ = false;
        }

        this.adapter_.registerDrawerInteractionHandler('touchstart', this.componentTouchStartHandler_);
        this.adapter_.registerInteractionHandler('touchmove', this.componentTouchMoveHandler_);
        this.adapter_.registerInteractionHandler('touchend', this.componentTouchEndHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterDrawerInteractionHandler('touchstart', this.componentTouchStartHandler_);
        this.adapter_.deregisterInteractionHandler('touchmove', this.componentTouchMoveHandler_);
        this.adapter_.deregisterInteractionHandler('touchend', this.componentTouchEndHandler_);
        // Deregister the document keydown handler just in case the component is destroyed while the menu is open.
        this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
      }
    }, {
      key: 'open',
      value: function open() {
        this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
        this.adapter_.registerDocumentKeydownHandler(this.documentKeydownHandler_);
        this.adapter_.addClass(this.animatingCssClass_);
        this.adapter_.addClass(this.openCssClass_);
        this.retabinate_();
        // Debounce multiple calls
        if (!this.isOpen_) {
          this.adapter_.notifyOpen();
        }
        this.isOpen_ = true;
      }
    }, {
      key: 'close',
      value: function close() {
        this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
        this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
        this.adapter_.addClass(this.animatingCssClass_);
        this.adapter_.removeClass(this.openCssClass_);
        this.detabinate_();
        // Debounce multiple calls
        if (this.isOpen_) {
          this.adapter_.notifyClose();
        }
        this.isOpen_ = false;
      }
    }, {
      key: 'isOpen',
      value: function isOpen() {
        return this.isOpen_;
      }

      /**
       *  Render all children of the drawer inert when it's closed.
       */

    }, {
      key: 'detabinate_',
      value: function detabinate_() {
        if (this.inert_) {
          return;
        }

        var elements = this.adapter_.getFocusableElements();
        if (elements) {
          for (var i = 0; i < elements.length; i++) {
            this.adapter_.saveElementTabState(elements[i]);
            this.adapter_.makeElementUntabbable(elements[i]);
          }
        }

        this.inert_ = true;
      }

      /**
       *  Make all children of the drawer tabbable again when it's open.
       */

    }, {
      key: 'retabinate_',
      value: function retabinate_() {
        if (!this.inert_) {
          return;
        }

        var elements = this.adapter_.getFocusableElements();
        if (elements) {
          for (var i = 0; i < elements.length; i++) {
            this.adapter_.restoreElementTabState(elements[i]);
          }
        }

        this.inert_ = false;
      }
    }, {
      key: 'handleTouchStart_',
      value: function handleTouchStart_(evt) {
        if (!this.adapter_.hasClass(this.openCssClass_)) {
          return;
        }
        if (evt.pointerType && evt.pointerType !== 'touch') {
          return;
        }

        this.direction_ = this.adapter_.isRtl() ? -1 : 1;
        this.drawerWidth_ = this.adapter_.getDrawerWidth();
        this.startX_ = evt.touches ? evt.touches[0].pageX : evt.pageX;
        this.currentX_ = this.startX_;

        this.updateRaf_ = requestAnimationFrame(this.updateDrawer_.bind(this));
      }
    }, {
      key: 'handleTouchMove_',
      value: function handleTouchMove_(evt) {
        if (evt.pointerType && evt.pointerType !== 'touch') {
          return;
        }

        this.currentX_ = evt.touches ? evt.touches[0].pageX : evt.pageX;
      }
    }, {
      key: 'handleTouchEnd_',
      value: function handleTouchEnd_(evt) {
        if (evt.pointerType && evt.pointerType !== 'touch') {
          return;
        }

        this.prepareForTouchEnd_();

        // Did the user close the drawer by more than 50%?
        if (Math.abs(this.newPosition_ / this.drawerWidth_) >= 0.5) {
          this.close();
        } else {
          // Triggering an open here means we'll get a nice animation back to the fully open state.
          this.open();
        }
      }
    }, {
      key: 'prepareForTouchEnd_',
      value: function prepareForTouchEnd_() {
        cancelAnimationFrame(this.updateRaf_);
        this.adapter_.setTranslateX(null);
      }
    }, {
      key: 'updateDrawer_',
      value: function updateDrawer_() {
        this.updateRaf_ = requestAnimationFrame(this.updateDrawer_.bind(this));
        this.adapter_.setTranslateX(this.newPosition_);
      }
    }, {
      key: 'isRootTransitioningEventTarget_',
      value: function isRootTransitioningEventTarget_() {
        // Classes extending MDCSlidableDrawerFoundation should implement this method to return true or false
        // if the event target is the root event target currently transitioning.
        return false;
      }
    }, {
      key: 'handleTransitionEnd_',
      value: function handleTransitionEnd_(evt) {
        if (this.isRootTransitioningEventTarget_(evt.target)) {
          this.adapter_.removeClass(this.animatingCssClass_);
          this.adapter_.deregisterTransitionEndHandler(this.transitionEndHandler_);
        }
      }
    }, {
      key: 'newPosition_',
      get: function get$$1() {
        var newPos = null;

        if (this.direction_ === 1) {
          newPos = Math.min(0, this.currentX_ - this.startX_);
        } else {
          newPos = Math.max(0, this.currentX_ - this.startX_);
        }

        return newPos;
      }
    }]);
    return MDCSlidableDrawerFoundation;
  }(MDCFoundation);

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$6 = {
    ROOT: 'mdc-drawer--persistent',
    OPEN: 'mdc-drawer--open',
    ANIMATING: 'mdc-drawer--animating'
  };

  var strings$6 = {
    DRAWER_SELECTOR: '.mdc-drawer--persistent .mdc-drawer__drawer',
    FOCUSABLE_ELEMENTS: FOCUSABLE_ELEMENTS,
    OPEN_EVENT: 'MDCPersistentDrawer:open',
    CLOSE_EVENT: 'MDCPersistentDrawer:close'
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCPersistentDrawerFoundation = function (_MDCSlidableDrawerFou) {
    inherits(MDCPersistentDrawerFoundation, _MDCSlidableDrawerFou);
    createClass(MDCPersistentDrawerFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$6;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$6;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return _extends(MDCSlidableDrawerFoundation.defaultAdapter, {
          isDrawer: function isDrawer() {
            return false;
          }
        });
      }
    }]);

    function MDCPersistentDrawerFoundation(adapter) {
      classCallCheck(this, MDCPersistentDrawerFoundation);
      return possibleConstructorReturn(this, (MDCPersistentDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCPersistentDrawerFoundation)).call(this, _extends(MDCPersistentDrawerFoundation.defaultAdapter, adapter), MDCPersistentDrawerFoundation.cssClasses.ROOT, MDCPersistentDrawerFoundation.cssClasses.ANIMATING, MDCPersistentDrawerFoundation.cssClasses.OPEN));
    }

    createClass(MDCPersistentDrawerFoundation, [{
      key: 'isRootTransitioningEventTarget_',
      value: function isRootTransitioningEventTarget_(el) {
        return this.adapter_.isDrawer(el);
      }
    }]);
    return MDCPersistentDrawerFoundation;
  }(MDCSlidableDrawerFoundation);

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var TAB_DATA = 'data-mdc-tabindex';
  var TAB_DATA_HANDLED = 'data-mdc-tabindex-handled';

  var storedTransformPropertyName_ = void 0;
  var supportsPassive_$2 = void 0;

  // Remap touch events to pointer events, if the browser doesn't support touch events.
  function remapEvent(eventName) {
    var globalObj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;

    if (!('ontouchstart' in globalObj.document)) {
      switch (eventName) {
        case 'touchstart':
          return 'pointerdown';
        case 'touchmove':
          return 'pointermove';
        case 'touchend':
          return 'pointerup';
        default:
          return eventName;
      }
    }

    return eventName;
  }

  // Choose the correct transform property to use on the current browser.
  function getTransformPropertyName() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (storedTransformPropertyName_ === undefined || forceRefresh) {
      var el = globalObj.document.createElement('div');
      var transformPropertyName = 'transform' in el.style ? 'transform' : '-webkit-transform';
      storedTransformPropertyName_ = transformPropertyName;
    }

    return storedTransformPropertyName_;
  }

  // Determine whether the current browser supports CSS properties.
  function supportsCssCustomProperties() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;

    if ('CSS' in globalObj) {
      return globalObj.CSS.supports('(--color: red)');
    }
    return false;
  }

  // Determine whether the current browser supports passive event listeners, and if so, use them.
  function applyPassive$2() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (supportsPassive_$2 === undefined || forceRefresh) {
      var isSupported = false;
      try {
        globalObj.document.addEventListener('test', null, { get passive() {
            isSupported = true;
          } });
      } catch (e) {}

      supportsPassive_$2 = isSupported;
    }

    return supportsPassive_$2 ? { passive: true } : false;
  }

  // Save the tab state for an element.
  function saveElementTabState(el) {
    if (el.hasAttribute('tabindex')) {
      el.setAttribute(TAB_DATA, el.getAttribute('tabindex'));
    }
    el.setAttribute(TAB_DATA_HANDLED, true);
  }

  // Restore the tab state for an element, if it was saved.
  function restoreElementTabState(el) {
    // Only modify elements we've already handled, in case anything was dynamically added since we saved state.
    if (el.hasAttribute(TAB_DATA_HANDLED)) {
      if (el.hasAttribute(TAB_DATA)) {
        el.setAttribute('tabindex', el.getAttribute(TAB_DATA));
        el.removeAttribute(TAB_DATA);
      } else {
        el.removeAttribute('tabindex');
      }
      el.removeAttribute(TAB_DATA_HANDLED);
    }
  }

  var mdcPersistentDrawer = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('aside', { staticClass: "mdc-persistent-drawer mdc-drawer--persistent mdc-typography", class: _vm.classes }, [_c('nav', { ref: "drawer", staticClass: "mdc-drawer__drawer" }, [_vm.toolbarSpacer ? _c('div', { staticClass: "mdc-drawer__toolbar-spacer" }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2)]);
    }, staticRenderFns: [],
    name: 'mdc-persistent-drawer',
    model: {
      prop: 'open',
      event: 'change'
    },
    props: {
      'toolbar-spacer': Boolean,
      open: Boolean
    },
    data: function data() {
      return {
        classes: {}
      };
    },

    watch: {
      open: '_refresh'
    },
    mounted: function mounted() {
      var _this = this;

      var FOCUSABLE_ELEMENTS = MDCPersistentDrawerFoundation.strings.FOCUSABLE_ELEMENTS;


      this.foundation = new MDCPersistentDrawerFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.classes, className);
        },
        hasClass: function hasClass(className) {
          return _this.$el.classList.contains(className);
        },
        hasNecessaryDom: function hasNecessaryDom() {
          return !!_this.$refs.drawer;
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          _this.$el.addEventListener(remapEvent(evt), handler, applyPassive$2());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          _this.$el.removeEventListener(remapEvent(evt), handler, applyPassive$2());
        },
        registerDrawerInteractionHandler: function registerDrawerInteractionHandler(evt, handler) {
          _this.$refs.drawer.addEventListener(remapEvent(evt), handler, applyPassive$2());
        },
        deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler(evt, handler) {
          _this.$refs.drawer.removeEventListener(remapEvent(evt), handler, applyPassive$2());
        },
        registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
          _this.$refs.drawer.addEventListener('transitionend', handler);
        },
        deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
          _this.$refs.drawer.removeEventListener('transitionend', handler);
        },
        registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
          document.addEventListener('keydown', handler);
        },
        deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
          document.removeEventListener('keydown', handler);
        },
        getDrawerWidth: function getDrawerWidth() {
          return _this.$refs.drawer.offsetWidth;
        },
        setTranslateX: function setTranslateX(value) {
          _this.$refs.drawer.style.setProperty(getTransformPropertyName(), value === null ? null : 'translateX(' + value + 'px)');
        },
        getFocusableElements: function getFocusableElements() {
          return _this.$refs.drawer.querySelectorAll(FOCUSABLE_ELEMENTS);
        },
        saveElementTabState: function saveElementTabState$$1(el) {
          saveElementTabState(el);
        },
        restoreElementTabState: function restoreElementTabState$$1(el) {
          restoreElementTabState(el);
        },
        makeElementUntabbable: function makeElementUntabbable(el) {
          el.setAttribute('tabindex', -1);
        },
        notifyOpen: function notifyOpen() {
          _this.$emit('change', true);
          _this.$emit('open');
        },
        notifyClose: function notifyClose() {
          _this.$emit('change', false);
          _this.$emit('close');
        },
        isRtl: function isRtl() {
          /* global getComputedStyle */
          return getComputedStyle(_this.$el).getPropertyValue('direction') === 'rtl';
        },
        isDrawer: function isDrawer(el) {
          return el === _this.$refs.drawer;
        }
      });
      this.foundation && this.foundation.init();
      this._refresh();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation && this.foundation.destroy();
      this.foundation = null;
    },

    methods: {
      _refresh: function _refresh() {
        if (this.open) {
          this.foundation && this.foundation.open();
        } else {
          this.foundation && this.foundation.close();
        }
      }
    }
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$7 = {
    ROOT: 'mdc-drawer--temporary',
    OPEN: 'mdc-drawer--open',
    ANIMATING: 'mdc-drawer--animating',
    SCROLL_LOCK: 'mdc-drawer-scroll-lock'
  };

  var strings$7 = {
    DRAWER_SELECTOR: '.mdc-drawer--temporary .mdc-drawer__drawer',
    OPACITY_VAR_NAME: '--mdc-temporary-drawer-opacity',
    FOCUSABLE_ELEMENTS: FOCUSABLE_ELEMENTS,
    OPEN_EVENT: 'MDCTemporaryDrawer:open',
    CLOSE_EVENT: 'MDCTemporaryDrawer:close'
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCTemporaryDrawerFoundation = function (_MDCSlidableDrawerFou) {
    inherits(MDCTemporaryDrawerFoundation, _MDCSlidableDrawerFou);
    createClass(MDCTemporaryDrawerFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$7;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$7;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return _extends(MDCSlidableDrawerFoundation.defaultAdapter, {
          addBodyClass: function addBodyClass() /* className: string */{},
          removeBodyClass: function removeBodyClass() /* className: string */{},
          isDrawer: function isDrawer() {
            return false;
          },
          updateCssVariable: function updateCssVariable() /* value: string */{},
          eventTargetHasClass: function eventTargetHasClass() {
            return (/* target: EventTarget, className: string */ /* boolean */false
            );
          }
        });
      }
    }]);

    function MDCTemporaryDrawerFoundation(adapter) {
      classCallCheck(this, MDCTemporaryDrawerFoundation);

      var _this = possibleConstructorReturn(this, (MDCTemporaryDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation)).call(this, _extends(MDCTemporaryDrawerFoundation.defaultAdapter, adapter), MDCTemporaryDrawerFoundation.cssClasses.ROOT, MDCTemporaryDrawerFoundation.cssClasses.ANIMATING, MDCTemporaryDrawerFoundation.cssClasses.OPEN));

      _this.componentClickHandler_ = function (evt) {
        if (_this.adapter_.eventTargetHasClass(evt.target, cssClasses$7.ROOT)) {
          _this.close(true);
        }
      };
      return _this;
    }

    createClass(MDCTemporaryDrawerFoundation, [{
      key: 'init',
      value: function init() {
        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'init', this).call(this);

        // Make browser aware of custom property being used in this element.
        // Workaround for certain types of hard-to-reproduce heisenbugs.
        this.adapter_.updateCssVariable(0);
        this.adapter_.registerInteractionHandler('click', this.componentClickHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'destroy', this).call(this);

        this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
        this.enableScroll_();
      }
    }, {
      key: 'open',
      value: function open() {
        this.disableScroll_();
        // Make sure custom property values are cleared before starting.
        this.adapter_.updateCssVariable('');

        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'open', this).call(this);
      }
    }, {
      key: 'close',
      value: function close() {
        // Make sure custom property values are cleared before making any changes.
        this.adapter_.updateCssVariable('');

        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'close', this).call(this);
      }
    }, {
      key: 'prepareForTouchEnd_',
      value: function prepareForTouchEnd_() {
        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'prepareForTouchEnd_', this).call(this);

        this.adapter_.updateCssVariable('');
      }
    }, {
      key: 'updateDrawer_',
      value: function updateDrawer_() {
        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'updateDrawer_', this).call(this);

        var newOpacity = Math.max(0, 1 + this.direction_ * (this.newPosition_ / this.drawerWidth_));
        this.adapter_.updateCssVariable(newOpacity);
      }
    }, {
      key: 'isRootTransitioningEventTarget_',
      value: function isRootTransitioningEventTarget_(el) {
        return this.adapter_.isDrawer(el);
      }
    }, {
      key: 'handleTransitionEnd_',
      value: function handleTransitionEnd_(evt) {
        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'handleTransitionEnd_', this).call(this, evt);
        if (!this.isOpen_) {
          this.enableScroll_();
        }
      }
    }, {
      key: 'disableScroll_',
      value: function disableScroll_() {
        this.adapter_.addBodyClass(cssClasses$7.SCROLL_LOCK);
      }
    }, {
      key: 'enableScroll_',
      value: function enableScroll_() {
        this.adapter_.removeBodyClass(cssClasses$7.SCROLL_LOCK);
      }
    }]);
    return MDCTemporaryDrawerFoundation;
  }(MDCSlidableDrawerFoundation);

  var mdcTemporaryDrawer = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('aside', { staticClass: "mdc-temporary-drawer mdc-drawer--temporary mdc-typography", class: _vm.classes }, [_c('nav', { ref: "drawer", staticClass: "mdc-drawer__drawer" }, [_vm.toolbarSpacer ? _c('div', { staticClass: "mdc-drawer__toolbar-spacer" }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2)]);
    }, staticRenderFns: [],
    name: 'mdc-temporary-drawer',
    model: {
      prop: 'open',
      event: 'change'
    },
    props: {
      open: Boolean,
      'toolbar-spacer': Boolean
    },
    data: function data() {
      return {
        classes: {}
      };
    },

    watch: {
      open: '_refresh'
    },
    mounted: function mounted() {
      var _this = this;

      var _MDCTemporaryDrawerFo = MDCTemporaryDrawerFoundation.strings,
          FOCUSABLE_ELEMENTS = _MDCTemporaryDrawerFo.FOCUSABLE_ELEMENTS,
          OPACITY_VAR_NAME = _MDCTemporaryDrawerFo.OPACITY_VAR_NAME;


      this.foundation = new MDCTemporaryDrawerFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.classes, className);
        },
        hasClass: function hasClass(className) {
          return _this.$el.classList.contains(className);
        },
        addBodyClass: function addBodyClass(className) {
          return document.body.classList.add(className);
        },
        removeBodyClass: function removeBodyClass(className) {
          return document.body.classList.remove(className);
        },
        eventTargetHasClass: function eventTargetHasClass(target, className) {
          return target.classList.contains(className);
        },
        hasNecessaryDom: function hasNecessaryDom() {
          return !!_this.$refs.drawer;
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          _this.$el.addEventListener(remapEvent(evt), handler, applyPassive$2());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          _this.$el.removeEventListener(remapEvent(evt), handler, applyPassive$2());
        },
        registerDrawerInteractionHandler: function registerDrawerInteractionHandler(evt, handler) {
          _this.$refs.drawer.addEventListener(remapEvent(evt), handler, applyPassive$2());
        },
        deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler(evt, handler) {
          _this.$refs.drawer.removeEventListener(remapEvent(evt), handler, applyPassive$2());
        },
        registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
          _this.$refs.drawer.addEventListener('transitionend', handler);
        },
        deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
          _this.$refs.drawer.removeEventListener('transitionend', handler);
        },
        registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
          document.addEventListener('keydown', handler);
        },
        deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
          document.removeEventListener('keydown', handler);
        },
        getDrawerWidth: function getDrawerWidth() {
          return _this.$refs.drawer.offsetWidth;
        },
        setTranslateX: function setTranslateX(value) {
          _this.$refs.drawer.style.setProperty(getTransformPropertyName(), value === null ? null : 'translateX(' + value + 'px)');
        },
        updateCssVariable: function updateCssVariable(value) {
          if (supportsCssCustomProperties()) {
            _this.$el.style.setProperty(OPACITY_VAR_NAME, value);
          }
        },
        getFocusableElements: function getFocusableElements() {
          return _this.$refs.drawer.querySelectorAll(FOCUSABLE_ELEMENTS);
        },
        saveElementTabState: function saveElementTabState$$1(el) {
          saveElementTabState(el);
        },
        restoreElementTabState: function restoreElementTabState$$1(el) {
          restoreElementTabState(el);
        },
        makeElementUntabbable: function makeElementUntabbable(el) {
          el.setAttribute('tabindex', -1);
        },
        notifyOpen: function notifyOpen() {
          _this.$emit('change', true);
          _this.$emit('open');
        },
        notifyClose: function notifyClose() {
          _this.$emit('change', false);
          _this.$emit('close');
        },
        isRtl: function isRtl() {
          /* global getComputedStyle */
          return getComputedStyle(_this.$el).getPropertyValue('direction') === 'rtl';
        },
        isDrawer: function isDrawer(el) {
          return el === _this.$refs.drawer;
        }
      });
      this.foundation && this.foundation.init();
      this._refresh();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation && this.foundation.destroy();
      this.foundation = null;
    },

    methods: {
      _refresh: function _refresh() {
        if (this.open) {
          this.foundation && this.foundation.open();
        } else {
          this.foundation && this.foundation.close();
        }
      }
    }
  };

  var media = new (function () {
    function _class() {
      classCallCheck(this, _class);
    }

    createClass(_class, [{
      key: 'small',
      get: function get$$1() {
        return this._small || (this._small = window.matchMedia('(max-width: 839px)'));
      }
    }, {
      key: 'large',
      get: function get$$1() {
        return this._large || (this._large = window.matchMedia('(min-width: 1200px)'));
      }
    }]);
    return _class;
  }())();

  var mdcDrawer = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c(_vm.type, { ref: "drawer", tag: "component", staticClass: "mdc-drawer", attrs: { "toolbar-spacer": _vm.toolbarSpacer }, on: { "change": _vm.onChange, "open": function open($event) {
            _vm.$emit('open');
          }, "close": function close($event) {
            _vm.$emit('close');
          } }, model: { value: _vm.open_, callback: function callback($$v) {
            _vm.open_ = $$v;
          }, expression: "open_" } }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-drawer',
    components: {
      'mdc-permanent-drawer': mdcPermanentDrawer,
      'mdc-persistent-drawer': mdcPersistentDrawer,
      'mdc-temporary-drawer': mdcTemporaryDrawer
    },
    model: {
      prop: 'open',
      event: 'change'
    },
    props: {
      open: Boolean,
      permanent: Boolean,
      persistent: Boolean,
      temporary: Boolean,
      drawerType: {
        type: String,
        validator: function validator(val) {
          return val in ['temporary', 'persistent', 'permanent'];
        }
      },
      toolbarSpacer: Boolean,
      toggleOn: String,
      toggleOnSource: { type: Object, required: false },
      openOn: String,
      openOnSource: { type: Object, required: false },
      closeOn: String,
      closeOnSource: { type: Object, required: false }
    },
    provide: function provide() {
      return { mdcDrawer: this };
    },
    data: function data() {
      return {
        small: false,
        large: false,
        open_: false
      };
    },

    computed: {
      type: function type() {
        if (this.permanent) {
          return 'mdc-permanent-drawer';
        } else if (this.persistent) {
          return 'mdc-persistent-drawer';
        } else if (this.temporary) {
          return 'mdc-temporary-drawer';
        } else {
          switch (this.drawerType) {
            case 'permanent':
              return 'mdc-permanent-drawer';
            case 'persistent':
              return 'mdc-persistent-drawer';
            case 'temporary':
              return 'mdc-temporary-drawer';
            default:
              return this.small ? 'mdc-temporary-drawer' : 'mdc-persistent-drawer';
          }
        }
      },
      isPermanent: function isPermanent() {
        return this.permanent || this.type === 'mdc-permanent-drawer';
      },
      isPersistent: function isPersistent() {
        return this.persistent || this.type === 'mdc-persistent-drawer';
      },
      isTemporary: function isTemporary() {
        return this.temporary || this.type === 'mdc-temporary-drawer';
      },
      isResponsive: function isResponsive() {
        return !(this.permanent || this.persistent || this.temporary || this.drawerType);
      }
    },
    watch: {
      open: 'onOpen_'
    },
    created: function created() {
      if (typeof window !== 'undefined' && window.matchMedia) {
        this.small = media.small.matches;
        this.large = media.large.matches;
      }
    },
    mounted: function mounted() {
      var _this = this;

      if (this.toggleOn) {
        this.toggleOnEventSource = this.toggleOnSource || this.$root;
        this.toggleOnEventSource.$on(this.toggleOn, this.toggle);
      }
      if (this.openOn) {
        this.openOnEventSource = this.openOnSource || this.$root;
        this.openOnEventSource.$on(this.openOn, this.show);
      }
      if (this.closeOn) {
        this.closeOnEventSource = this.closeOnSource || this.$root;
        this.closeOnEventSource.$on(this.closeOn, this.close);
      }
      media.small.addListener(this.refreshMedia);
      media.large.addListener(this.refreshMedia);
      this.$nextTick(function () {
        return _this.refreshMedia();
      });
    },
    beforeDestroy: function beforeDestroy() {
      media.small.removeListener(this.refreshMedia);
      media.large.removeListener(this.refreshMedia);

      if (this.toggleOnEventSource) {
        this.toggleOnEventSource.$off(this.toggleOn, this.toggle);
      }
      if (this.openOnEventSource) {
        this.openOnEventSource.$off(this.openOn, this.show);
      }
      if (this.closeOnEventSource) {
        this.closeOnEventSource.$off(this.closeOn, this.close);
      }
    },

    methods: {
      onOpen_: function onOpen_(value) {
        this.isPermanent || (this.open_ = value);
      },
      onChange: function onChange(event) {
        this.$emit('change', event);
        this.$root.$emit('vma:layout');
      },
      show: function show() {
        this.open_ = true;
      },
      close: function close() {
        this.isPermanent || (this.open_ = false);
      },
      toggle: function toggle() {
        this.isPermanent || (this.isOpen() ? this.close() : this.show());
      },
      isOpen: function isOpen() {
        return this.isPermanent || this.open_;
      },
      refreshMedia: function refreshMedia() {
        this.small = media.small.matches;
        this.large = media.large.matches;
        if (this.isResponsive) {
          if (this.large) {
            this.show();
          } else {
            this.close();
          }
        }
      }
    }
  };

  var mdcDrawerLayout = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-drawer-layout" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-drawer-layout'
  };

  var mdcDrawerHeader = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _vm.show ? _c('header', { staticClass: "mdc-drawer-header mdc-drawer__header" }, [_c('div', { staticClass: "mdc-drawer__header-content" }, [_vm._t("default")], 2)]) : _vm._e();
    }, staticRenderFns: [],
    name: 'mdc-drawer-header',
    props: {
      permanent: Boolean,
      persistent: Boolean,
      temporary: Boolean
    },
    inject: ['mdcDrawer'],
    computed: {
      show: function show() {
        if (this.temporary || this.persistent || this.permanent) {
          return this.temporary && this.mdcDrawer.isTemporary || this.persistent && this.mdcDrawer.isPersistent || this.permanent && this.mdcDrawer.isPermanent;
        } else {
          return true;
        }
      }
    }
  };

  var mdcDrawerList = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('nav', { staticClass: "mdc-drawer-list mdc-list", class: _vm.classes }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-drawer-list',
    props: {
      dense: Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-list--dense': this.dense
        }
      };
    }
  };

  var mdcDrawerItem = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-link', _vm._g({ staticClass: "mdc-drawer-item mdc-list-item", class: [_vm.classes, _vm.itemClasses], style: _vm.styles, attrs: { "link": _vm.link } }, _vm.mylisteners), [_vm.hasStartDetail ? _c('span', { staticClass: "mdc-list-item__graphic" }, [_vm._t("start-detail", [_c('i', { staticClass: "material-icons", attrs: { "aria-hidden": "true" } }, [_vm._v(_vm._s(_vm.startIcon))])])], 2) : _vm._e(), _vm._v(" "), _vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-drawer-item',
    inject: ['mdcDrawer'],
    mixins: [DispatchEventMixin, CustomLinkMixin],
    props: {
      startIcon: String,
      temporaryClose: {
        type: Boolean,
        default: true
      },
      activated: Boolean,
      exactActiveClass: {
        type: String,
        default: 'mdc-list-item--activated'
      }
    },
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },

    computed: {
      mylisteners: function mylisteners() {
        var _this = this;

        return _extends({}, this.$listeners, {
          click: function click(e) {
            _this.mdcDrawer.isTemporary && _this.temporaryClose && _this.mdcDrawer.close();
            _this.dispatchEvent(e);
          }
        });
      },
      itemClasses: function itemClasses() {
        return {
          'mdc-list-item--activated': this.activated
        };
      },
      hasStartDetail: function hasStartDetail() {
        return this.startIcon || this.$slots['start-detail'];
      }
    },
    mounted: function mounted() {
      this.ripple = new RippleBase(this);
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.ripple && this.ripple.destroy();
      this.ripple = null;
    }
  };

  var mdcDrawerDivider = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('hr', { staticClass: "mdc-list-divider" });
    }, staticRenderFns: [],
    name: 'mdc-drawer-divider'
  };

  var VueMDCDrawer = BasePlugin({
    mdcDrawer: mdcDrawer,
    mdcDrawerLayout: mdcDrawerLayout,
    mdcDrawerHeader: mdcDrawerHeader,
    mdcDrawerList: mdcDrawerList,
    mdcDrawerItem: mdcDrawerItem,
    mdcDrawerDivider: mdcDrawerDivider
  });

  var mdcElevation = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-elevation" });
    }, staticRenderFns: [],
    name: 'mdc-elevation',
    props: {}
  };

  var VueMDCElevation = BasePlugin({
    mdcElevation: mdcElevation
  });

  var mdcFAB = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-button', _vm._g({ staticClass: "mdc-fab", class: _vm.classes, style: _vm.styles, attrs: { "href": _vm.href, "link": _vm.link } }, _vm.listeners), [_c('span', { staticClass: "mdc-fab__icon" }, [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2)]);
    }, staticRenderFns: [],
    name: 'mdc-fab',
    mixins: [DispatchEventMixin, CustomButtonMixin, RippleMixin],
    props: {
      icon: String,
      mini: Boolean,
      absolute: Boolean,
      fixed: Boolean
    },
    data: function data() {
      return {
        classes: {
          'material-icons': this.icon,
          'mdc-fab--mini': this.mini,
          'mdc-fab--absolute': this.absolute,
          'mdc-fab--fixed': this.fixed
        },
        styles: {}
      };
    },

    watch: {
      icon: function icon() {
        this.$set(this.classes, 'material-icons', this.icon);
      },
      mini: function mini() {
        this.$set(this.classes, 'mdc-fab--mini', this.mini);
      }
    }
  };

  var VueMDCFab = BasePlugin({
    mdcFAB: mdcFAB
  });

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var strings$8 = {
    TILES_SELECTOR: '.mdc-grid-list__tiles',
    TILE_SELECTOR: '.mdc-grid-tile'
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCGridListFoundation = function (_MDCFoundation) {
    inherits(MDCGridListFoundation, _MDCFoundation);
    createClass(MDCGridListFoundation, null, [{
      key: 'strings',
      get: function get$$1() {
        return strings$8;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          getOffsetWidth: function getOffsetWidth() {
            return (/* number */0
            );
          },
          getNumberOfTiles: function getNumberOfTiles() {
            return (/* number */0
            );
          },
          getOffsetWidthForTileAtIndex: function getOffsetWidthForTileAtIndex() {
            return (/* index: number */ /* number */0
            );
          },
          setStyleForTilesElement: function setStyleForTilesElement() /* property: string, value: string */{},
          registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
          deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{}
        };
      }
    }]);

    function MDCGridListFoundation(adapter) {
      classCallCheck(this, MDCGridListFoundation);

      var _this = possibleConstructorReturn(this, (MDCGridListFoundation.__proto__ || Object.getPrototypeOf(MDCGridListFoundation)).call(this, _extends(MDCGridListFoundation.defaultAdapter, adapter)));

      _this.resizeHandler_ = function () {
        return _this.alignCenter();
      };
      _this.resizeFrame_ = 0;
      return _this;
    }

    createClass(MDCGridListFoundation, [{
      key: 'init',
      value: function init() {
        this.alignCenter();
        this.adapter_.registerResizeHandler(this.resizeHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterResizeHandler(this.resizeHandler_);
      }
    }, {
      key: 'alignCenter',
      value: function alignCenter() {
        var _this2 = this;

        if (this.resizeFrame_ !== 0) {
          cancelAnimationFrame(this.resizeFrame_);
        }
        this.resizeFrame_ = requestAnimationFrame(function () {
          _this2.alignCenter_();
          _this2.resizeFrame_ = 0;
        });
      }
    }, {
      key: 'alignCenter_',
      value: function alignCenter_() {
        if (this.adapter_.getNumberOfTiles() == 0) {
          return;
        }
        var gridWidth = this.adapter_.getOffsetWidth();
        var itemWidth = this.adapter_.getOffsetWidthForTileAtIndex(0);
        var tilesWidth = itemWidth * Math.floor(gridWidth / itemWidth);
        this.adapter_.setStyleForTilesElement('width', tilesWidth + 'px');
      }
    }]);
    return MDCGridListFoundation;
  }(MDCFoundation);

  var mdcGridList = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-grid-list" }, [_c('ul', { staticClass: "mdc-grid-list__tiles", class: _vm.classes, style: _vm.styles }, [_vm._t("default")], 2)]);
    }, staticRenderFns: [],
    name: 'mdc-grid-list',
    props: {
      width: [String, Number],
      ratio: String,
      'narrow-gutter': Boolean,
      'header-caption': Boolean,
      'icon-align-start': Boolean,
      'icon-align-end': Boolean,
      'with-support-text': Boolean,
      interactive: Boolean
    },
    provide: function provide() {
      return { mdcGrid: this };
    },

    computed: {
      classes: function classes() {
        var classes = {};

        classes['mdc-grid-list--tile-gutter-1'] = this.narrowGutter;
        classes['mdc-grid-list--header-caption'] = this.headerCaption;
        classes['mdc-grid-list--tile-aspect-' + this.ratio] = this.ratio;
        classes['mdc-grid-list--with-icon-align-start'] = this.iconAlignStart;
        classes['mdc-grid-list--with-icon-align-end'] = this.iconAlignEnd;
        classes['mdc-grid-list--twoline-caption'] = this.withSupportText;
        classes['mdc-grid-list--non-interactive'] = !this.interactive;

        return classes;
      },
      styles: function styles() {
        var defaultWidth = 200;
        return {
          '--mdc-grid-list-tile-width': (this.width || defaultWidth) + 'px'
        };
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCGridListFoundation({
        getOffsetWidth: function getOffsetWidth() {
          return _this.$el.offsetWidth;
        },
        getNumberOfTiles: function getNumberOfTiles() {
          return _this.$el.querySelectorAll(MDCGridListFoundation.strings.TILE_SELECTOR).length;
        },
        getOffsetWidthForTileAtIndex: function getOffsetWidthForTileAtIndex(index) {
          return _this.$el.querySelectorAll(MDCGridListFoundation.strings.TILE_SELECTOR)[index].offsetWidth;
        },
        setStyleForTilesElement: function setStyleForTilesElement(property, value) {
          _this.$el.querySelector(MDCGridListFoundation.strings.TILES_SELECTOR).style[property] = value;
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          window.removeEventListener('resize', handler);
        }
      });
      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    }
  };

  var mdcGridTile = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('li', _vm._g({ staticClass: "mdc-grid-tile", class: [_vm.classes, _vm.itemClasses], style: _vm.styles, attrs: { "tabindex": _vm.isInteractive ? '0' : undefined } }, _vm.isInteractive ? _vm.listeners : _vm.clickListener), [_vm.cover ? _c('div', { staticClass: "mdc-grid-tile__primary" }, [_c('div', { staticClass: "mdc-grid-tile__primary-content", style: { backgroundImage: 'url(' + _vm.src + ')' } })]) : _c('div', { staticClass: "mdc-grid-tile__primary" }, [_c('img', { staticClass: "mdc-grid-tile__primary-content", attrs: { "src": _vm.src } })]), _vm._v(" "), _vm.title || _vm.supportText ? _c('span', { staticClass: "mdc-grid-tile__secondary" }, [_vm.icon ? _c('i', { staticClass: "mdc-grid-tile__icon material-icons" }, [_vm._v(_vm._s(_vm.icon))]) : _vm._e(), _vm._v(" "), _vm.title ? _c('span', { staticClass: "mdc-grid-tile__title" }, [_vm._v(_vm._s(_vm.title))]) : _vm._e(), _vm._v(" "), _vm.supportText ? _c('span', { staticClass: "mdc-grid-tile__support-text" }, [_vm._v(_vm._s(_vm.supportText))]) : _vm._e()]) : _vm._e()]);
    }, staticRenderFns: [],
    name: 'mdc-grid-tile',
    inject: ['mdcGrid'],
    mixins: [DispatchEventMixin],
    props: {
      src: String,
      cover: Boolean,
      icon: String,
      title: String,
      'support-text': String,
      selected: Boolean,
      activated: Boolean
    },
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },

    computed: {
      clickListener: function clickListener() {
        var _this = this;

        return { click: function click(e) {
            return _this.dispatchEvent(e);
          } };
      },
      itemClasses: function itemClasses() {
        return {
          'mdc-grid-tile--selected': this.selected,
          'mdc-grid-tile--activated': this.activated
        };
      },
      isInteractive: function isInteractive() {
        return this.mdcGrid && this.mdcGrid.interactive;
      },
      hasStartDetail: function hasStartDetail() {
        return this.startIcon || this.$slots['start-detail'];
      },
      hasEndDetail: function hasEndDetail() {
        return this.endIcon || this.$slots['end-detail'];
      }
    },
    watch: {
      isInteractive: function isInteractive(value) {
        if (value) {
          this.addRipple();
        } else {
          this.removeRipple();
        }
      }
    },
    mounted: function mounted() {
      this.isInteractive && this.addRipple();
    },
    beforeDestroy: function beforeDestroy() {
      this.removeRipple();
    },

    methods: {
      addRipple: function addRipple() {
        if (!this.ripple) {
          var ripple = new RippleBase(this);
          ripple.init();
          this.ripple = ripple;
        }
      },
      removeRipple: function removeRipple() {
        if (this.ripple) {
          var ripple = this.ripple;
          this.ripple = null;
          ripple.destroy();
        }
      }
    }
  };

  var VueMDCGridList = BasePlugin({
    mdcGridList: mdcGridList,
    mdcGridTile: mdcGridTile
  });

  var mdcIcon = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('span', { staticClass: "mdc-icon mdc-icon--material", class: { 'material-icons': !!_vm.icon } }, [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2);
    }, staticRenderFns: [],
    name: 'mdc-icon',
    props: {
      icon: String
    }
  };

  var VueMDCIcon = BasePlugin({
    mdcIcon: mdcIcon
  });

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Icon Toggle. Provides an interface for managing
   * - classes
   * - dom
   * - inner text
   * - event handlers
   * - event dispatch
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */

  var MDCIconToggleAdapter = function () {
    function MDCIconToggleAdapter() {
      classCallCheck(this, MDCIconToggleAdapter);
    }

    createClass(MDCIconToggleAdapter, [{
      key: "addClass",

      /** @param {string} className */
      value: function addClass(className) {}

      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * @param {string} type
       * @param {!EventListener} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(type, handler) {}

      /**
       * @param {string} type
       * @param {!EventListener} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(type, handler) {}

      /** @param {string} text */

    }, {
      key: "setText",
      value: function setText(text) {}

      /** @return {number} */

    }, {
      key: "getTabIndex",
      value: function getTabIndex() {}

      /** @param {number} tabIndex */

    }, {
      key: "setTabIndex",
      value: function setTabIndex(tabIndex) {}

      /**
       * @param {string} name
       * @return {string}
       */

    }, {
      key: "getAttr",
      value: function getAttr(name) {}

      /**
       * @param {string} name
       * @param {string} value
       */

    }, {
      key: "setAttr",
      value: function setAttr(name, value) {}

      /** @param {string} name */

    }, {
      key: "rmAttr",
      value: function rmAttr(name) {}

      /** @param {!IconToggleEvent} evtData */

    }, {
      key: "notifyChange",
      value: function notifyChange(evtData) {}
    }]);
    return MDCIconToggleAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses$8 = {
    ROOT: 'mdc-icon-toggle',
    DISABLED: 'mdc-icon-toggle--disabled'
  };

  /** @enum {string} */
  var strings$9 = {
    DATA_TOGGLE_ON: 'data-toggle-on',
    DATA_TOGGLE_OFF: 'data-toggle-off',
    ARIA_PRESSED: 'aria-pressed',
    ARIA_DISABLED: 'aria-disabled',
    ARIA_LABEL: 'aria-label',
    CHANGE_EVENT: 'MDCIconToggle:change'
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCIconToggleAdapter>}
   */

  var MDCIconToggleFoundation = function (_MDCFoundation) {
    inherits(MDCIconToggleFoundation, _MDCFoundation);
    createClass(MDCIconToggleFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$8;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$9;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
          setText: function setText() /* text: string */{},
          getTabIndex: function getTabIndex() {
            return (/* number */0
            );
          },
          setTabIndex: function setTabIndex() /* tabIndex: number */{},
          getAttr: function getAttr() {
            return (/* name: string */ /* string */''
            );
          },
          setAttr: function setAttr() /* name: string, value: string */{},
          rmAttr: function rmAttr() /* name: string */{},
          notifyChange: function notifyChange() /* evtData: IconToggleEvent */{}
        };
      }
    }]);

    function MDCIconToggleFoundation(adapter) {
      classCallCheck(this, MDCIconToggleFoundation);

      /** @private {boolean} */
      var _this = possibleConstructorReturn(this, (MDCIconToggleFoundation.__proto__ || Object.getPrototypeOf(MDCIconToggleFoundation)).call(this, _extends(MDCIconToggleFoundation.defaultAdapter, adapter)));

      _this.on_ = false;

      /** @private {boolean} */
      _this.disabled_ = false;

      /** @private {number} */
      _this.savedTabIndex_ = -1;

      /** @private {?IconToggleState} */
      _this.toggleOnData_ = null;

      /** @private {?IconToggleState} */
      _this.toggleOffData_ = null;

      _this.clickHandler_ = /** @private {!EventListener} */function () {
        return _this.toggleFromEvt_();
      };

      /** @private {boolean} */
      _this.isHandlingKeydown_ = false;

      _this.keydownHandler_ = /** @private {!EventListener} */function ( /** @type {!KeyboardKey} */evt) {
        if (isSpace(evt)) {
          _this.isHandlingKeydown_ = true;
          return evt.preventDefault();
        }
      };

      _this.keyupHandler_ = /** @private {!EventListener} */function ( /** @type {!KeyboardKey} */evt) {
        if (isSpace(evt)) {
          _this.isHandlingKeydown_ = false;
          _this.toggleFromEvt_();
        }
      };
      return _this;
    }

    createClass(MDCIconToggleFoundation, [{
      key: 'init',
      value: function init() {
        this.refreshToggleData();
        this.savedTabIndex_ = this.adapter_.getTabIndex();
        this.adapter_.registerInteractionHandler('click', this.clickHandler_);
        this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.registerInteractionHandler('keyup', this.keyupHandler_);
      }
    }, {
      key: 'refreshToggleData',
      value: function refreshToggleData() {
        var _MDCIconToggleFoundat = MDCIconToggleFoundation.strings,
            DATA_TOGGLE_ON = _MDCIconToggleFoundat.DATA_TOGGLE_ON,
            DATA_TOGGLE_OFF = _MDCIconToggleFoundat.DATA_TOGGLE_OFF;

        this.toggleOnData_ = this.parseJsonDataAttr_(DATA_TOGGLE_ON);
        this.toggleOffData_ = this.parseJsonDataAttr_(DATA_TOGGLE_OFF);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
        this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.deregisterInteractionHandler('keyup', this.keyupHandler_);
      }

      /** @private */

    }, {
      key: 'toggleFromEvt_',
      value: function toggleFromEvt_() {
        this.toggle();
        var isOn = this.on_;

        this.adapter_.notifyChange( /** @type {!IconToggleEvent} */{ isOn: isOn });
      }

      /** @return {boolean} */

    }, {
      key: 'isOn',
      value: function isOn() {
        return this.on_;
      }

      /** @param {boolean=} isOn */

    }, {
      key: 'toggle',
      value: function toggle() {
        var isOn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !this.on_;

        this.on_ = isOn;

        var _MDCIconToggleFoundat2 = MDCIconToggleFoundation.strings,
            ARIA_LABEL = _MDCIconToggleFoundat2.ARIA_LABEL,
            ARIA_PRESSED = _MDCIconToggleFoundat2.ARIA_PRESSED;


        if (this.on_) {
          this.adapter_.setAttr(ARIA_PRESSED, 'true');
        } else {
          this.adapter_.setAttr(ARIA_PRESSED, 'false');
        }

        var _ref = this.on_ ? this.toggleOffData_ : this.toggleOnData_,
            classToRemove = _ref.cssClass;

        if (classToRemove) {
          this.adapter_.removeClass(classToRemove);
        }

        var _ref2 = this.on_ ? this.toggleOnData_ : this.toggleOffData_,
            content = _ref2.content,
            label = _ref2.label,
            cssClass = _ref2.cssClass;

        if (cssClass) {
          this.adapter_.addClass(cssClass);
        }
        if (content) {
          this.adapter_.setText(content);
        }
        if (label) {
          this.adapter_.setAttr(ARIA_LABEL, label);
        }
      }

      /**
       * @param {string} dataAttr
       * @return {!IconToggleState}
       */

    }, {
      key: 'parseJsonDataAttr_',
      value: function parseJsonDataAttr_(dataAttr) {
        var val = this.adapter_.getAttr(dataAttr);
        if (!val) {
          return {};
        }
        return (/** @type {!IconToggleState} */JSON.parse(val)
        );
      }

      /** @return {boolean} */

    }, {
      key: 'isDisabled',
      value: function isDisabled() {
        return this.disabled_;
      }

      /** @param {boolean} isDisabled */

    }, {
      key: 'setDisabled',
      value: function setDisabled(isDisabled) {
        this.disabled_ = isDisabled;

        var DISABLED = MDCIconToggleFoundation.cssClasses.DISABLED;
        var ARIA_DISABLED = MDCIconToggleFoundation.strings.ARIA_DISABLED;


        if (this.disabled_) {
          this.savedTabIndex_ = this.adapter_.getTabIndex();
          this.adapter_.setTabIndex(-1);
          this.adapter_.setAttr(ARIA_DISABLED, 'true');
          this.adapter_.addClass(DISABLED);
        } else {
          this.adapter_.setTabIndex(this.savedTabIndex_);
          this.adapter_.rmAttr(ARIA_DISABLED);
          this.adapter_.removeClass(DISABLED);
        }
      }

      /** @return {boolean} */

    }, {
      key: 'isKeyboardActivated',
      value: function isKeyboardActivated() {
        return this.isHandlingKeydown_;
      }
    }]);
    return MDCIconToggleFoundation;
  }(MDCFoundation);

  /**
   * @param {!KeyboardKey} keyboardKey
   * @return {boolean}
   */
  function isSpace(keyboardKey) {
    return keyboardKey.key === 'Space' || keyboardKey.keyCode === 32;
  }

  var mdcIConToggle = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('span', { staticClass: "mdc-icon-toggle", class: _vm.classes, style: _vm.styles, attrs: { "tabindex": _vm.tabIndex, "data-toggle-on": _vm.toggleOnData, "data-toggle-off": _vm.toggleOffData, "role": "button", "aria-pressed": "false" } }, [_c('i', { class: _vm.iconClasses, attrs: { "aria-hidden": "true" } }, [_vm._v(_vm._s(_vm.text))])]);
    }, staticRenderFns: [],
    name: 'mdc-icon-toggle',
    props: {
      toggleOn: [String, Object],
      toggleOff: [String, Object],
      value: Boolean,
      disabled: Boolean,
      accent: Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-icon-toggle--accent': this.accent
        },
        styles: {},
        iconClasses: {},
        tabIndex: 0,
        text: ''
      };
    },

    computed: {
      toggleOnData: function toggleOnData() {
        var toggle = this.toggleOn;
        return toggle && JSON.stringify(typeof toggle === 'string' ? {
          content: toggle,
          cssClass: 'material-icons'
        } : {
          content: toggle.icon || toggle.content,
          label: toggle.label,
          cssClass: toggle.icon ? 'material-icons' : toggle.cssClass
        });
      },
      toggleOffData: function toggleOffData() {
        var toggle = this.toggleOff;
        return toggle && JSON.stringify(typeof toggle === 'string' ? {
          content: toggle,
          cssClass: 'material-icons'
        } : {
          content: toggle.icon || toggle.content,
          label: toggle.label,
          cssClass: toggle.icon ? 'material-icons' : toggle.cssClass
        });
      }
    },
    watch: {
      value: function value(_value) {
        this.foundation && this.foundation.toggle(_value);
      },
      disabled: function disabled(_disabled) {
        this.foundation && this.foundation.setDisabled(_disabled);
      },
      toggleOnData: function toggleOnData() {
        this.foundation && this.foundation.refreshToggleData();
      },
      toggleOffData: function toggleOffData() {
        this.foundation && this.foundation.refreshToggleData();
      },
      accent: function accent(value) {
        this.$set(this.classes, 'mdc-icon-toggle--secondary', value);
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCIconToggleFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.iconClasses, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.iconClasses, className);
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          return _this.$el.addEventListener(evt, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          return _this.$el.removeEventListener(evt, handler);
        },
        setText: function setText(text) {
          _this.text = text;
        },
        getTabIndex: function getTabIndex() {
          return _this.tabIndex;
        },
        setTabIndex: function setTabIndex(tabIndex) {
          _this.tabIndex = tabIndex;
        },
        getAttr: function getAttr(name, value) {
          return _this.$el.getAttribute(name, value);
        },
        setAttr: function setAttr(name, value) {
          _this.$el.setAttribute(name, value);
        },
        rmAttr: function rmAttr(name) {
          _this.$el.removeAttribute(name);
        },
        notifyChange: function notifyChange(evtData) {
          _this.$emit('input', evtData.isOn);
        }
      });
      this.foundation.init();
      this.foundation.toggle(this.value);
      this.foundation.setDisabled(this.disabled);

      this.ripple = new RippleBase(this, {
        isUnbounded: function isUnbounded() {
          return true;
        },
        isSurfaceActive: function isSurfaceActive() {
          return _this.foundation.isKeyboardActivated();
        }
      });
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
      this.ripple.destroy();
    }
  };

  var VueMDCIconToggle = BasePlugin({
    mdcIConToggle: mdcIConToggle
  });

  var mdcLayoutApp = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-layout-app" }, [_c('div', { staticClass: "mdc-layout-app--toolbar-wrapper" }, [_vm._t("toolbar")], 2), _vm._v(" "), _c('div', { staticClass: "mdc-layout-app--main-container" }, [_c('div', { staticClass: "mdc-layout-app--drawer-wrapper" }, [_vm._t("drawer")], 2), _vm._v(" "), _c('div', { staticClass: "mdc-layout-app--content-wrapper" }, [_vm._t("default")], 2)])]);
    }, staticRenderFns: [],
    name: 'mdc-layout-app'
  };

  var VueMDCLayoutApp = BasePlugin({
    mdcLayoutApp: mdcLayoutApp
  });

  var mdcLayoutGrid = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { class: _vm.classes }, [_c('div', { staticClass: "mdc-layout-grid__inner" }, [_vm._t("default")], 2)]);
    }, staticRenderFns: [],
    name: 'mdc-layout-grid',
    props: {
      'fixed-column-width': Boolean,
      'align-left': Boolean,
      'align-right': Boolean
    },
    computed: {
      classes: function classes() {
        return {
          'mdc-layout-grid': true,
          'mdc-layout-grid--fixed-column-width': this.fixedColumnWidth,
          'mdc-layout-grid--align-left': this.alignLeft,
          'mdc-layout-grid--align-right': this.alignRight
        };
      }
    }
  };

  var spanOptions = {
    type: [String, Number],
    default: null,
    validator: function validator(value) {
      var num = Number(value);
      return isFinite(num) && num <= 12 && num > 0;
    }
  };

  var mdcLayoutCell = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-layout-cell mdc-layout-grid__cell", class: _vm.classes }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-layout-cell',
    props: {
      span: spanOptions,
      order: spanOptions,
      phone: spanOptions,
      tablet: spanOptions,
      desktop: spanOptions,
      align: {
        type: String,
        validator: function validator(value) {
          return ['top', 'bottom', 'middle'].indexOf(value) !== -1;
        }
      }
    },
    computed: {
      classes: function classes() {
        var classes = [];

        if (this.span) {
          classes.push("mdc-layout-grid__cell--span-" + this.span);
        }

        if (this.order) {
          classes.push("mdc-layout-grid__cell--order-" + this.order);
        }

        if (this.phone) {
          classes.push("mdc-layout-grid__cell--span-" + this.phone + "-phone");
        }

        if (this.tablet) {
          classes.push("mdc-layout-grid__cell--span-" + this.tablet + "-tablet");
        }

        if (this.desktop) {
          classes.push("mdc-layout-grid__cell--span-" + this.desktop + "-desktop");
        }

        if (this.align) {
          classes.push("mdc-layout-grid__cell--align-" + this.align);
        }

        return classes;
      }
    }
  };

  var mdcLayoutInnerGrid = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-layout-inner-grid mdc-layout-grid__inner" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-layout-inner-grid'
  };

  var VueMDCLayoutGrid = BasePlugin({
    mdcLayoutGrid: mdcLayoutGrid,
    mdcLayoutCell: mdcLayoutCell,
    mdcLayoutInnerGrid: mdcLayoutInnerGrid
  });

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$9 = {
    CLOSED_CLASS: 'mdc-linear-progress--closed',
    INDETERMINATE_CLASS: 'mdc-linear-progress--indeterminate',
    REVERSED_CLASS: 'mdc-linear-progress--reversed'
  };

  var strings$a = {
    PRIMARY_BAR_SELECTOR: '.mdc-linear-progress__primary-bar',
    BUFFER_SELECTOR: '.mdc-linear-progress__buffer'
  };

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCLinearProgressFoundation = function (_MDCFoundation) {
    inherits(MDCLinearProgressFoundation, _MDCFoundation);
    createClass(MDCLinearProgressFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$9;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$a;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          getPrimaryBar: function getPrimaryBar() /* el: Element */{},
          getBuffer: function getBuffer() /* el: Element */{},
          hasClass: function hasClass() {
            return (/* className: string */false
            );
          },
          removeClass: function removeClass() /* className: string */{},
          setStyle: function setStyle() /* el: Element, styleProperty: string, value: string */{}
        };
      }
    }]);

    function MDCLinearProgressFoundation(adapter) {
      classCallCheck(this, MDCLinearProgressFoundation);
      return possibleConstructorReturn(this, (MDCLinearProgressFoundation.__proto__ || Object.getPrototypeOf(MDCLinearProgressFoundation)).call(this, _extends(MDCLinearProgressFoundation.defaultAdapter, adapter)));
    }

    createClass(MDCLinearProgressFoundation, [{
      key: 'init',
      value: function init() {
        this.determinate_ = !this.adapter_.hasClass(cssClasses$9.INDETERMINATE_CLASS);
        this.reverse_ = this.adapter_.hasClass(cssClasses$9.REVERSED_CLASS);
        this.progress_ = 0;
      }
    }, {
      key: 'setDeterminate',
      value: function setDeterminate(isDeterminate) {
        this.determinate_ = isDeterminate;
        if (this.determinate_) {
          this.adapter_.removeClass(cssClasses$9.INDETERMINATE_CLASS);
          this.setScale_(this.adapter_.getPrimaryBar(), this.progress_);
        } else {
          this.adapter_.addClass(cssClasses$9.INDETERMINATE_CLASS);
          this.setScale_(this.adapter_.getPrimaryBar(), 1);
          this.setScale_(this.adapter_.getBuffer(), 1);
        }
      }
    }, {
      key: 'setProgress',
      value: function setProgress(value) {
        this.progress_ = value;
        if (this.determinate_) {
          this.setScale_(this.adapter_.getPrimaryBar(), value);
        }
      }
    }, {
      key: 'setBuffer',
      value: function setBuffer(value) {
        if (this.determinate_) {
          this.setScale_(this.adapter_.getBuffer(), value);
        }
      }
    }, {
      key: 'setReverse',
      value: function setReverse(isReversed) {
        this.reverse_ = isReversed;
        if (this.reverse_) {
          this.adapter_.addClass(cssClasses$9.REVERSED_CLASS);
        } else {
          this.adapter_.removeClass(cssClasses$9.REVERSED_CLASS);
        }
      }
    }, {
      key: 'open',
      value: function open() {
        this.adapter_.removeClass(cssClasses$9.CLOSED_CLASS);
      }
    }, {
      key: 'close',
      value: function close() {
        this.adapter_.addClass(cssClasses$9.CLOSED_CLASS);
      }
    }, {
      key: 'setScale_',
      value: function setScale_(el, scaleValue) {
        var _this2 = this;

        var value = 'scaleX(' + scaleValue + ')';
        transformStyleProperties.forEach(function (transformStyleProperty) {
          _this2.adapter_.setStyle(el, transformStyleProperty, value);
        });
      }
    }]);
    return MDCLinearProgressFoundation;
  }(MDCFoundation);

  var ProgressPropType = {
    type: [Number, String],
    validator: function validator(value) {
      return Number(value) >= 0 && Number(value) <= 1;
    }
  };

  var mdcLinearProgress = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-linear-progress", class: _vm.classes, style: _vm.styles, attrs: { "role": "progressbar" } }, [_c('div', { staticClass: "mdc-linear-progress__buffering-dots" }), _vm._v(" "), _c('div', { ref: "buffer", staticClass: "mdc-linear-progress__buffer" }), _vm._v(" "), _c('div', { ref: "primary", staticClass: "mdc-linear-progress__bar mdc-linear-progress__primary-bar" }, [_c('span', { staticClass: "mdc-linear-progress__bar-inner" })]), _vm._v(" "), _vm._m(0)]);
    }, staticRenderFns: [function () {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-linear-progress__bar mdc-linear-progress__secondary-bar" }, [_c('span', { staticClass: "mdc-linear-progress__bar-inner" })]);
    }],
    name: 'mdc-linear-progress',
    props: {
      open: { type: Boolean, default: true },
      indeterminate: Boolean,
      reverse: Boolean,
      accent: Boolean,
      progress: ProgressPropType,
      buffer: ProgressPropType
    },
    data: function data() {
      return {
        classes: { 'mdc-linear-progress--accent': this.accent },
        styles: {}
      };
    },

    watch: {
      open: function open() {
        if (this.open) {
          this.foundation.open();
        } else {
          this.foundation.close();
        }
      },
      progress: function progress() {
        this.foundation.setProgress(Number(this.progress));
      },
      buffer: function buffer() {
        this.foundation.setBuffer(Number(this.buffer));
      },
      indeterminate: function indeterminate() {
        this.foundation.setDeterminate(!this.indeterminate);
      },
      reverse: function reverse() {
        this.foundation.setReverse(this.reverse);
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCLinearProgressFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.classes, className, true);
        },
        getPrimaryBar: function getPrimaryBar() /* el: Element */{
          return _this.$refs.primary;
        },
        getBuffer: function getBuffer() /* el: Element */{
          return _this.$refs.buffer;
        },
        hasClass: function hasClass(className) {
          _this.$el.classList.contains(className);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.classes, className);
        },
        setStyle: function setStyle(el, styleProperty, value) {
          el.style[styleProperty] = value;
        }
      });
      this.foundation.init();

      this.foundation.setReverse(this.reverse);
      this.foundation.setProgress(Number(this.progress));
      this.foundation.setBuffer(Number(this.buffer));
      this.foundation.setDeterminate(!this.indeterminate);
      if (this.open) {
        this.foundation.open();
      } else {
        this.foundation.close();
      }
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    }
  };

  var VueMDCLinearProgress = BasePlugin({
    mdcLinearProgress: mdcLinearProgress
  });

  var mdcList = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('ul', { staticClass: "mdc-list", class: _vm.classes }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-list',
    props: {
      dense: Boolean,
      avatarList: Boolean,
      twoLine: Boolean,
      bordered: Boolean,
      interactive: Boolean
    },
    provide: function provide() {
      return { mdcList: this };
    },

    computed: {
      classes: function classes() {
        return {
          'mdc-list--dense': this.dense,
          'mdc-list--avatar-list': this.avatarList,
          'mdc-list--two-line': this.twoLine,
          'mdc-list--bordered': this.bordered,
          'mdc-list--non-interactive': !this.interactive
        };
      }
    }
  };

  var mdcListItem = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('li', _vm._g({ staticClass: "mdc-list-item", class: [_vm.classes, _vm.itemClasses], style: _vm.styles, attrs: { "tabindex": _vm.isInteractive ? '0' : undefined } }, _vm.isInteractive ? _vm.$listeners : {}), [_vm.hasStartDetail ? _c('span', { staticClass: "mdc-list-item__graphic" }, [_vm._t("start-detail")], 2) : _vm._e(), _vm._v(" "), _vm.hasSecondary ? _c('span', { staticClass: "mdc-list-item__text" }, [_vm._t("default"), _vm._v(" "), _c('span', { staticClass: "mdc-list-item__secondary-text" }, [_vm._t("secondary")], 2)], 2) : _vm._t("default"), _vm._v(" "), _vm.hasEndDetail ? _c('span', { staticClass: "mdc-list-item__meta" }, [_vm._t("end-detail")], 2) : _vm._e()], 2);
    }, staticRenderFns: [],
    name: 'mdc-list-item',
    inject: ['mdcList'],
    props: {
      selected: Boolean,
      activated: Boolean
    },
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },

    computed: {
      itemClasses: function itemClasses() {
        return {
          'mdc-list-item--selected': this.selected,
          'mdc-list-item--activated': this.activated
        };
      },
      isInteractive: function isInteractive() {
        return this.mdcList && this.mdcList.interactive;
      },
      hasSecondary: function hasSecondary() {
        return this.$slots['secondary'] && this.mdcList && this.mdcList.twoLine;
      },
      hasEndDetail: function hasEndDetail() {
        return !!this.$slots['end-detail'];
      },
      hasStartDetail: function hasStartDetail() {
        return !!this.$slots['start-detail'];
      }
    },
    watch: {
      isInteractive: function isInteractive(value) {
        if (value) {
          this.addRipple();
        } else {
          this.removeRipple();
        }
      }
    },
    mounted: function mounted() {
      this.isInteractive && this.addRipple();
    },
    beforeDestroy: function beforeDestroy() {
      this.removeRipple();
    },

    methods: {
      addRipple: function addRipple() {
        if (!this.ripple) {
          var ripple = new RippleBase(this);
          ripple.init();
          this.ripple = ripple;
        }
      },
      removeRipple: function removeRipple() {
        if (this.ripple) {
          var ripple = this.ripple;
          this.ripple = null;
          ripple.destroy();
        }
      }
    }
  };

  var mdcListDivider = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('li', { staticClass: "mdc-list-divider", class: _vm.classes, attrs: { "role": "separator" } });
    }, staticRenderFns: [],
    name: 'mdc-list-divider',
    props: {
      inset: Boolean,
      padded: Boolean
    },
    computed: {
      classes: function classes() {
        return {
          'mdc-list-divider--inset': this.inset,
          'mdc-list-divider--padded': this.padded
        };
      }
    }
  };

  var mdcListGroup = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-list-group" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-list-group'
  };

  var mdcListGroupHeader = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('h3', { staticClass: "mdc-list-group-header mdc-list-group__subheader" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-list-group-header'
  };

  var mdcListGroupDivider = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('hr', { staticClass: "mdc-list-group-divider mdc-list-divider" });
    }, staticRenderFns: [],
    name: 'mdc-list-group-divider'
  };

  var VueMDCList = BasePlugin({
    mdcList: mdcList,
    mdcListItem: mdcListItem,
    mdcListDivider: mdcListDivider,
    mdcListGroup: mdcListGroup,
    mdcListGroupHeader: mdcListGroupHeader,
    mdcListGroupDivider: mdcListGroupDivider
  });

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Menu. Provides an interface for managing
   * - classes
   * - dom
   * - focus
   * - position
   * - dimensions
   * - event handlers
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCMenuAdapter = function () {
    function MDCMenuAdapter() {
      classCallCheck(this, MDCMenuAdapter);
    }

    createClass(MDCMenuAdapter, [{
      key: "addClass",

      /** @param {string} className */
      value: function addClass(className) {}

      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}

      /** @return {boolean} */

    }, {
      key: "hasNecessaryDom",
      value: function hasNecessaryDom() {}

      /**
       * @param {EventTarget} target
       * @param {string} attributeName
       * @return {string}
       */

    }, {
      key: "getAttributeForEventTarget",
      value: function getAttributeForEventTarget(target, attributeName) {}

      /** @return {{ width: number, height: number }} */

    }, {
      key: "getInnerDimensions",
      value: function getInnerDimensions() {}

      /** @return {boolean} */

    }, {
      key: "hasAnchor",
      value: function hasAnchor() {}

      /** @return {{width: number, height: number, top: number, right: number, bottom: number, left: number}} */

    }, {
      key: "getAnchorDimensions",
      value: function getAnchorDimensions() {}

      /** @return {{ width: number, height: number }} */

    }, {
      key: "getWindowDimensions",
      value: function getWindowDimensions() {}

      /** @return {number} */

    }, {
      key: "getNumberOfItems",
      value: function getNumberOfItems() {}

      /**
       * @param {string} type
       * @param {function(!Event)} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(type, handler) {}

      /**
       * @param {string} type
       * @param {function(!Event)} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(type, handler) {}

      /** @param {function(!Event)} handler */

    }, {
      key: "registerBodyClickHandler",
      value: function registerBodyClickHandler(handler) {}

      /** @param {function(!Event)} handler */

    }, {
      key: "deregisterBodyClickHandler",
      value: function deregisterBodyClickHandler(handler) {}

      /**
       * @param {EventTarget} target
       * @return {number}
       */

    }, {
      key: "getIndexForEventTarget",
      value: function getIndexForEventTarget(target) {}

      /** @param {{index: number}} evtData */

    }, {
      key: "notifySelected",
      value: function notifySelected(evtData) {}
    }, {
      key: "notifyCancel",
      value: function notifyCancel() {}
    }, {
      key: "saveFocus",
      value: function saveFocus() {}
    }, {
      key: "restoreFocus",
      value: function restoreFocus() {}

      /** @return {boolean} */

    }, {
      key: "isFocused",
      value: function isFocused() {}
    }, {
      key: "focus",
      value: function focus() {}

      /** @return {number} */

    }, {
      key: "getFocusedItemIndex",
      value: function getFocusedItemIndex() /* number */{}

      /** @param {number} index */

    }, {
      key: "focusItemAtIndex",
      value: function focusItemAtIndex(index) {}

      /** @return {boolean} */

    }, {
      key: "isRtl",
      value: function isRtl() {}

      /** @param {string} origin */

    }, {
      key: "setTransformOrigin",
      value: function setTransformOrigin(origin) {}

      /** @param {{
      *   top: (string|undefined),
      *   right: (string|undefined),
      *   bottom: (string|undefined),
      *   left: (string|undefined)
      * }} position */

    }, {
      key: "setPosition",
      value: function setPosition(position) {}

      /** @param {string} height */

    }, {
      key: "setMaxHeight",
      value: function setMaxHeight(height) {}

      /**
       * @param {number} index
       * @param {string} attr
       * @param {string} value
       */

    }, {
      key: "setAttrForOptionAtIndex",
      value: function setAttrForOptionAtIndex(index, attr, value) {}

      /**
       * @param {number} index
       * @param {string} attr
       */

    }, {
      key: "rmAttrForOptionAtIndex",
      value: function rmAttrForOptionAtIndex(index, attr) {}

      /**
       * @param {number} index
       * @param {string} className
       */

    }, {
      key: "addClassForOptionAtIndex",
      value: function addClassForOptionAtIndex(index, className) {}

      /**
       * @param {number} index
       * @param {string} className
       */

    }, {
      key: "rmClassForOptionAtIndex",
      value: function rmClassForOptionAtIndex(index, className) {}
    }]);
    return MDCMenuAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses$a = {
    ROOT: 'mdc-menu',
    OPEN: 'mdc-menu--open',
    ANIMATING_OPEN: 'mdc-menu--animating-open',
    ANIMATING_CLOSED: 'mdc-menu--animating-closed',
    SELECTED_LIST_ITEM: 'mdc-list-item--selected'
  };

  /** @enum {string} */
  var strings$b = {
    ITEMS_SELECTOR: '.mdc-menu__items',
    SELECTED_EVENT: 'MDCMenu:selected',
    CANCEL_EVENT: 'MDCMenu:cancel',
    ARIA_DISABLED_ATTR: 'aria-disabled'
  };

  /** @enum {number} */
  var numbers$2 = {
    // Amount of time to wait before triggering a selected event on the menu. Note that this time
    // will most likely be bumped up once interactive lists are supported to allow for the ripple to
    // animate before closing the menu
    SELECTED_TRIGGER_DELAY: 50,
    // Total duration of menu open animation.
    TRANSITION_OPEN_DURATION: 120,
    // Total duration of menu close animation.
    TRANSITION_CLOSE_DURATION: 75,
    // Margin left to the edge of the viewport when menu is at maximum possible height.
    MARGIN_TO_EDGE: 32,
    // Ratio of anchor width to menu width for switching from corner positioning to center positioning.
    ANCHOR_TO_MENU_WIDTH_RATIO: 0.67,
    // Ratio of vertical offset to menu height for switching from corner to mid-way origin positioning.
    OFFSET_TO_MENU_HEIGHT_RATIO: 0.1
  };

  /**
   * Enum for bits in the {@see Corner) bitmap.
   * @enum {number}
   */
  var CornerBit = {
    BOTTOM: 1,
    CENTER: 2,
    RIGHT: 4,
    FLIP_RTL: 8
  };

  /**
   * Enum for representing an element corner for positioning the menu.
   *
   * The START constants map to LEFT if element directionality is left
   * to right and RIGHT if the directionality is right to left.
   * Likewise END maps to RIGHT or LEFT depending on the directionality.
   *
   * @enum {number}
   */
  var Corner = {
    TOP_LEFT: 0,
    TOP_RIGHT: CornerBit.RIGHT,
    BOTTOM_LEFT: CornerBit.BOTTOM,
    BOTTOM_RIGHT: CornerBit.BOTTOM | CornerBit.RIGHT,
    TOP_START: CornerBit.FLIP_RTL,
    TOP_END: CornerBit.FLIP_RTL | CornerBit.RIGHT,
    BOTTOM_START: CornerBit.BOTTOM | CornerBit.FLIP_RTL,
    BOTTOM_END: CornerBit.BOTTOM | CornerBit.RIGHT | CornerBit.FLIP_RTL
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCMenuAdapter>}
   */

  var MDCMenuFoundation = function (_MDCFoundation) {
    inherits(MDCMenuFoundation, _MDCFoundation);
    createClass(MDCMenuFoundation, null, [{
      key: 'cssClasses',

      /** @return enum{cssClasses} */
      get: function get$$1() {
        return cssClasses$a;
      }

      /** @return enum{strings} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$b;
      }

      /** @return enum{numbers} */

    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers$2;
      }

      /** @return enum{number} */

    }, {
      key: 'Corner',
      get: function get$$1() {
        return Corner;
      }

      /**
       * {@see MDCMenuAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCMenuAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCMenuAdapter} */{
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {
              return false;
            },
            hasNecessaryDom: function hasNecessaryDom() {
              return false;
            },
            getAttributeForEventTarget: function getAttributeForEventTarget() {},
            getInnerDimensions: function getInnerDimensions() {
              return {};
            },
            hasAnchor: function hasAnchor() {
              return false;
            },
            getAnchorDimensions: function getAnchorDimensions() {
              return {};
            },
            getWindowDimensions: function getWindowDimensions() {
              return {};
            },
            getNumberOfItems: function getNumberOfItems() {
              return 0;
            },
            registerInteractionHandler: function registerInteractionHandler() {},
            deregisterInteractionHandler: function deregisterInteractionHandler() {},
            registerBodyClickHandler: function registerBodyClickHandler() {},
            deregisterBodyClickHandler: function deregisterBodyClickHandler() {},
            getIndexForEventTarget: function getIndexForEventTarget() {
              return 0;
            },
            notifySelected: function notifySelected() {},
            notifyCancel: function notifyCancel() {},
            saveFocus: function saveFocus() {},
            restoreFocus: function restoreFocus() {},
            isFocused: function isFocused() {
              return false;
            },
            focus: function focus() {},
            getFocusedItemIndex: function getFocusedItemIndex() {
              return -1;
            },
            focusItemAtIndex: function focusItemAtIndex() {},
            isRtl: function isRtl() {
              return false;
            },
            setTransformOrigin: function setTransformOrigin() {},
            setPosition: function setPosition() {},
            setMaxHeight: function setMaxHeight() {},
            setAttrForOptionAtIndex: function setAttrForOptionAtIndex() {},
            rmAttrForOptionAtIndex: function rmAttrForOptionAtIndex() {},
            addClassForOptionAtIndex: function addClassForOptionAtIndex() {},
            rmClassForOptionAtIndex: function rmClassForOptionAtIndex() {}
          }
        );
      }

      /** @param {!MDCMenuAdapter} adapter */

    }]);

    function MDCMenuFoundation(adapter) {
      classCallCheck(this, MDCMenuFoundation);

      /** @private {function(!Event)} */
      var _this = possibleConstructorReturn(this, (MDCMenuFoundation.__proto__ || Object.getPrototypeOf(MDCMenuFoundation)).call(this, _extends(MDCMenuFoundation.defaultAdapter, adapter)));

      _this.clickHandler_ = function (evt) {
        return _this.handlePossibleSelected_(evt);
      };
      /** @private {function(!Event)} */
      _this.keydownHandler_ = function (evt) {
        return _this.handleKeyboardDown_(evt);
      };
      /** @private {function(!Event)} */
      _this.keyupHandler_ = function (evt) {
        return _this.handleKeyboardUp_(evt);
      };
      /** @private {function(!Event)} */
      _this.documentClickHandler_ = function (evt) {
        return _this.handleDocumentClick_(evt);
      };
      /** @private {boolean} */
      _this.isOpen_ = false;
      /** @private {number} */
      _this.openAnimationEndTimerId_ = 0;
      /** @private {number} */
      _this.closeAnimationEndTimerId_ = 0;
      /** @private {number} */
      _this.selectedTriggerTimerId_ = 0;
      /** @private {number} */
      _this.animationRequestId_ = 0;
      /** @private {!{ width: number, height: number }} */
      _this.dimensions_;
      /** @private {number} */
      _this.itemHeight_;
      /** @private {Corner} */
      _this.anchorCorner_ = Corner.TOP_START;
      /** @private {AnchorMargin} */
      _this.anchorMargin_ = { top: 0, right: 0, bottom: 0, left: 0 };
      /** @private {?AutoLayoutMeasurements} */
      _this.measures_ = null;
      /** @private {number} */
      _this.selectedIndex_ = -1;
      /** @private {boolean} */
      _this.rememberSelection_ = false;
      /** @private {boolean} */
      _this.quickOpen_ = false;

      // A keyup event on the menu needs to have a corresponding keydown
      // event on the menu. If the user opens the menu with a keydown event on a
      // button, the menu will only get the key up event causing buggy behavior with selected elements.
      /** @private {boolean} */
      _this.keyDownWithinMenu_ = false;
      return _this;
    }

    createClass(MDCMenuFoundation, [{
      key: 'init',
      value: function init() {
        var _MDCMenuFoundation$cs = MDCMenuFoundation.cssClasses,
            ROOT = _MDCMenuFoundation$cs.ROOT,
            OPEN = _MDCMenuFoundation$cs.OPEN;


        if (!this.adapter_.hasClass(ROOT)) {
          throw new Error(ROOT + ' class required in root element.');
        }

        if (!this.adapter_.hasNecessaryDom()) {
          throw new Error('Required DOM nodes missing in ' + ROOT + ' component.');
        }

        if (this.adapter_.hasClass(OPEN)) {
          this.isOpen_ = true;
        }

        this.adapter_.registerInteractionHandler('click', this.clickHandler_);
        this.adapter_.registerInteractionHandler('keyup', this.keyupHandler_);
        this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        clearTimeout(this.selectedTriggerTimerId_);
        clearTimeout(this.openAnimationEndTimerId_);
        clearTimeout(this.closeAnimationEndTimerId_);
        // Cancel any currently running animations.
        cancelAnimationFrame(this.animationRequestId_);
        this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
        this.adapter_.deregisterInteractionHandler('keyup', this.keyupHandler_);
        this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.deregisterBodyClickHandler(this.documentClickHandler_);
      }

      /**
       * @param {!Corner} corner Default anchor corner alignment of top-left menu corner.
       */

    }, {
      key: 'setAnchorCorner',
      value: function setAnchorCorner(corner) {
        this.anchorCorner_ = corner;
      }

      /**
       * @param {!AnchorMargin} margin 4-plet of margins from anchor.
       */

    }, {
      key: 'setAnchorMargin',
      value: function setAnchorMargin(margin) {
        this.anchorMargin_.top = typeof margin.top === 'number' ? margin.top : 0;
        this.anchorMargin_.right = typeof margin.right === 'number' ? margin.right : 0;
        this.anchorMargin_.bottom = typeof margin.bottom === 'number' ? margin.bottom : 0;
        this.anchorMargin_.left = typeof margin.left === 'number' ? margin.left : 0;
      }

      /** @param {boolean} rememberSelection */

    }, {
      key: 'setRememberSelection',
      value: function setRememberSelection(rememberSelection) {
        this.rememberSelection_ = rememberSelection;
        this.setSelectedIndex(-1);
      }

      /** @param {boolean} quickOpen */

    }, {
      key: 'setQuickOpen',
      value: function setQuickOpen(quickOpen) {
        this.quickOpen_ = quickOpen;
      }

      /**
       * @param {?number} focusIndex
       * @private
       */

    }, {
      key: 'focusOnOpen_',
      value: function focusOnOpen_(focusIndex) {
        if (focusIndex === null) {
          // If this instance of MDCMenu remembers selections, and the user has
          // made a selection, then focus the last selected item
          if (this.rememberSelection_ && this.selectedIndex_ >= 0) {
            this.adapter_.focusItemAtIndex(this.selectedIndex_);
            return;
          }

          this.adapter_.focus();
          // If that doesn't work, focus first item instead.
          if (!this.adapter_.isFocused()) {
            this.adapter_.focusItemAtIndex(0);
          }
        } else {
          this.adapter_.focusItemAtIndex(focusIndex);
        }
      }

      /**
       * Handle clicks and cancel the menu if not a child list-item
       * @param {!Event} evt
       * @private
       */

    }, {
      key: 'handleDocumentClick_',
      value: function handleDocumentClick_(evt) {
        var el = evt.target;

        while (el && el !== document.documentElement) {
          if (this.adapter_.getIndexForEventTarget(el) !== -1) {
            return;
          }
          el = el.parentNode;
        }

        this.adapter_.notifyCancel();
        this.close(evt);
      }
    }, {
      key: 'handleKeyboardDown_',


      /**
       * Handle keys that we want to repeat on hold (tab and arrows).
       * @param {!Event} evt
       * @return {boolean}
       * @private
       */
      value: function handleKeyboardDown_(evt) {
        // Do nothing if Alt, Ctrl or Meta are pressed.
        if (evt.altKey || evt.ctrlKey || evt.metaKey) {
          return true;
        }

        var keyCode = evt.keyCode,
            key = evt.key,
            shiftKey = evt.shiftKey;

        var isTab = key === 'Tab' || keyCode === 9;
        var isArrowUp = key === 'ArrowUp' || keyCode === 38;
        var isArrowDown = key === 'ArrowDown' || keyCode === 40;
        var isSpace = key === 'Space' || keyCode === 32;
        var isEnter = key === 'Enter' || keyCode === 13;
        // The menu needs to know if the keydown event was triggered on the menu
        this.keyDownWithinMenu_ = isEnter || isSpace;

        var focusedItemIndex = this.adapter_.getFocusedItemIndex();
        var lastItemIndex = this.adapter_.getNumberOfItems() - 1;

        if (shiftKey && isTab && focusedItemIndex === 0) {
          this.adapter_.focusItemAtIndex(lastItemIndex);
          evt.preventDefault();
          return false;
        }

        if (!shiftKey && isTab && focusedItemIndex === lastItemIndex) {
          this.adapter_.focusItemAtIndex(0);
          evt.preventDefault();
          return false;
        }

        // Ensure Arrow{Up,Down} and space do not cause inadvertent scrolling
        if (isArrowUp || isArrowDown || isSpace) {
          evt.preventDefault();
        }

        if (isArrowUp) {
          if (focusedItemIndex === 0 || this.adapter_.isFocused()) {
            this.adapter_.focusItemAtIndex(lastItemIndex);
          } else {
            this.adapter_.focusItemAtIndex(focusedItemIndex - 1);
          }
        } else if (isArrowDown) {
          if (focusedItemIndex === lastItemIndex || this.adapter_.isFocused()) {
            this.adapter_.focusItemAtIndex(0);
          } else {
            this.adapter_.focusItemAtIndex(focusedItemIndex + 1);
          }
        }

        return true;
      }

      /**
       * Handle keys that we don't want to repeat on hold (Enter, Space, Escape).
       * @param {!Event} evt
       * @return {boolean}
       * @private
       */

    }, {
      key: 'handleKeyboardUp_',
      value: function handleKeyboardUp_(evt) {
        // Do nothing if Alt, Ctrl or Meta are pressed.
        if (evt.altKey || evt.ctrlKey || evt.metaKey) {
          return true;
        }

        var keyCode = evt.keyCode,
            key = evt.key;

        var isEnter = key === 'Enter' || keyCode === 13;
        var isSpace = key === 'Space' || keyCode === 32;
        var isEscape = key === 'Escape' || keyCode === 27;

        if (isEnter || isSpace) {
          // If the keydown event didn't occur on the menu, then it should
          // disregard the possible selected event.
          if (this.keyDownWithinMenu_) {
            this.handlePossibleSelected_(evt);
          }
          this.keyDownWithinMenu_ = false;
        }

        if (isEscape) {
          this.adapter_.notifyCancel();
          this.close();
        }

        return true;
      }

      /**
       * @param {!Event} evt
       * @private
       */

    }, {
      key: 'handlePossibleSelected_',
      value: function handlePossibleSelected_(evt) {
        var _this2 = this;

        if (this.adapter_.getAttributeForEventTarget(evt.target, strings$b.ARIA_DISABLED_ATTR) === 'true') {
          return;
        }
        var targetIndex = this.adapter_.getIndexForEventTarget(evt.target);
        if (targetIndex < 0) {
          return;
        }
        // Debounce multiple selections
        if (this.selectedTriggerTimerId_) {
          return;
        }
        this.selectedTriggerTimerId_ = setTimeout(function () {
          _this2.selectedTriggerTimerId_ = 0;
          _this2.close();
          if (_this2.rememberSelection_) {
            _this2.setSelectedIndex(targetIndex);
          }
          _this2.adapter_.notifySelected({ index: targetIndex });
        }, numbers$2.SELECTED_TRIGGER_DELAY);
      }

      /**
       * @return {AutoLayoutMeasurements} Measurements used to position menu popup.
       */

    }, {
      key: 'getAutoLayoutMeasurements_',
      value: function getAutoLayoutMeasurements_() {
        var anchorRect = this.adapter_.getAnchorDimensions();
        var viewport = this.adapter_.getWindowDimensions();

        return {
          viewport: viewport,
          viewportDistance: {
            top: anchorRect.top,
            right: viewport.width - anchorRect.right,
            left: anchorRect.left,
            bottom: viewport.height - anchorRect.bottom
          },
          anchorHeight: anchorRect.height,
          anchorWidth: anchorRect.width,
          menuHeight: this.dimensions_.height,
          menuWidth: this.dimensions_.width
        };
      }

      /**
       * Computes the corner of the anchor from which to animate and position the menu.
       * @return {Corner}
       * @private
       */

    }, {
      key: 'getOriginCorner_',
      value: function getOriginCorner_() {
        // Defaults: open from the top left.
        var corner = Corner.TOP_LEFT;

        var _measures_ = this.measures_,
            viewportDistance = _measures_.viewportDistance,
            anchorHeight = _measures_.anchorHeight,
            anchorWidth = _measures_.anchorWidth,
            menuHeight = _measures_.menuHeight,
            menuWidth = _measures_.menuWidth;

        var isBottomAligned = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);
        var availableTop = isBottomAligned ? viewportDistance.top + anchorHeight + this.anchorMargin_.bottom : viewportDistance.top + this.anchorMargin_.top;
        var availableBottom = isBottomAligned ? viewportDistance.bottom - this.anchorMargin_.bottom : viewportDistance.bottom + anchorHeight - this.anchorMargin_.top;

        var topOverflow = menuHeight - availableTop;
        var bottomOverflow = menuHeight - availableBottom;
        if (bottomOverflow > 0 && topOverflow < bottomOverflow) {
          corner |= CornerBit.BOTTOM;
        }

        var isRtl = this.adapter_.isRtl();
        var isFlipRtl = Boolean(this.anchorCorner_ & CornerBit.FLIP_RTL);
        var avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);
        var isAlignedRight = avoidHorizontalOverlap && !isRtl || !avoidHorizontalOverlap && isFlipRtl && isRtl;
        var availableLeft = isAlignedRight ? viewportDistance.left + anchorWidth + this.anchorMargin_.right : viewportDistance.left + this.anchorMargin_.left;
        var availableRight = isAlignedRight ? viewportDistance.right - this.anchorMargin_.right : viewportDistance.right + anchorWidth - this.anchorMargin_.left;

        var leftOverflow = menuWidth - availableLeft;
        var rightOverflow = menuWidth - availableRight;

        if (leftOverflow < 0 && isAlignedRight && isRtl || avoidHorizontalOverlap && !isAlignedRight && leftOverflow < 0 || rightOverflow > 0 && leftOverflow < rightOverflow) {
          corner |= CornerBit.RIGHT;
        }

        return corner;
      }

      /**
       * @param {Corner} corner Origin corner of the menu.
       * @return {number} Horizontal offset of menu origin corner from corresponding anchor corner.
       * @private
       */

    }, {
      key: 'getHorizontalOriginOffset_',
      value: function getHorizontalOriginOffset_(corner) {
        var anchorWidth = this.measures_.anchorWidth;

        var isRightAligned = Boolean(corner & CornerBit.RIGHT);
        var avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);
        var x = 0;
        if (isRightAligned) {
          var rightOffset = avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.left : this.anchorMargin_.right;
          x = rightOffset;
        } else {
          var leftOffset = avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.right : this.anchorMargin_.left;
          x = leftOffset;
        }
        return x;
      }

      /**
       * @param {Corner} corner Origin corner of the menu.
       * @return {number} Vertical offset of menu origin corner from corresponding anchor corner.
       * @private
       */

    }, {
      key: 'getVerticalOriginOffset_',
      value: function getVerticalOriginOffset_(corner) {
        var _measures_2 = this.measures_,
            viewport = _measures_2.viewport,
            viewportDistance = _measures_2.viewportDistance,
            anchorHeight = _measures_2.anchorHeight,
            menuHeight = _measures_2.menuHeight;

        var isBottomAligned = Boolean(corner & CornerBit.BOTTOM);
        var MARGIN_TO_EDGE = MDCMenuFoundation.numbers.MARGIN_TO_EDGE;

        var avoidVerticalOverlap = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);
        var canOverlapVertically = !avoidVerticalOverlap;
        var y = 0;

        if (isBottomAligned) {
          y = avoidVerticalOverlap ? anchorHeight - this.anchorMargin_.top : -this.anchorMargin_.bottom;
          // adjust for when menu can overlap anchor, but too tall to be aligned to bottom
          // anchor corner. Bottom margin is ignored in such cases.
          if (canOverlapVertically && menuHeight > viewportDistance.top + anchorHeight) {
            y = -(Math.min(menuHeight, viewport.height - MARGIN_TO_EDGE) - (viewportDistance.top + anchorHeight));
          }
        } else {
          y = avoidVerticalOverlap ? anchorHeight + this.anchorMargin_.bottom : this.anchorMargin_.top;
          // adjust for when menu can overlap anchor, but too tall to be aligned to top
          // anchor corners. Top margin is ignored in that case.
          if (canOverlapVertically && menuHeight > viewportDistance.bottom + anchorHeight) {
            y = -(Math.min(menuHeight, viewport.height - MARGIN_TO_EDGE) - (viewportDistance.bottom + anchorHeight));
          }
        }
        return y;
      }

      /**
       * @param {Corner} corner Origin corner of the menu.
       * @return {number} Maximum height of the menu, based on available space. 0 indicates should not be set.
       * @private
       */

    }, {
      key: 'getMenuMaxHeight_',
      value: function getMenuMaxHeight_(corner) {
        var maxHeight = 0;
        var viewportDistance = this.measures_.viewportDistance;

        var isBottomAligned = Boolean(corner & CornerBit.BOTTOM);

        // When maximum height is not specified, it is handled from css.
        if (this.anchorCorner_ & CornerBit.BOTTOM) {
          if (isBottomAligned) {
            maxHeight = viewportDistance.top + this.anchorMargin_.top;
          } else {
            maxHeight = viewportDistance.bottom - this.anchorMargin_.bottom;
          }
        }

        return maxHeight;
      }

      /** @private */

    }, {
      key: 'autoPosition_',
      value: function autoPosition_() {
        var _position;

        if (!this.adapter_.hasAnchor()) {
          return;
        }

        // Compute measurements for autoposition methods reuse.
        this.measures_ = this.getAutoLayoutMeasurements_();

        var corner = this.getOriginCorner_();
        var maxMenuHeight = this.getMenuMaxHeight_(corner);
        var verticalAlignment = corner & CornerBit.BOTTOM ? 'bottom' : 'top';
        var horizontalAlignment = corner & CornerBit.RIGHT ? 'right' : 'left';
        var horizontalOffset = this.getHorizontalOriginOffset_(corner);
        var verticalOffset = this.getVerticalOriginOffset_(corner);
        var position = (_position = {}, defineProperty(_position, horizontalAlignment, horizontalOffset ? horizontalOffset + 'px' : '0'), defineProperty(_position, verticalAlignment, verticalOffset ? verticalOffset + 'px' : '0'), _position);
        var _measures_3 = this.measures_,
            anchorWidth = _measures_3.anchorWidth,
            menuHeight = _measures_3.menuHeight,
            menuWidth = _measures_3.menuWidth;
        // Center align when anchor width is comparable or greater than menu, otherwise keep corner.

        if (anchorWidth / menuWidth > numbers$2.ANCHOR_TO_MENU_WIDTH_RATIO) {
          horizontalAlignment = 'center';
        }

        // Adjust vertical origin when menu is positioned with significant offset from anchor. This is done so that
        // scale animation is "anchored" on the anchor.
        if (!(this.anchorCorner_ & CornerBit.BOTTOM) && Math.abs(verticalOffset / menuHeight) > numbers$2.OFFSET_TO_MENU_HEIGHT_RATIO) {
          var verticalOffsetPercent = Math.abs(verticalOffset / menuHeight) * 100;
          var originPercent = corner & CornerBit.BOTTOM ? 100 - verticalOffsetPercent : verticalOffsetPercent;
          verticalAlignment = Math.round(originPercent * 100) / 100 + '%';
        }

        this.adapter_.setTransformOrigin(horizontalAlignment + ' ' + verticalAlignment);
        this.adapter_.setPosition(position);
        this.adapter_.setMaxHeight(maxMenuHeight ? maxMenuHeight + 'px' : '');

        // Clear measures after positioning is complete.
        this.measures_ = null;
      }

      /**
       * Open the menu.
       * @param {{focusIndex: ?number}=} options
       */

    }, {
      key: 'open',
      value: function open() {
        var _this3 = this;

        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref$focusIndex = _ref.focusIndex,
            focusIndex = _ref$focusIndex === undefined ? null : _ref$focusIndex;

        this.adapter_.saveFocus();

        if (!this.quickOpen_) {
          this.adapter_.addClass(MDCMenuFoundation.cssClasses.ANIMATING_OPEN);
        }

        this.animationRequestId_ = requestAnimationFrame(function () {
          _this3.dimensions_ = _this3.adapter_.getInnerDimensions();
          _this3.autoPosition_();
          _this3.adapter_.addClass(MDCMenuFoundation.cssClasses.OPEN);
          _this3.focusOnOpen_(focusIndex);
          _this3.adapter_.registerBodyClickHandler(_this3.documentClickHandler_);
          if (!_this3.quickOpen_) {
            _this3.openAnimationEndTimerId_ = setTimeout(function () {
              _this3.openAnimationEndTimerId_ = 0;
              _this3.adapter_.removeClass(MDCMenuFoundation.cssClasses.ANIMATING_OPEN);
            }, numbers$2.TRANSITION_OPEN_DURATION);
          }
        });
        this.isOpen_ = true;
      }

      /**
       * Closes the menu.
       * @param {Event=} evt
       */

    }, {
      key: 'close',
      value: function close() {
        var _this4 = this;

        var evt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        var targetIsDisabled = evt ? this.adapter_.getAttributeForEventTarget(evt.target, strings$b.ARIA_DISABLED_ATTR) === 'true' : false;

        if (targetIsDisabled) {
          return;
        }

        this.adapter_.deregisterBodyClickHandler(this.documentClickHandler_);

        if (!this.quickOpen_) {
          this.adapter_.addClass(MDCMenuFoundation.cssClasses.ANIMATING_CLOSED);
        }

        requestAnimationFrame(function () {
          _this4.adapter_.removeClass(MDCMenuFoundation.cssClasses.OPEN);
          if (!_this4.quickOpen_) {
            _this4.closeAnimationEndTimerId_ = setTimeout(function () {
              _this4.closeAnimationEndTimerId_ = 0;
              _this4.adapter_.removeClass(MDCMenuFoundation.cssClasses.ANIMATING_CLOSED);
            }, numbers$2.TRANSITION_CLOSE_DURATION);
          }
        });
        this.isOpen_ = false;
        this.adapter_.restoreFocus();
      }

      /** @return {boolean} */

    }, {
      key: 'isOpen',
      value: function isOpen() {
        return this.isOpen_;
      }

      /** @return {number} */

    }, {
      key: 'getSelectedIndex',
      value: function getSelectedIndex() {
        return this.selectedIndex_;
      }

      /**
       * @param {number} index Index of the item to set as selected.
       */

    }, {
      key: 'setSelectedIndex',
      value: function setSelectedIndex(index) {
        if (index === this.selectedIndex_) {
          return;
        }

        var prevSelectedIndex = this.selectedIndex_;
        if (prevSelectedIndex >= 0) {
          this.adapter_.rmAttrForOptionAtIndex(prevSelectedIndex, 'aria-selected');
          this.adapter_.rmClassForOptionAtIndex(prevSelectedIndex, cssClasses$a.SELECTED_LIST_ITEM);
        }

        this.selectedIndex_ = index >= 0 && index < this.adapter_.getNumberOfItems() ? index : -1;
        if (this.selectedIndex_ >= 0) {
          this.adapter_.setAttrForOptionAtIndex(this.selectedIndex_, 'aria-selected', 'true');
          this.adapter_.addClassForOptionAtIndex(this.selectedIndex_, cssClasses$a.SELECTED_LIST_ITEM);
        }
      }
    }]);
    return MDCMenuFoundation;
  }(MDCFoundation);

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @type {string|undefined} */
  var storedTransformPropertyName_$1 = void 0;

  /**
   * Returns the name of the correct transform property to use on the current browser.
   * @param {!Window} globalObj
   * @param {boolean=} forceRefresh
   * @return {string}
   */
  function getTransformPropertyName$1(globalObj) {
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (storedTransformPropertyName_$1 === undefined || forceRefresh) {
      var el = globalObj.document.createElement('div');
      var transformPropertyName = 'transform' in el.style ? 'transform' : 'webkitTransform';
      storedTransformPropertyName_$1 = transformPropertyName;
    }

    return storedTransformPropertyName_$1;
  }

  var mdcMenu = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { ref: "root", staticClass: "mdc-menu mdc-simple-menu", class: _vm.classes, style: _vm.styles, attrs: { "tabindex": "-1" } }, [_c('ul', { ref: "items", staticClass: "mdc-simple-menu__items mdc-list", attrs: { "role": "menu", "aria-hidden": "true" } }, [_vm._t("default")], 2)]);
    }, staticRenderFns: [],
    name: 'mdc-menu',
    model: {
      prop: 'open',
      event: 'change'
    },
    props: {
      open: [Boolean, Object],
      'quick-open': Boolean,
      'anchor-corner': [String, Number],
      'anchor-margin': Object
    },
    data: function data() {
      return {
        classes: {},
        styles: {},
        items: []
      };
    },

    watch: {
      open: 'onOpen_',
      quickOpen: function quickOpen(nv) {
        this.foundation.setQuickOpen(nv);
      },
      anchorCorner: function anchorCorner(nv) {
        this.foundation.setAnchorCorner(Number(nv));
      },
      anchorMargin: function anchorMargin(nv) {
        this.foundation.setAnchorMargin(nv);
      }
    },
    mounted: function mounted() {
      var _this = this;

      var refreshItems = function refreshItems() {
        _this.items = [].slice.call(_this.$refs.items.querySelectorAll('.mdc-list-item[role]'));
        _this.$emit('update');
      };
      this.slotObserver = new MutationObserver(function () {
        return refreshItems();
      });
      this.slotObserver.observe(this.$el, {
        childList: true,
        subtree: true
      });

      this._previousFocus = undefined;

      this.foundation = new MDCMenuFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        hasClass: function hasClass(className) {
          return _this.$refs.root.classList.contains(className);
        },
        hasNecessaryDom: function hasNecessaryDom() {
          return Boolean(_this.$refs.items);
        },
        getAttributeForEventTarget: function getAttributeForEventTarget(target, attributeName) {
          return target.getAttribute(attributeName);
        },
        getInnerDimensions: function getInnerDimensions() {
          return {
            width: _this.$refs.items.offsetWidth,
            height: _this.$refs.items.offsetHeight
          };
        },
        hasAnchor: function hasAnchor() {
          return _this.$refs.root.parentElement && _this.$refs.root.parentElement.classList.contains('mdc-menu-anchor');
        },
        getAnchorDimensions: function getAnchorDimensions() {
          return _this.$refs.root.parentElement.getBoundingClientRect();
        },
        getWindowDimensions: function getWindowDimensions() {
          return {
            width: window.innerWidth,
            height: window.innerHeight
          };
        },
        getNumberOfItems: function getNumberOfItems() {
          return _this.items.length;
        },
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          return _this.$refs.root.addEventListener(type, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          return _this.$refs.root.removeEventListener(type, handler);
        },
        registerBodyClickHandler: function registerBodyClickHandler(handler) {
          return document.body.addEventListener('click', handler);
        },
        deregisterBodyClickHandler: function deregisterBodyClickHandler(handler) {
          return document.body.removeEventListener('click', handler);
        },
        getIndexForEventTarget: function getIndexForEventTarget(target) {
          return _this.items.indexOf(target);
        },
        notifySelected: function notifySelected(evtData) {
          var evt = {
            index: evtData.index,
            item: _this.items[evtData.index]
          };
          _this.$emit('change', false);
          _this.$emit('select', evt);
          emitCustomEvent(_this.$el, MDCMenuFoundation.strings.SELECTED_EVENT, evt);
        },
        notifyCancel: function notifyCancel() {
          _this.$emit('change', false);
          _this.$emit('cancel');
          emitCustomEvent(_this.$el, MDCMenuFoundation.strings.CANCEL_EVENT, {});
        },
        saveFocus: function saveFocus() {
          _this._previousFocus = document.activeElement;
        },
        restoreFocus: function restoreFocus() {
          if (_this._previousFocus) {
            _this._previousFocus.focus();
          }
        },
        isFocused: function isFocused() {
          return document.activeElement === _this.$refs.root;
        },
        focus: function focus() {
          return _this.$refs.root.focus();
        },
        getFocusedItemIndex: function getFocusedItemIndex() {
          return _this.items.indexOf(document.activeElement);
        },
        focusItemAtIndex: function focusItemAtIndex(index) {
          return _this.items[index].focus();
        },
        isRtl: function isRtl() {
          return getComputedStyle(_this.$refs.root).getPropertyValue('direction') === 'rtl';
        },
        setTransformOrigin: function setTransformOrigin(origin) {
          _this.$set(_this.styles, getTransformPropertyName$1(window) + '-origin', origin);
        },
        setPosition: function setPosition(position) {
          _this.$set(_this.styles, 'left', position.left);
          _this.$set(_this.styles, 'right', position.right);
          _this.$set(_this.styles, 'top', position.top);
          _this.$set(_this.styles, 'bottom', position.bottom);
        },
        setMaxHeight: function setMaxHeight(height) {
          _this.$set(_this.styles, 'max-height', height);
        },
        setAttrForOptionAtIndex: function setAttrForOptionAtIndex(index, attr, value) {
          _this.items[index].setAttribute(attr, value);
        },
        rmAttrForOptionAtIndex: function rmAttrForOptionAtIndex(index, attr) {
          _this.items[index].removeAttribute(attr);
        },
        addClassForOptionAtIndex: function addClassForOptionAtIndex(index, className) {
          _this.items[index].classList.add(className);
        },
        rmClassForOptionAtIndex: function rmClassForOptionAtIndex(index, className) {
          _this.items[index].classList.remove(className);
        }
      });

      refreshItems();
      this.foundation.init();
      if (this.anchorCorner !== void 0) {
        this.foundation.setAnchorCorner(Number(this.anchorCorner));
      }
      if (this.anchorMargin !== void 0) {
        this.foundation.setAnchorMargin(this.anchorMargin);
      }
    },
    beforeDestroy: function beforeDestroy() {
      this._previousFocus = null;
      this.slotObserver.disconnect();
      this.foundation.destroy();
    },


    methods: {
      onOpen_: function onOpen_(value) {
        if (value) {
          this.foundation.open((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' ? value : void 0);
        } else {
          this.foundation.close();
        }
      },
      show: function show(options) {
        this.foundation.open(options);
      },
      hide: function hide() {
        this.foundation.close();
      },
      isOpen: function isOpen() {
        return this.foundation ? this.foundation.isOpen() : false;
      }
    }
  };

  var mdcMenuItem = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('li', { staticClass: "mdc-menu-item mdc-list-item", attrs: { "tabindex": _vm.disabled ? '-1' : '0', "aria-disabled": _vm.disabled, "role": "menuitem" } }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-menu-item',
    props: {
      disabled: Boolean
    }
  };

  var mdcMenuDivider = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('li', { staticClass: "mdc-menu-divider mdc-list-divider", attrs: { "role": "separator" } });
    }, staticRenderFns: [],
    name: 'mdc-menu-divider'
  };

  var mdcMenuAnchor = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-menu-anchor" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-menu-anchor'
  };

  var VueMDCMenu = BasePlugin({
    mdcMenu: mdcMenu,
    mdcMenuItem: mdcMenuItem,
    mdcMenuDivider: mdcMenuDivider,
    mdcMenuAnchor: mdcMenuAnchor
  });

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Radio. Provides an interface for managing
   * - classes
   * - dom
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */

  var MDCRadioAdapter = function () {
    function MDCRadioAdapter() {
      classCallCheck(this, MDCRadioAdapter);
    }

    createClass(MDCRadioAdapter, [{
      key: 'addClass',

      /** @param {string} className */
      value: function addClass(className) {}

      /** @param {string} className */

    }, {
      key: 'removeClass',
      value: function removeClass(className) {}

      /** @return {!MDCSelectionControlState} */

    }, {
      key: 'getNativeControl',
      value: function getNativeControl() {}
    }]);
    return MDCRadioAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings$c = {
    NATIVE_CONTROL_SELECTOR: '.mdc-radio__native-control'
  };

  /** @enum {string} */
  var cssClasses$b = {
    ROOT: 'mdc-radio',
    DISABLED: 'mdc-radio--disabled'
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCRadioAdapter>}
   */

  var MDCRadioFoundation = function (_MDCFoundation) {
    inherits(MDCRadioFoundation, _MDCFoundation);

    function MDCRadioFoundation() {
      classCallCheck(this, MDCRadioFoundation);
      return possibleConstructorReturn(this, (MDCRadioFoundation.__proto__ || Object.getPrototypeOf(MDCRadioFoundation)).apply(this, arguments));
    }

    createClass(MDCRadioFoundation, [{
      key: 'isChecked',


      /** @return {boolean} */
      value: function isChecked() {
        return this.getNativeControl_().checked;
      }

      /** @param {boolean} checked */

    }, {
      key: 'setChecked',
      value: function setChecked(checked) {
        this.getNativeControl_().checked = checked;
      }

      /** @return {boolean} */

    }, {
      key: 'isDisabled',
      value: function isDisabled() {
        return this.getNativeControl_().disabled;
      }

      /** @param {boolean} disabled */

    }, {
      key: 'setDisabled',
      value: function setDisabled(disabled) {
        var DISABLED = MDCRadioFoundation.cssClasses.DISABLED;

        this.getNativeControl_().disabled = disabled;
        if (disabled) {
          this.adapter_.addClass(DISABLED);
        } else {
          this.adapter_.removeClass(DISABLED);
        }
      }

      /** @return {?string} */

    }, {
      key: 'getValue',
      value: function getValue() {
        return this.getNativeControl_().value;
      }

      /** @param {?string} value */

    }, {
      key: 'setValue',
      value: function setValue(value) {
        this.getNativeControl_().value = value;
      }

      /**
       * @return {!MDCSelectionControlState}
       * @private
       */

    }, {
      key: 'getNativeControl_',
      value: function getNativeControl_() {
        return this.adapter_.getNativeControl() || {
          checked: false,
          disabled: false,
          value: null
        };
      }
    }], [{
      key: 'cssClasses',

      /** @return enum {cssClasses} */
      get: function get$$1() {
        return cssClasses$b;
      }

      /** @return enum {strings} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$c;
      }

      /** @return {!MDCRadioAdapter} */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCRadioAdapter} */{
            addClass: function addClass() /* className: string */{},
            removeClass: function removeClass() /* className: string */{},
            getNativeControl: function getNativeControl() /* !MDCSelectionControlState */{}
          }
        );
      }
    }]);
    return MDCRadioFoundation;
  }(MDCFoundation);

  var mdcRadio = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-radio-wrapper", class: _vm.formFieldClasses }, [_c('div', { ref: "root", staticClass: "mdc-radio", class: _vm.classes, style: _vm.styles }, [_c('input', { ref: "control", staticClass: "mdc-radio__native-control", attrs: { "id": _vm.vma_uid_, "name": _vm.name, "type": "radio" }, on: { "change": _vm.sync } }), _vm._v(" "), _vm._m(0)]), _vm._v(" "), _c('label', { ref: "label", attrs: { "for": _vm.vma_uid_ } }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2)]);
    }, staticRenderFns: [function () {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-radio__background" }, [_c('div', { staticClass: "mdc-radio__outer-circle" }), _vm._v(" "), _c('div', { staticClass: "mdc-radio__inner-circle" })]);
    }],
    name: 'mdc-radio',
    mixins: [DispatchFocusMixin, VMAUniqueIdMixin],
    model: {
      prop: 'picked',
      event: 'change'
    },
    props: {
      name: { type: String, required: true },
      value: String,
      picked: String,
      checked: Boolean,
      label: String,
      'align-end': Boolean,
      disabled: Boolean
    },
    data: function data() {
      return {
        classes: {},
        styles: {},
        formFieldClasses: {
          'mdc-form-field': this.label,
          'mdc-form-field--align-end': this.label && this.alignEnd
        }
      };
    },

    watch: {
      checked: 'setChecked',
      disabled: function disabled(value) {
        this.foundation.setDisabled(value);
      }
    },
    mounted: function mounted() {
      var _this = this;

      // add foundation
      this.foundation = new MDCRadioFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        getNativeControl: function getNativeControl() {
          return _this.$refs.control;
        }
      });

      // add ripple
      this.ripple = new RippleBase(this, {
        isUnbounded: function isUnbounded() {
          return true;
        },
        isSurfaceActive: function isSurfaceActive() {
          return false;
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          _this.$refs.control.addEventListener(evt, handler, applyPassive());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          _this.$refs.control.removeEventListener(evt, handler, applyPassive());
        },
        computeBoundingRect: function computeBoundingRect() {
          return _this.$refs.root.getBoundingClientRect();
        }
      });

      this.formField = new MDCFormFieldFoundation({
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          _this.$refs.label.addEventListener(type, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          _this.$refs.label.removeEventListener(type, handler);
        },
        activateInputRipple: function activateInputRipple() {
          _this.ripple && _this.ripple.activate();
        },
        deactivateInputRipple: function deactivateInputRipple() {
          _this.ripple && _this.ripple.deactivate();
        }
      });

      this.foundation.init();
      this.ripple.init();
      this.formField.init();

      this.foundation.setValue(this.value ? this.value : this.label);
      this.foundation.setDisabled(this.disabled);
      this.foundation.setChecked(this.checked || this.picked == this.foundation.getValue());

      // refresh model
      this.checked && this.sync();
    },
    beforeDestroy: function beforeDestroy() {
      this.formField.destroy();
      this.ripple.destroy();
      this.foundation.destroy();
    },

    methods: {
      setChecked: function setChecked(checked) {
        this.foundation.setChecked(checked);
      },
      isChecked: function isChecked() {
        return this.foundation.isChecked();
      },
      sync: function sync() {
        this.$emit('change', this.foundation.getValue());
      }
    }
  };

  var VueMDCRadio = BasePlugin({
    mdcRadio: mdcRadio
  });

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var cssClasses$c = {
    BOX: 'mdc-select--box',
    DISABLED: 'mdc-select--disabled',
    ROOT: 'mdc-select',
    OUTLINED: 'mdc-select--outlined'
  };

  var strings$d = {
    CHANGE_EVENT: 'MDCSelect:change',
    LINE_RIPPLE_SELECTOR: '.mdc-line-ripple',
    LABEL_SELECTOR: '.mdc-floating-label',
    NATIVE_CONTROL_SELECTOR: '.mdc-select__native-control',
    OUTLINE_SELECTOR: '.mdc-notched-outline'
  };

  /** @enum {number} */
  var numbers$3 = {
    LABEL_SCALE: 0.75
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCSelectFoundation = function (_MDCFoundation) {
    inherits(MDCSelectFoundation, _MDCFoundation);
    createClass(MDCSelectFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$c;
      }
    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers$3;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$d;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          hasClass: function hasClass() {
            return (/* className: string */false
            );
          },
          floatLabel: function floatLabel() /* value: boolean */{},
          activateBottomLine: function activateBottomLine() {},
          deactivateBottomLine: function deactivateBottomLine() {},
          registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
          getSelectedIndex: function getSelectedIndex() {
            return (/* number */-1
            );
          },
          setSelectedIndex: function setSelectedIndex() /* index: number */{},
          setDisabled: function setDisabled() /* disabled: boolean */{},
          getValue: function getValue() {
            return (/* string */''
            );
          },
          setValue: function setValue() /* value: string */{},
          isRtl: function isRtl() {
            return false;
          },
          hasLabel: function hasLabel() {},
          getLabelWidth: function getLabelWidth() {},
          hasOutline: function hasOutline() {},
          notchOutline: function notchOutline() {},
          closeOutline: function closeOutline() {}
        };
      }
    }]);

    function MDCSelectFoundation(adapter) {
      classCallCheck(this, MDCSelectFoundation);

      var _this = possibleConstructorReturn(this, (MDCSelectFoundation.__proto__ || Object.getPrototypeOf(MDCSelectFoundation)).call(this, _extends(MDCSelectFoundation.defaultAdapter, adapter)));

      _this.focusHandler_ = function (evt) {
        return _this.handleFocus_(evt);
      };
      _this.blurHandler_ = function (evt) {
        return _this.handleBlur_(evt);
      };
      _this.selectionHandler_ = function (evt) {
        return _this.handleSelect_(evt);
      };
      return _this;
    }

    createClass(MDCSelectFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
        this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
        this.adapter_.registerInteractionHandler('change', this.selectionHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
        this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);
        this.adapter_.deregisterInteractionHandler('change', this.selectionHandler_);
      }
    }, {
      key: 'setSelectedIndex',
      value: function setSelectedIndex(index) {
        this.adapter_.setSelectedIndex(index);
        this.floatLabelWithValue_();
      }
    }, {
      key: 'setValue',
      value: function setValue(value) {
        this.adapter_.setValue(value);
        this.setSelectedIndex(this.adapter_.getSelectedIndex());
      }
    }, {
      key: 'setDisabled',
      value: function setDisabled(disabled) {
        var DISABLED = MDCSelectFoundation.cssClasses.DISABLED;

        this.adapter_.setDisabled(disabled);
        if (disabled) {
          this.adapter_.addClass(DISABLED);
        } else {
          this.adapter_.removeClass(DISABLED);
        }
      }
    }, {
      key: 'floatLabelWithValue_',
      value: function floatLabelWithValue_() {
        var optionHasValue = this.adapter_.getValue().length > 0;
        this.adapter_.floatLabel(optionHasValue);
        this.notchOutline(optionHasValue);
      }
    }, {
      key: 'handleFocus_',
      value: function handleFocus_() {
        this.adapter_.floatLabel(true);
        this.notchOutline(true);
        this.adapter_.activateBottomLine();
      }
    }, {
      key: 'handleBlur_',
      value: function handleBlur_() {
        this.floatLabelWithValue_();
        this.adapter_.deactivateBottomLine();
      }
    }, {
      key: 'handleSelect_',
      value: function handleSelect_() {
        this.setSelectedIndex(this.adapter_.getSelectedIndex());
      }

      /**
       * Opens/closes the notched outline.
       * @param {boolean} openNotch
       */

    }, {
      key: 'notchOutline',
      value: function notchOutline(openNotch) {
        if (!this.adapter_.hasOutline() || !this.adapter_.hasLabel()) {
          return;
        }

        if (openNotch) {
          var labelScale = numbers$3.LABEL_SCALE;
          var labelWidth = this.adapter_.getLabelWidth() * labelScale;
          var isRtl = this.adapter_.isRtl();
          this.adapter_.notchOutline(labelWidth, isRtl);
        } else {
          this.adapter_.closeOutline();
        }
      }
    }]);
    return MDCSelectFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Floating Label.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the floating label into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCFloatingLabelAdapter = function () {
    function MDCFloatingLabelAdapter() {
      classCallCheck(this, MDCFloatingLabelAdapter);
    }

    createClass(MDCFloatingLabelAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the label element.
       * @param {string} className
       */
      value: function addClass(className) {}

      /**
       * Removes a class from the label element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * Returns the width of the label element.
       * @return {number}
       */

    }, {
      key: "getWidth",
      value: function getWidth() {}

      /**
       * Registers an event listener on the root element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(evtType, handler) {}

      /**
       * Deregisters an event listener on the root element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(evtType, handler) {}
    }]);
    return MDCFloatingLabelAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses$d = {
    LABEL_FLOAT_ABOVE: 'mdc-floating-label--float-above',
    LABEL_SHAKE: 'mdc-floating-label--shake'
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCFloatingLabelAdapter>}
   * @final
   */

  var MDCFloatingLabelFoundation = function (_MDCFoundation) {
    inherits(MDCFloatingLabelFoundation, _MDCFoundation);
    createClass(MDCFloatingLabelFoundation, null, [{
      key: 'cssClasses',

      /** @return enum {string} */
      get: function get$$1() {
        return cssClasses$d;
      }

      /**
       * {@see MDCFloatingLabelAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCFloatingLabelAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCFloatingLabelAdapter} */{
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            getWidth: function getWidth() {},
            registerInteractionHandler: function registerInteractionHandler() {},
            deregisterInteractionHandler: function deregisterInteractionHandler() {}
          }
        );
      }

      /**
       * @param {!MDCFloatingLabelAdapter} adapter
       */

    }]);

    function MDCFloatingLabelFoundation(adapter) {
      classCallCheck(this, MDCFloatingLabelFoundation);

      /** @private {function(!Event): undefined} */
      var _this = possibleConstructorReturn(this, (MDCFloatingLabelFoundation.__proto__ || Object.getPrototypeOf(MDCFloatingLabelFoundation)).call(this, _extends(MDCFloatingLabelFoundation.defaultAdapter, adapter)));

      _this.shakeAnimationEndHandler_ = function () {
        return _this.handleShakeAnimationEnd_();
      };
      return _this;
    }

    createClass(MDCFloatingLabelFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.registerInteractionHandler('animationend', this.shakeAnimationEndHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterInteractionHandler('animationend', this.shakeAnimationEndHandler_);
      }

      /**
       * Returns the width of the label element.
       * @return {number}
       */

    }, {
      key: 'getWidth',
      value: function getWidth() {
        return this.adapter_.getWidth();
      }

      /**
       * Styles the label to produce the label shake for errors.
       * @param {boolean} shouldShake adds shake class if true,
       * otherwise removes shake class.
       */

    }, {
      key: 'shake',
      value: function shake(shouldShake) {
        var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;

        if (shouldShake) {
          this.adapter_.addClass(LABEL_SHAKE);
        } else {
          this.adapter_.removeClass(LABEL_SHAKE);
        }
      }

      /**
       * Styles the label to float or dock.
       * @param {boolean} shouldFloat adds float class if true, otherwise remove
       * float and shake class to dock label.
       */

    }, {
      key: 'float',
      value: function float(shouldFloat) {
        var _MDCFloatingLabelFoun = MDCFloatingLabelFoundation.cssClasses,
            LABEL_FLOAT_ABOVE = _MDCFloatingLabelFoun.LABEL_FLOAT_ABOVE,
            LABEL_SHAKE = _MDCFloatingLabelFoun.LABEL_SHAKE;

        if (shouldFloat) {
          this.adapter_.addClass(LABEL_FLOAT_ABOVE);
        } else {
          this.adapter_.removeClass(LABEL_FLOAT_ABOVE);
          this.adapter_.removeClass(LABEL_SHAKE);
        }
      }

      /**
       * Handles an interaction event on the root element.
       */

    }, {
      key: 'handleShakeAnimationEnd_',
      value: function handleShakeAnimationEnd_() {
        var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;

        this.adapter_.removeClass(LABEL_SHAKE);
      }
    }]);
    return MDCFloatingLabelFoundation;
  }(MDCFoundation);

  var SelectLabel = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('label', { staticClass: "mdc-floating-label", class: _vm.labelClasses }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-select-label',
    data: function data() {
      return {
        labelClasses: {}
      };
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCFloatingLabelFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.labelClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.labelClasses, className);
        },
        getWidth: function getWidth() {
          return _this.$el.offsetWidth;
        },
        registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
          _this.$el.addEventListener(evtType, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
          _this.$el.removeEventListener(evtType, handler);
        }
      });
      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      var foundation = this.foundation;
      this.foundation = null;
      foundation.destroy();
    }
  };

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC TextField Line Ripple.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the line ripple into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCLineRippleAdapter = function () {
    function MDCLineRippleAdapter() {
      classCallCheck(this, MDCLineRippleAdapter);
    }

    createClass(MDCLineRippleAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the line ripple element.
       * @param {string} className
       */
      value: function addClass(className) {}

      /**
       * Removes a class from the line ripple element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}

      /**
       * Sets the style property with propertyName to value on the root element.
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setStyle",
      value: function setStyle(propertyName, value) {}

      /**
       * Registers an event listener on the line ripple element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerEventHandler",
      value: function registerEventHandler(evtType, handler) {}

      /**
       * Deregisters an event listener on the line ripple element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterEventHandler",
      value: function deregisterEventHandler(evtType, handler) {}
    }]);
    return MDCLineRippleAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses$e = {
    LINE_RIPPLE_ACTIVE: 'mdc-line-ripple--active',
    LINE_RIPPLE_DEACTIVATING: 'mdc-line-ripple--deactivating'
  };

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCLineRippleAdapter>}
   * @final
   */

  var MDCLineRippleFoundation = function (_MDCFoundation) {
    inherits(MDCLineRippleFoundation, _MDCFoundation);
    createClass(MDCLineRippleFoundation, null, [{
      key: 'cssClasses',

      /** @return enum {string} */
      get: function get$$1() {
        return cssClasses$e;
      }

      /**
       * {@see MDCLineRippleAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCLineRippleAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCLineRippleAdapter} */{
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {},
            setStyle: function setStyle() {},
            registerEventHandler: function registerEventHandler() {},
            deregisterEventHandler: function deregisterEventHandler() {}
          }
        );
      }

      /**
       * @param {!MDCLineRippleAdapter=} adapter
       */

    }]);

    function MDCLineRippleFoundation() {
      var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : /** @type {!MDCLineRippleAdapter} */{};
      classCallCheck(this, MDCLineRippleFoundation);

      /** @private {function(!Event): undefined} */
      var _this = possibleConstructorReturn(this, (MDCLineRippleFoundation.__proto__ || Object.getPrototypeOf(MDCLineRippleFoundation)).call(this, _extends(MDCLineRippleFoundation.defaultAdapter, adapter)));

      _this.transitionEndHandler_ = function (evt) {
        return _this.handleTransitionEnd(evt);
      };
      return _this;
    }

    createClass(MDCLineRippleFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.registerEventHandler('transitionend', this.transitionEndHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterEventHandler('transitionend', this.transitionEndHandler_);
      }

      /**
       * Activates the line ripple
       */

    }, {
      key: 'activate',
      value: function activate() {
        this.adapter_.removeClass(cssClasses$e.LINE_RIPPLE_DEACTIVATING);
        this.adapter_.addClass(cssClasses$e.LINE_RIPPLE_ACTIVE);
      }

      /**
       * Sets the center of the ripple animation to the given X coordinate.
       * @param {number} xCoordinate
       */

    }, {
      key: 'setRippleCenter',
      value: function setRippleCenter(xCoordinate) {
        this.adapter_.setStyle('transform-origin', xCoordinate + 'px center');
      }

      /**
       * Deactivates the line ripple
       */

    }, {
      key: 'deactivate',
      value: function deactivate() {
        this.adapter_.addClass(cssClasses$e.LINE_RIPPLE_DEACTIVATING);
      }

      /**
       * Handles a transition end event
       * @param {!Event} evt
       */

    }, {
      key: 'handleTransitionEnd',
      value: function handleTransitionEnd(evt) {
        // Wait for the line ripple to be either transparent or opaque
        // before emitting the animation end event
        var isDeactivating = this.adapter_.hasClass(cssClasses$e.LINE_RIPPLE_DEACTIVATING);

        if (evt.propertyName === 'opacity') {
          if (isDeactivating) {
            this.adapter_.removeClass(cssClasses$e.LINE_RIPPLE_ACTIVE);
            this.adapter_.removeClass(cssClasses$e.LINE_RIPPLE_DEACTIVATING);
          }
        }
      }
    }]);
    return MDCLineRippleFoundation;
  }(MDCFoundation);

  var SelectLineRiple = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-line-ripple", class: _vm.lineClasses, style: _vm.lineStyles });
    }, staticRenderFns: [],
    name: 'mdc-select-line-ripple',
    data: function data() {
      return {
        lineClasses: {},
        lineStyles: {}
      };
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCLineRippleFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.lineClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.lineClasses, className);
        },
        hasClass: function hasClass(className) {
          _this.$el.classList.contains(className);
        },
        setStyle: function setStyle(name, value) {
          _this.$set(_this.lineStyles, name, value);
        },
        registerEventHandler: function registerEventHandler(evtType, handler) {
          _this.$el.addEventListener(evtType, handler);
        },
        deregisterEventHandler: function deregisterEventHandler(evtType, handler) {
          _this.$el.removeEventListener(evtType, handler);
        }
      });
      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      var foundation = this.foundation;
      this.foundation = null;
      foundation.destroy();
    }
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Notched Outline.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Notched Outline into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCNotchedOutlineAdapter = function () {
    function MDCNotchedOutlineAdapter() {
      classCallCheck(this, MDCNotchedOutlineAdapter);
    }

    createClass(MDCNotchedOutlineAdapter, [{
      key: "getWidth",

      /**
       * Returns the width of the root element.
       * @return {number}
       */
      value: function getWidth() {}

      /**
       * Returns the height of the root element.
       * @return {number}
       */

    }, {
      key: "getHeight",
      value: function getHeight() {}

      /**
       * Adds a class to the root element.
       * @param {string} className
       */

    }, {
      key: "addClass",
      value: function addClass(className) {}

      /**
       * Removes a class from the root element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * Sets the "d" attribute of the outline element's SVG path.
       * @param {string} value
       */

    }, {
      key: "setOutlinePathAttr",
      value: function setOutlinePathAttr(value) {}

      /**
       * Returns the idle outline element's computed style value of the given css property `propertyName`.
       * We achieve this via `getComputedStyle(...).getPropertyValue(propertyName)`.
       * @param {string} propertyName
       * @return {string}
       */

    }, {
      key: "getIdleOutlineStyleValue",
      value: function getIdleOutlineStyleValue(propertyName) {}
    }]);
    return MDCNotchedOutlineAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings$e = {
    PATH_SELECTOR: '.mdc-notched-outline__path',
    IDLE_OUTLINE_SELECTOR: '.mdc-notched-outline__idle'
  };

  /** @enum {string} */
  var cssClasses$f = {
    OUTLINE_NOTCHED: 'mdc-notched-outline--notched'
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCNotchedOutlineAdapter>}
   * @final
   */

  var MDCNotchedOutlineFoundation = function (_MDCFoundation) {
    inherits(MDCNotchedOutlineFoundation, _MDCFoundation);
    createClass(MDCNotchedOutlineFoundation, null, [{
      key: 'strings',

      /** @return enum {string} */
      get: function get$$1() {
        return strings$e;
      }

      /** @return enum {string} */

    }, {
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$f;
      }

      /**
       * {@see MDCNotchedOutlineAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCNotchedOutlineAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCNotchedOutlineAdapter} */{
            getWidth: function getWidth() {},
            getHeight: function getHeight() {},
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            setOutlinePathAttr: function setOutlinePathAttr() {},
            getIdleOutlineStyleValue: function getIdleOutlineStyleValue() {}
          }
        );
      }

      /**
       * @param {!MDCNotchedOutlineAdapter} adapter
       */

    }]);

    function MDCNotchedOutlineFoundation(adapter) {
      classCallCheck(this, MDCNotchedOutlineFoundation);
      return possibleConstructorReturn(this, (MDCNotchedOutlineFoundation.__proto__ || Object.getPrototypeOf(MDCNotchedOutlineFoundation)).call(this, _extends(MDCNotchedOutlineFoundation.defaultAdapter, adapter)));
    }

    /**
     * Adds the outline notched selector and updates the notch width
     * calculated based off of notchWidth and isRtl.
     * @param {number} notchWidth
     * @param {boolean=} isRtl
     */


    createClass(MDCNotchedOutlineFoundation, [{
      key: 'notch',
      value: function notch(notchWidth) {
        var isRtl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;

        this.adapter_.addClass(OUTLINE_NOTCHED);
        this.updateSvgPath_(notchWidth, isRtl);
      }

      /**
       * Removes notched outline selector to close the notch in the outline.
       */

    }, {
      key: 'closeNotch',
      value: function closeNotch() {
        var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;

        this.adapter_.removeClass(OUTLINE_NOTCHED);
      }

      /**
       * Updates the SVG path of the focus outline element based on the notchWidth
       * and the RTL context.
       * @param {number} notchWidth
       * @param {boolean=} isRtl
       * @private
       */

    }, {
      key: 'updateSvgPath_',
      value: function updateSvgPath_(notchWidth, isRtl) {
        // Fall back to reading a specific corner's style because Firefox doesn't report the style on border-radius.
        var radiusStyleValue = this.adapter_.getIdleOutlineStyleValue('border-radius') || this.adapter_.getIdleOutlineStyleValue('border-top-left-radius');
        var radius = parseFloat(radiusStyleValue);
        var width = this.adapter_.getWidth();
        var height = this.adapter_.getHeight();
        var cornerWidth = radius + 1.2;
        var leadingStrokeLength = Math.abs(11 - cornerWidth);
        var paddedNotchWidth = notchWidth + 8;

        // The right, bottom, and left sides of the outline follow the same SVG path.
        var pathMiddle = 'a' + radius + ',' + radius + ' 0 0 1 ' + radius + ',' + radius + 'v' + (height - 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + -radius + ',' + radius + 'h' + (-width + 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + -radius + ',' + -radius + 'v' + (-height + 2 * cornerWidth) + 'a' + radius + ',' + radius + ' 0 0 1 ' + radius + ',' + -radius;

        var path = void 0;
        if (!isRtl) {
          path = 'M' + (cornerWidth + leadingStrokeLength + paddedNotchWidth) + ',' + 1 + 'h' + (width - 2 * cornerWidth - paddedNotchWidth - leadingStrokeLength) + pathMiddle + 'h' + leadingStrokeLength;
        } else {
          path = 'M' + (width - cornerWidth - leadingStrokeLength) + ',' + 1 + 'h' + leadingStrokeLength + pathMiddle + 'h' + (width - 2 * cornerWidth - paddedNotchWidth - leadingStrokeLength);
        }

        this.adapter_.setOutlinePathAttr(path);
      }
    }]);
    return MDCNotchedOutlineFoundation;
  }(MDCFoundation);

  var SelectNotchedOutline = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', [_c('div', { ref: "outlined", staticClass: "mdc-notched-outline", class: _vm.outlinedClasses }, [_c('svg', [_c('path', { ref: "outlinedPath", staticClass: "mdc-notched-outline__path" })])]), _vm._v(" "), _c('div', { ref: "outlinedIdle", staticClass: "mdc-notched-outline__idle" })]);
    }, staticRenderFns: [],
    name: 'mdc-select-notched-outline',
    data: function data() {
      return {
        outlinedClasses: {}
      };
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCNotchedOutlineFoundation({
        getWidth: function getWidth() {
          return _this.$refs.outlined.offsetWidth;
        },
        getHeight: function getHeight() {
          return _this.$refs.outlined.offsetHeight;
        },
        addClass: function addClass(className) {
          _this.$set(_this.outlinedClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.outlinedClasses, className);
        },
        setOutlinePathAttr: function setOutlinePathAttr(value) {
          var path = _this.$refs.outlinedPath;
          path.setAttribute('d', value);
        },
        getIdleOutlineStyleValue: function getIdleOutlineStyleValue(propertyName) {
          return window.getComputedStyle(_this.$refs.outlinedIdle).getPropertyValue(propertyName);
        }
      });
      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      var foundation = this.foundation;
      this.foundation = null;
      foundation.destroy();
    }
  };

  var mdcSelect = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-select", class: _vm.rootClasses, style: _vm.styles, attrs: { "id": _vm.id } }, [_c('select', _vm._g(_vm._b({ ref: "native_control", staticClass: "mdc-select__native-control" }, 'select', _vm.$attrs, false), _vm.listeners), [!!_vm.label ? _c('option', { staticClass: "mdc-option", attrs: { "value": "", "disabled": "disabled", "selected": "selected" } }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2), _vm._v(" "), _vm.label ? _c('select-label', { ref: "label" }, [_vm._v(_vm._s(_vm.label))]) : _vm._e(), _vm._v(" "), !_vm.outlined ? _c('select-line-riple', { ref: "line" }) : _vm._e(), _vm._v(" "), _vm.outlined ? _c('select-notched-outline', { ref: "outline" }) : _vm._e()], 1);
    }, staticRenderFns: [],
    name: 'mdc-select',
    components: {
      SelectLabel: SelectLabel,
      SelectLineRiple: SelectLineRiple,
      SelectNotchedOutline: SelectNotchedOutline
    },
    inheritAttrs: false,
    model: {
      prop: 'value',
      event: 'change'
    },
    props: {
      value: String,
      disabled: Boolean,
      label: String,
      box: Boolean,
      outlined: Boolean,
      id: { type: String }
    },
    data: function data() {
      return {
        styles: {},
        classes: {}
      };
    },

    computed: {
      rootClasses: function rootClasses() {
        return _extends({
          'mdc-select--box': this.box,
          'mdc-select--outlined': this.outlined
        }, this.classes);
      },
      listeners: function listeners() {
        var _this = this;

        return _extends({}, this.$listeners, {
          change: function change(event) {
            return _this.$emit('change', event.target.value);
          }
        });
      }
    },
    watch: {
      disabled: function disabled(value) {
        this.foundation && this.foundation.setDisabled(value);
      },

      value: 'refreshIndex'
    },
    mounted: function mounted() {
      var _this2 = this;

      this.foundation = new MDCSelectFoundation({
        addClass: function addClass(className) {
          return _this2.$set(_this2.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this2.$delete(_this2.classes, className);
        },
        hasClass: function hasClass(className) {
          return _this2.$el.classList.contains(className);
        },
        activateBottomLine: function activateBottomLine() {
          if (_this2.$refs.line) {
            _this2.$refs.line.foundation.activate();
          }
        },
        deactivateBottomLine: function deactivateBottomLine() {
          if (_this2.$refs.line) {
            _this2.$refs.line.foundation.deactivate();
          }
        },
        setDisabled: function setDisabled(disabled) {
          return _this2.$refs.native_control.disabled = disabled;
        },
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          return _this2.$refs.native_control.addEventListener(type, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          return _this2.$refs.native_control.removeEventListener(type, handler);
        },
        getSelectedIndex: function getSelectedIndex() {
          return _this2.$refs.native_control.selectedIndex;
        },
        setSelectedIndex: function setSelectedIndex(index) {
          return _this2.$refs.native_control.selectedIndex = index;
        },
        getValue: function getValue() {
          return _this2.$refs.native_control.value;
        },
        setValue: function setValue(value) {
          return _this2.$refs.native_control.value = value;
        },
        isRtl: function isRtl() {
          return window.getComputedStyle(_this2.$el).getPropertyValue('direction') === 'rtl';
        },
        notchOutline: function notchOutline(labelWidth, isRtl) {
          if (_this2.$refs.outline) {
            _this2.$refs.outline.foundation.notch(labelWidth, isRtl);
          }
        },
        closeOutline: function closeOutline() {
          if (_this2.$refs.outline) {
            _this2.$refs.outline.foundation.closeNotch();
          }
        },
        hasOutline: function hasOutline() {
          return !!_this2.$refs.outline;
        },
        floatLabel: function floatLabel(value) {
          if (_this2.$refs.label) {
            _this2.$refs.label.foundation.float(value);
          }
        },
        hasLabel: function hasLabel() {
          return !!_this2.$refs.label;
        },
        getLabelWidth: function getLabelWidth() {
          if (_this2.$refs.label) {
            return _this2.$refs.label.foundation.getWidth();
          }
        }
      });

      this.foundation.init();

      this.foundation.setDisabled(this.disabled);

      // initial sync with DOM
      this.refreshIndex();
      this.slotObserver = new MutationObserver(function () {
        return _this2.refreshIndex();
      });
      this.slotObserver.observe(this.$refs.native_control, {
        childList: true,
        subtree: true
      });

      this.ripple = new RippleBase(this);
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.slotObserver.disconnect();

      var foundation = this.foundation;
      this.foundation = null;
      foundation.destroy();

      this.ripple && this.ripple.destroy();
    },

    methods: {
      refreshIndex: function refreshIndex() {
        var _this3 = this;

        var options = [].concat(toConsumableArray(this.$refs.native_control.querySelectorAll('option')));

        var idx = options.findIndex(function (_ref) {
          var value = _ref.value;

          return _this3.value === value;
        });

        if (this.$refs.native_control.selectedIndex !== idx) {
          this.foundation.setSelectedIndex(idx);
        }
      }
    }
  };

  var VueMDCSelect = BasePlugin({
    mdcSelect: mdcSelect
  });

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses$g = {
    ACTIVE: 'mdc-slider--active',
    DISABLED: 'mdc-slider--disabled',
    DISCRETE: 'mdc-slider--discrete',
    FOCUS: 'mdc-slider--focus',
    IN_TRANSIT: 'mdc-slider--in-transit',
    IS_DISCRETE: 'mdc-slider--discrete',
    HAS_TRACK_MARKER: 'mdc-slider--display-markers'
  };

  /** @enum {string} */
  var strings$f = {
    TRACK_SELECTOR: '.mdc-slider__track',
    TRACK_MARKER_CONTAINER_SELECTOR: '.mdc-slider__track-marker-container',
    LAST_TRACK_MARKER_SELECTOR: '.mdc-slider__track-marker:last-child',
    THUMB_CONTAINER_SELECTOR: '.mdc-slider__thumb-container',
    PIN_VALUE_MARKER_SELECTOR: '.mdc-slider__pin-value-marker',
    ARIA_VALUEMIN: 'aria-valuemin',
    ARIA_VALUEMAX: 'aria-valuemax',
    ARIA_VALUENOW: 'aria-valuenow',
    ARIA_DISABLED: 'aria-disabled',
    STEP_DATA_ATTR: 'data-step',
    CHANGE_EVENT: 'MDCSlider:change',
    INPUT_EVENT: 'MDCSlider:input'
  };

  /** @enum {number} */
  var numbers$4 = {
    PAGE_FACTOR: 4
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint-disable no-unused-vars */

  /**
   * Adapter for MDC Slider.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Slider into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCSliderAdapter = function () {
    function MDCSliderAdapter() {
      classCallCheck(this, MDCSliderAdapter);
    }

    createClass(MDCSliderAdapter, [{
      key: "hasClass",

      /**
       * Returns true if className exists for the slider Element
       * @param {string} className
       * @return {boolean}
       */
      value: function hasClass(className) {}

      /**
       * Adds a class to the slider Element
       * @param {string} className
       */

    }, {
      key: "addClass",
      value: function addClass(className) {}

      /**
       * Removes a class from the slider Element
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * Returns a string if attribute name exists on the slider Element,
       * otherwise returns null
       * @param {string} name
       * @return {?string}
       */

    }, {
      key: "getAttribute",
      value: function getAttribute(name) {}

      /**
       * Sets attribute name on slider Element to value
       * @param {string} name
       * @param {string} value
       */

    }, {
      key: "setAttribute",
      value: function setAttribute(name, value) {}

      /**
       * Removes attribute name from slider Element
       * @param {string} name
       */

    }, {
      key: "removeAttribute",
      value: function removeAttribute(name) {}

      /**
       * Returns the bounding client rect for the slider Element
       * @return {?ClientRect}
       */

    }, {
      key: "computeBoundingRect",
      value: function computeBoundingRect() {}

      /**
       * Returns the tab index of the slider Element
       * @return {number}
       */

    }, {
      key: "getTabIndex",
      value: function getTabIndex() {}

      /**
       * Registers an event handler on the root element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(type, handler) {}

      /**
       * Deregisters an event handler on the root element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(type, handler) {}

      /**
       * Registers an event handler on the thumb container element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerThumbContainerInteractionHandler",
      value: function registerThumbContainerInteractionHandler(type, handler) {}

      /**
       * Deregisters an event handler on the thumb container element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterThumbContainerInteractionHandler",
      value: function deregisterThumbContainerInteractionHandler(type, handler) {}

      /**
       * Registers an event handler on the body for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerBodyInteractionHandler",
      value: function registerBodyInteractionHandler(type, handler) {}

      /**
       * Deregisters an event handler on the body for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterBodyInteractionHandler",
      value: function deregisterBodyInteractionHandler(type, handler) {}

      /**
       * Registers an event handler for the window resize event
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerResizeHandler",
      value: function registerResizeHandler(handler) {}

      /**
       * Deregisters an event handler for the window resize event
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterResizeHandler",
      value: function deregisterResizeHandler(handler) {}

      /**
       * Emits a custom event MDCSlider:input from the root
       */

    }, {
      key: "notifyInput",
      value: function notifyInput() {}

      /**
       * Emits a custom event MDCSlider:change from the root
       */

    }, {
      key: "notifyChange",
      value: function notifyChange() {}

      /**
       * Sets a style property of the thumb container element to the passed value
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setThumbContainerStyleProperty",
      value: function setThumbContainerStyleProperty(propertyName, value) {}

      /**
       * Sets a style property of the track element to the passed value
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setTrackStyleProperty",
      value: function setTrackStyleProperty(propertyName, value) {}

      /**
       * Sets the inner text of the pin marker to the passed value
       * @param {number} value
       */

    }, {
      key: "setMarkerValue",
      value: function setMarkerValue(value) {}

      /**
       * Appends the passed number of track markers to the track mark container element
       * @param {number} numMarkers
       */

    }, {
      key: "appendTrackMarkers",
      value: function appendTrackMarkers(numMarkers) {}

      /**
       * Removes all track markers fromt he track mark container element
       */

    }, {
      key: "removeTrackMarkers",
      value: function removeTrackMarkers() {}

      /**
       * Sets a style property of the last track marker to the passed value
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setLastTrackMarkersStyleProperty",
      value: function setLastTrackMarkersStyleProperty(propertyName, value) {}

      /**
       * Returns true if the root element is RTL, otherwise false
       * @return {boolean}
       */

    }, {
      key: "isRTL",
      value: function isRTL() {}
    }]);
    return MDCSliderAdapter;
  }();

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   *you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var KEY_IDS = {
    ARROW_LEFT: 'ArrowLeft',
    ARROW_RIGHT: 'ArrowRight',
    ARROW_UP: 'ArrowUp',
    ARROW_DOWN: 'ArrowDown',
    HOME: 'Home',
    END: 'End',
    PAGE_UP: 'PageUp',
    PAGE_DOWN: 'PageDown'
  };

  /** @enum {string} */
  var MOVE_EVENT_MAP = {
    'mousedown': 'mousemove',
    'touchstart': 'touchmove',
    'pointerdown': 'pointermove'
  };

  var DOWN_EVENTS = ['mousedown', 'pointerdown', 'touchstart'];
  var UP_EVENTS = ['mouseup', 'pointerup', 'touchend'];

  /**
   * @extends {MDCFoundation<!MDCSliderAdapter>}
   */

  var MDCSliderFoundation = function (_MDCFoundation) {
    inherits(MDCSliderFoundation, _MDCFoundation);
    createClass(MDCSliderFoundation, null, [{
      key: 'cssClasses',

      /** @return enum {cssClasses} */
      get: function get$$1() {
        return cssClasses$g;
      }

      /** @return enum {strings} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$f;
      }

      /** @return enum {numbers} */

    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers$4;
      }

      /** @return {!MDCSliderAdapter} */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCSliderAdapter} */{
            hasClass: function hasClass() {
              return (/* className: string */ /* boolean */false
              );
            },
            addClass: function addClass() /* className: string */{},
            removeClass: function removeClass() /* className: string */{},
            getAttribute: function getAttribute() {
              return (/* name: string */ /* string|null */null
              );
            },
            setAttribute: function setAttribute() /* name: string, value: string */{},
            removeAttribute: function removeAttribute() /* name: string */{},
            computeBoundingRect: function computeBoundingRect() {
              return (/* ClientRect */{
                  top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0
                }
              );
            },
            getTabIndex: function getTabIndex() {
              return (/* number */0
              );
            },
            registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
            deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
            registerThumbContainerInteractionHandler: function registerThumbContainerInteractionHandler() /* type: string, handler: EventListener */{},
            deregisterThumbContainerInteractionHandler: function deregisterThumbContainerInteractionHandler() /* type: string, handler: EventListener */{},
            registerBodyInteractionHandler: function registerBodyInteractionHandler() /* type: string, handler: EventListener */{},
            deregisterBodyInteractionHandler: function deregisterBodyInteractionHandler() /* type: string, handler: EventListener */{},
            registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
            deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
            notifyInput: function notifyInput() {},
            notifyChange: function notifyChange() {},
            setThumbContainerStyleProperty: function setThumbContainerStyleProperty() /* propertyName: string, value: string */{},
            setTrackStyleProperty: function setTrackStyleProperty() /* propertyName: string, value: string */{},
            setMarkerValue: function setMarkerValue() /* value: number */{},
            appendTrackMarkers: function appendTrackMarkers() /* numMarkers: number */{},
            removeTrackMarkers: function removeTrackMarkers() {},
            setLastTrackMarkersStyleProperty: function setLastTrackMarkersStyleProperty() /* propertyName: string, value: string */{},
            isRTL: function isRTL() {
              return (/* boolean */false
              );
            }
          }
        );
      }

      /**
       * Creates a new instance of MDCSliderFoundation
       * @param {?MDCSliderAdapter} adapter
       */

    }]);

    function MDCSliderFoundation(adapter) {
      classCallCheck(this, MDCSliderFoundation);

      /** @private {?ClientRect} */
      var _this = possibleConstructorReturn(this, (MDCSliderFoundation.__proto__ || Object.getPrototypeOf(MDCSliderFoundation)).call(this, _extends(MDCSliderFoundation.defaultAdapter, adapter)));

      _this.rect_ = null;
      // We set this to NaN since we want it to be a number, but we can't use '0' or '-1'
      // because those could be valid tabindices set by the client code.
      _this.savedTabIndex_ = NaN;
      _this.active_ = false;
      _this.inTransit_ = false;
      _this.isDiscrete_ = false;
      _this.hasTrackMarker_ = false;
      _this.handlingThumbTargetEvt_ = false;
      _this.min_ = 0;
      _this.max_ = 100;
      _this.step_ = 0;
      _this.value_ = 0;
      _this.disabled_ = false;
      _this.preventFocusState_ = false;
      _this.updateUIFrame_ = 0;
      _this.thumbContainerPointerHandler_ = function () {
        _this.handlingThumbTargetEvt_ = true;
      };
      _this.interactionStartHandler_ = function (evt) {
        return _this.handleDown_(evt);
      };
      _this.keydownHandler_ = function (evt) {
        return _this.handleKeydown_(evt);
      };
      _this.focusHandler_ = function () {
        return _this.handleFocus_();
      };
      _this.blurHandler_ = function () {
        return _this.handleBlur_();
      };
      _this.resizeHandler_ = function () {
        return _this.layout();
      };
      return _this;
    }

    createClass(MDCSliderFoundation, [{
      key: 'init',
      value: function init() {
        var _this2 = this;

        this.isDiscrete_ = this.adapter_.hasClass(cssClasses$g.IS_DISCRETE);
        this.hasTrackMarker_ = this.adapter_.hasClass(cssClasses$g.HAS_TRACK_MARKER);
        DOWN_EVENTS.forEach(function (evtName) {
          return _this2.adapter_.registerInteractionHandler(evtName, _this2.interactionStartHandler_);
        });
        this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
        this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
        DOWN_EVENTS.forEach(function (evtName) {
          _this2.adapter_.registerThumbContainerInteractionHandler(evtName, _this2.thumbContainerPointerHandler_);
        });
        this.adapter_.registerResizeHandler(this.resizeHandler_);
        this.layout();
        // At last step, provide a reasonable default value to discrete slider
        if (this.isDiscrete_ && this.getStep() == 0) {
          this.step_ = 1;
        }
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this3 = this;

        DOWN_EVENTS.forEach(function (evtName) {
          _this3.adapter_.deregisterInteractionHandler(evtName, _this3.interactionStartHandler_);
        });
        this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
        this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);
        DOWN_EVENTS.forEach(function (evtName) {
          _this3.adapter_.deregisterThumbContainerInteractionHandler(evtName, _this3.thumbContainerPointerHandler_);
        });
        this.adapter_.deregisterResizeHandler(this.resizeHandler_);
      }
    }, {
      key: 'setupTrackMarker',
      value: function setupTrackMarker() {
        if (this.isDiscrete_ && this.hasTrackMarker_ && this.getStep() != 0) {
          var min = this.getMin();
          var max = this.getMax();
          var step = this.getStep();
          var numMarkers = (max - min) / step;

          // In case distance between max & min is indivisible to step,
          // we place the secondary to last marker proportionally at where thumb
          // could reach and place the last marker at max value
          var indivisible = Math.ceil(numMarkers) !== numMarkers;
          if (indivisible) {
            numMarkers = Math.ceil(numMarkers);
          }

          this.adapter_.removeTrackMarkers();
          this.adapter_.appendTrackMarkers(numMarkers);

          if (indivisible) {
            var lastStepRatio = (max - numMarkers * step) / step + 1;
            var flex = getCorrectPropertyName(window, 'flex');
            this.adapter_.setLastTrackMarkersStyleProperty(flex, String(lastStepRatio));
          }
        }
      }
    }, {
      key: 'layout',
      value: function layout() {
        this.rect_ = this.adapter_.computeBoundingRect();
        this.updateUIForCurrentValue_();
      }

      /** @return {number} */

    }, {
      key: 'getValue',
      value: function getValue() {
        return this.value_;
      }

      /** @param {number} value */

    }, {
      key: 'setValue',
      value: function setValue(value) {
        this.setValue_(value, false);
      }

      /** @return {number} */

    }, {
      key: 'getMax',
      value: function getMax() {
        return this.max_;
      }

      /** @param {number} max */

    }, {
      key: 'setMax',
      value: function setMax(max) {
        if (max < this.min_) {
          throw new Error('Cannot set max to be less than the slider\'s minimum value');
        }
        this.max_ = max;
        this.setValue_(this.value_, false, true);
        this.adapter_.setAttribute(strings$f.ARIA_VALUEMAX, String(this.max_));
        this.setupTrackMarker();
      }

      /** @return {number} */

    }, {
      key: 'getMin',
      value: function getMin() {
        return this.min_;
      }

      /** @param {number} min */

    }, {
      key: 'setMin',
      value: function setMin(min) {
        if (min > this.max_) {
          throw new Error('Cannot set min to be greater than the slider\'s maximum value');
        }
        this.min_ = min;
        this.setValue_(this.value_, false, true);
        this.adapter_.setAttribute(strings$f.ARIA_VALUEMIN, String(this.min_));
        this.setupTrackMarker();
      }

      /** @return {number} */

    }, {
      key: 'getStep',
      value: function getStep() {
        return this.step_;
      }

      /** @param {number} step */

    }, {
      key: 'setStep',
      value: function setStep(step) {
        if (step < 0) {
          throw new Error('Step cannot be set to a negative number');
        }
        if (this.isDiscrete_ && (typeof step !== 'number' || step < 1)) {
          step = 1;
        }
        this.step_ = step;
        this.setValue_(this.value_, false, true);
        this.setupTrackMarker();
      }

      /** @return {boolean} */

    }, {
      key: 'isDisabled',
      value: function isDisabled() {
        return this.disabled_;
      }

      /** @param {boolean} disabled */

    }, {
      key: 'setDisabled',
      value: function setDisabled(disabled) {
        this.disabled_ = disabled;
        this.toggleClass_(cssClasses$g.DISABLED, this.disabled_);
        if (this.disabled_) {
          this.savedTabIndex_ = this.adapter_.getTabIndex();
          this.adapter_.setAttribute(strings$f.ARIA_DISABLED, 'true');
          this.adapter_.removeAttribute('tabindex');
        } else {
          this.adapter_.removeAttribute(strings$f.ARIA_DISABLED);
          if (!isNaN(this.savedTabIndex_)) {
            this.adapter_.setAttribute('tabindex', String(this.savedTabIndex_));
          }
        }
      }

      /**
       * Called when the user starts interacting with the slider
       * @param {!Event} evt
       * @private
       */

    }, {
      key: 'handleDown_',
      value: function handleDown_(evt) {
        var _this4 = this;

        if (this.disabled_) {
          return;
        }

        this.preventFocusState_ = true;
        this.setInTransit_(!this.handlingThumbTargetEvt_);
        this.handlingThumbTargetEvt_ = false;
        this.setActive_(true);

        var moveHandler = function moveHandler(evt) {
          _this4.handleMove_(evt);
        };

        // Note: upHandler is [de]registered on ALL potential pointer-related release event types, since some browsers
        // do not always fire these consistently in pairs.
        // (See https://github.com/material-components/material-components-web/issues/1192)
        var upHandler = function upHandler() {
          _this4.handleUp_();
          _this4.adapter_.deregisterBodyInteractionHandler(MOVE_EVENT_MAP[evt.type], moveHandler);
          UP_EVENTS.forEach(function (evtName) {
            return _this4.adapter_.deregisterBodyInteractionHandler(evtName, upHandler);
          });
        };

        this.adapter_.registerBodyInteractionHandler(MOVE_EVENT_MAP[evt.type], moveHandler);
        UP_EVENTS.forEach(function (evtName) {
          return _this4.adapter_.registerBodyInteractionHandler(evtName, upHandler);
        });
        this.setValueFromEvt_(evt);
      }

      /**
       * Called when the user moves the slider
       * @param {!Event} evt
       * @private
       */

    }, {
      key: 'handleMove_',
      value: function handleMove_(evt) {
        evt.preventDefault();
        this.setValueFromEvt_(evt);
      }

      /**
       * Called when the user's interaction with the slider ends
       * @private
       */

    }, {
      key: 'handleUp_',
      value: function handleUp_() {
        this.setActive_(false);
        this.adapter_.notifyChange();
      }

      /**
       * Returns the pageX of the event
       * @param {!Event} evt
       * @return {number}
       * @private
       */

    }, {
      key: 'getPageX_',
      value: function getPageX_(evt) {
        if (evt.targetTouches && evt.targetTouches.length > 0) {
          return evt.targetTouches[0].pageX;
        }
        return evt.pageX;
      }

      /**
       * Sets the slider value from an event
       * @param {!Event} evt
       * @private
       */

    }, {
      key: 'setValueFromEvt_',
      value: function setValueFromEvt_(evt) {
        var pageX = this.getPageX_(evt);
        var value = this.computeValueFromPageX_(pageX);
        this.setValue_(value, true);
      }

      /**
       * Computes the new value from the pageX position
       * @param {number} pageX
       * @return {number}
       */

    }, {
      key: 'computeValueFromPageX_',
      value: function computeValueFromPageX_(pageX) {
        var max = this.max_,
            min = this.min_;

        var xPos = pageX - this.rect_.left;
        var pctComplete = xPos / this.rect_.width;
        if (this.adapter_.isRTL()) {
          pctComplete = 1 - pctComplete;
        }
        // Fit the percentage complete between the range [min,max]
        // by remapping from [0, 1] to [min, min+(max-min)].
        return min + pctComplete * (max - min);
      }

      /**
       * Handles keydown events
       * @param {!Event} evt
       */

    }, {
      key: 'handleKeydown_',
      value: function handleKeydown_(evt) {
        var keyId = this.getKeyId_(evt);
        var value = this.getValueForKeyId_(keyId);
        if (isNaN(value)) {
          return;
        }

        // Prevent page from scrolling due to key presses that would normally scroll the page
        evt.preventDefault();
        this.adapter_.addClass(cssClasses$g.FOCUS);
        this.setValue_(value, true);
        this.adapter_.notifyChange();
      }

      /**
       * Returns the computed name of the event
       * @param {!Event} kbdEvt
       * @return {string}
       */

    }, {
      key: 'getKeyId_',
      value: function getKeyId_(kbdEvt) {
        if (kbdEvt.key === KEY_IDS.ARROW_LEFT || kbdEvt.keyCode === 37) {
          return KEY_IDS.ARROW_LEFT;
        }
        if (kbdEvt.key === KEY_IDS.ARROW_RIGHT || kbdEvt.keyCode === 39) {
          return KEY_IDS.ARROW_RIGHT;
        }
        if (kbdEvt.key === KEY_IDS.ARROW_UP || kbdEvt.keyCode === 38) {
          return KEY_IDS.ARROW_UP;
        }
        if (kbdEvt.key === KEY_IDS.ARROW_DOWN || kbdEvt.keyCode === 40) {
          return KEY_IDS.ARROW_DOWN;
        }
        if (kbdEvt.key === KEY_IDS.HOME || kbdEvt.keyCode === 36) {
          return KEY_IDS.HOME;
        }
        if (kbdEvt.key === KEY_IDS.END || kbdEvt.keyCode === 35) {
          return KEY_IDS.END;
        }
        if (kbdEvt.key === KEY_IDS.PAGE_UP || kbdEvt.keyCode === 33) {
          return KEY_IDS.PAGE_UP;
        }
        if (kbdEvt.key === KEY_IDS.PAGE_DOWN || kbdEvt.keyCode === 34) {
          return KEY_IDS.PAGE_DOWN;
        }

        return '';
      }

      /**
       * Computes the value given a keyboard key ID
       * @param {string} keyId
       * @return {number}
       */

    }, {
      key: 'getValueForKeyId_',
      value: function getValueForKeyId_(keyId) {
        var max = this.max_,
            min = this.min_,
            step = this.step_;

        var delta = step || (max - min) / 100;
        var valueNeedsToBeFlipped = this.adapter_.isRTL() && (keyId === KEY_IDS.ARROW_LEFT || keyId === KEY_IDS.ARROW_RIGHT);
        if (valueNeedsToBeFlipped) {
          delta = -delta;
        }

        switch (keyId) {
          case KEY_IDS.ARROW_LEFT:
          case KEY_IDS.ARROW_DOWN:
            return this.value_ - delta;
          case KEY_IDS.ARROW_RIGHT:
          case KEY_IDS.ARROW_UP:
            return this.value_ + delta;
          case KEY_IDS.HOME:
            return this.min_;
          case KEY_IDS.END:
            return this.max_;
          case KEY_IDS.PAGE_UP:
            return this.value_ + delta * numbers$4.PAGE_FACTOR;
          case KEY_IDS.PAGE_DOWN:
            return this.value_ - delta * numbers$4.PAGE_FACTOR;
          default:
            return NaN;
        }
      }
    }, {
      key: 'handleFocus_',
      value: function handleFocus_() {
        if (this.preventFocusState_) {
          return;
        }
        this.adapter_.addClass(cssClasses$g.FOCUS);
      }
    }, {
      key: 'handleBlur_',
      value: function handleBlur_() {
        this.preventFocusState_ = false;
        this.adapter_.removeClass(cssClasses$g.FOCUS);
      }

      /**
       * Sets the value of the slider
       * @param {number} value
       * @param {boolean} shouldFireInput
       * @param {boolean=} force
       */

    }, {
      key: 'setValue_',
      value: function setValue_(value, shouldFireInput) {
        var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (value === this.value_ && !force) {
          return;
        }

        var min = this.min_,
            max = this.max_;

        var valueSetToBoundary = value === min || value === max;
        if (this.step_ && !valueSetToBoundary) {
          value = this.quantize_(value);
        }
        if (value < min) {
          value = min;
        } else if (value > max) {
          value = max;
        }
        this.value_ = value;
        this.adapter_.setAttribute(strings$f.ARIA_VALUENOW, String(this.value_));
        this.updateUIForCurrentValue_();

        if (shouldFireInput) {
          this.adapter_.notifyInput();
          if (this.isDiscrete_) {
            this.adapter_.setMarkerValue(value);
          }
        }
      }

      /**
       * Calculates the quantized value
       * @param {number} value
       * @return {number}
       */

    }, {
      key: 'quantize_',
      value: function quantize_(value) {
        var numSteps = Math.round(value / this.step_);
        var quantizedVal = numSteps * this.step_;
        return quantizedVal;
      }
    }, {
      key: 'updateUIForCurrentValue_',
      value: function updateUIForCurrentValue_() {
        var _this5 = this;

        var max = this.max_,
            min = this.min_,
            value = this.value_;

        var pctComplete = (value - min) / (max - min);
        var translatePx = pctComplete * this.rect_.width;
        if (this.adapter_.isRTL()) {
          translatePx = this.rect_.width - translatePx;
        }

        var transformProp = getCorrectPropertyName(window, 'transform');
        var transitionendEvtName = getCorrectEventName(window, 'transitionend');

        if (this.inTransit_) {
          var onTransitionEnd = function onTransitionEnd() {
            _this5.setInTransit_(false);
            _this5.adapter_.deregisterThumbContainerInteractionHandler(transitionendEvtName, onTransitionEnd);
          };
          this.adapter_.registerThumbContainerInteractionHandler(transitionendEvtName, onTransitionEnd);
        }

        this.updateUIFrame_ = requestAnimationFrame(function () {
          // NOTE(traviskaufman): It would be nice to use calc() here,
          // but IE cannot handle calcs in transforms correctly.
          // See: https://goo.gl/NC2itk
          // Also note that the -50% offset is used to center the slider thumb.
          _this5.adapter_.setThumbContainerStyleProperty(transformProp, 'translateX(' + translatePx + 'px) translateX(-50%)');
          _this5.adapter_.setTrackStyleProperty(transformProp, 'scaleX(' + pctComplete + ')');
        });
      }

      /**
       * Toggles the active state of the slider
       * @param {boolean} active
       */

    }, {
      key: 'setActive_',
      value: function setActive_(active) {
        this.active_ = active;
        this.toggleClass_(cssClasses$g.ACTIVE, this.active_);
      }

      /**
       * Toggles the inTransit state of the slider
       * @param {boolean} inTransit
       */

    }, {
      key: 'setInTransit_',
      value: function setInTransit_(inTransit) {
        this.inTransit_ = inTransit;
        this.toggleClass_(cssClasses$g.IN_TRANSIT, this.inTransit_);
      }

      /**
       * Conditionally adds or removes a class based on shouldBePresent
       * @param {string} className
       * @param {boolean} shouldBePresent
       */

    }, {
      key: 'toggleClass_',
      value: function toggleClass_(className, shouldBePresent) {
        if (shouldBePresent) {
          this.adapter_.addClass(className);
        } else {
          this.adapter_.removeClass(className);
        }
      }
    }]);
    return MDCSliderFoundation;
  }(MDCFoundation);

  var mdcSlider = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-slider", class: _vm.classes, attrs: { "tabindex": "0", "role": "slider" } }, [_c('div', { staticClass: "mdc-slider__track-container" }, [_c('div', { staticClass: "mdc-slider__track", style: _vm.trackStyles }), _vm._v(" "), _vm.hasMarkers ? _c('div', { staticClass: "mdc-slider__track-marker-container" }, _vm._l(_vm.numMarkers, function (markerNum) {
        return _c('div', { key: markerNum, staticClass: "mdc-slider__track-marker", style: markerNum == _vm.numMarkers ? _vm.lastTrackMarkersStyles : {} });
      })) : _vm._e()]), _vm._v(" "), _c('div', { ref: "thumbContainer", staticClass: "mdc-slider__thumb-container", style: _vm.thumbStyles }, [_vm.isDiscrete ? _c('div', { staticClass: "mdc-slider__pin" }, [_c('span', { staticClass: "mdc-slider__pin-value-marker" }, [_vm._v(_vm._s(_vm.markerValue))])]) : _vm._e(), _vm._v(" "), _c('svg', { staticClass: "mdc-slider__thumb", attrs: { "width": "21", "height": "21" } }, [_c('circle', { attrs: { "cx": "10.5", "cy": "10.5", "r": "7.875" } })]), _vm._v(" "), _c('div', { staticClass: "mdc-slider__focus-ring" })])]);
    }, staticRenderFns: [],
    name: 'mdc-slider',
    mixins: [DispatchFocusMixin],
    model: {
      prop: 'value',
      event: 'change'
    },
    props: {
      value: [Number, String],
      min: { type: [Number, String], default: 0 },
      max: { type: [Number, String], default: 100 },
      step: { type: [Number, String], default: 0 },
      displayMarkers: Boolean,
      disabled: Boolean,
      layoutOn: String,
      layoutOnSource: { type: Object, required: false }
    },
    data: function data() {
      return {
        classes: {
          'mdc-slider--discrete': !!this.step,
          'mdc-slider--display-markers': this.displayMarkers
        },
        trackStyles: {},
        lastTrackMarkersStyles: {},
        thumbStyles: {},
        markerValue: '',
        numMarkers: 0
      };
    },

    computed: {
      isDiscrete: function isDiscrete() {
        return !!this.step;
      },
      hasMarkers: function hasMarkers() {
        return !!this.step && this.displayMarkers && this.numMarkers;
      }
    },
    watch: {
      value: function value() {
        if (this.foundation.getValue() !== Number(this.value)) {
          this.foundation.setValue(this.value);
        }
      },
      min: function min() {
        this.foundation.setMin(Number(this.min));
      },
      max: function max() {
        this.foundation.setMax(Number(this.max));
      },
      step: function step() {
        this.foundation.setStep(Number(this.step));
      },
      disabled: function disabled() {
        this.foundation.setDisabled(this.disabled);
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCSliderFoundation({
        hasClass: function hasClass(className) {
          return _this.$el.classList.contains(className);
        },
        addClass: function addClass(className) {
          _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.classes, className, true);
        },
        getAttribute: function getAttribute(name) {
          return _this.$el.getAttribute(name);
        },
        setAttribute: function setAttribute(name, value) {
          return _this.$el.setAttribute(name, value);
        },
        removeAttribute: function removeAttribute(name) {
          return _this.$el.removeAttribute(name);
        },
        computeBoundingRect: function computeBoundingRect() {
          return _this.$el.getBoundingClientRect();
        },
        getTabIndex: function getTabIndex() {
          return _this.$el.tabIndex;
        },
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          _this.$el.addEventListener(type, handler, applyPassive());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          _this.$el.removeEventListener(type, handler, applyPassive());
        },
        registerThumbContainerInteractionHandler: function registerThumbContainerInteractionHandler(type, handler) {
          _this.$refs.thumbContainer.addEventListener(type, handler, applyPassive());
        },
        deregisterThumbContainerInteractionHandler: function deregisterThumbContainerInteractionHandler(type, handler) {
          _this.$refs.thumbContainer.removeEventListener(type, handler, applyPassive());
        },
        registerBodyInteractionHandler: function registerBodyInteractionHandler(type, handler) {
          document.body.addEventListener(type, handler);
        },
        deregisterBodyInteractionHandler: function deregisterBodyInteractionHandler(type, handler) {
          document.body.removeEventListener(type, handler);
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          window.removeEventListener('resize', handler);
        },
        notifyInput: function notifyInput() {
          _this.$emit('input', _this.foundation.getValue());
        },
        notifyChange: function notifyChange() {
          _this.$emit('change', _this.foundation.getValue());
        },
        setThumbContainerStyleProperty: function setThumbContainerStyleProperty(propertyName, value) {
          _this.$set(_this.thumbStyles, propertyName, value);
        },
        setTrackStyleProperty: function setTrackStyleProperty(propertyName, value) {
          _this.$set(_this.trackStyles, propertyName, value);
        },
        setMarkerValue: function setMarkerValue(value) {
          _this.markerValue = value;
        },
        appendTrackMarkers: function appendTrackMarkers(numMarkers) {
          _this.numMarkers = numMarkers;
        },
        removeTrackMarkers: function removeTrackMarkers() {
          _this.numMarkers = 0;
        },
        setLastTrackMarkersStyleProperty: function setLastTrackMarkersStyleProperty(propertyName, value) {
          _this.$set(_this.lastTrackMarkersStyles, propertyName, value);
        },
        isRTL: function isRTL() {
          return false;
        }
      });

      this.foundation.init();
      this.foundation.setDisabled(this.disabled);
      if (Number(this.min) <= this.foundation.getMax()) {
        this.foundation.setMin(Number(this.min));
        this.foundation.setMax(Number(this.max));
      } else {
        this.foundation.setMax(Number(this.max));
        this.foundation.setMin(Number(this.min));
      }
      this.foundation.setStep(Number(this.step));
      this.foundation.setValue(Number(this.value));
      if (this.hasMarkers) {
        this.foundation.setupTrackMarker();
      }

      this.$root.$on('vma:layout', this.layout);

      if (this.layoutOn) {
        this.layoutOnEventSource = this.layoutOnSource || this.$root;
        this.layoutOnEventSource.$on(this.layoutOn, this.layout);
      }
    },
    beforeDestroy: function beforeDestroy() {
      this.$root.$off('vma:layout', this.layout);
      if (this.layoutOnEventSource) {
        this.layoutOnEventSource.$off(this.layoutOn, this.layout);
      }
      this.foundation.destroy();
    },

    methods: {
      layout: function layout() {
        var _this2 = this;

        this.$nextTick(function () {
          _this2.foundation && _this2.foundation.layout();
        });
      }
    }
  };

  var VueMDCSlider = BasePlugin({
    mdcSlider: mdcSlider
  });

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */
  var cssClasses$h = {
    ROOT: 'mdc-snackbar',
    TEXT: 'mdc-snackbar__text',
    ACTION_WRAPPER: 'mdc-snackbar__action-wrapper',
    ACTION_BUTTON: 'mdc-snackbar__action-button',
    ACTIVE: 'mdc-snackbar--active',
    MULTILINE: 'mdc-snackbar--multiline',
    ACTION_ON_BOTTOM: 'mdc-snackbar--action-on-bottom'
  };

  var strings$g = {
    TEXT_SELECTOR: '.mdc-snackbar__text',
    ACTION_WRAPPER_SELECTOR: '.mdc-snackbar__action-wrapper',
    ACTION_BUTTON_SELECTOR: '.mdc-snackbar__action-button',
    SHOW_EVENT: 'MDCSnackbar:show',
    HIDE_EVENT: 'MDCSnackbar:hide'
  };

  var numbers$5 = {
    MESSAGE_TIMEOUT: 2750
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCSnackbarFoundation = function (_MDCFoundation) {
    inherits(MDCSnackbarFoundation, _MDCFoundation);
    createClass(MDCSnackbarFoundation, [{
      key: 'active',
      get: function get$$1() {
        return this.active_;
      }
    }], [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$h;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$g;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          setAriaHidden: function setAriaHidden() {},
          unsetAriaHidden: function unsetAriaHidden() {},
          setActionAriaHidden: function setActionAriaHidden() {},
          unsetActionAriaHidden: function unsetActionAriaHidden() {},
          setActionText: function setActionText() /* actionText: string */{},
          setMessageText: function setMessageText() /* message: string */{},
          setFocus: function setFocus() {},
          visibilityIsHidden: function visibilityIsHidden() {
            return (/* boolean */false
            );
          },
          registerCapturedBlurHandler: function registerCapturedBlurHandler() /* handler: EventListener */{},
          deregisterCapturedBlurHandler: function deregisterCapturedBlurHandler() /* handler: EventListener */{},
          registerVisibilityChangeHandler: function registerVisibilityChangeHandler() /* handler: EventListener */{},
          deregisterVisibilityChangeHandler: function deregisterVisibilityChangeHandler() /* handler: EventListener */{},
          registerCapturedInteractionHandler: function registerCapturedInteractionHandler() /* evtType: string, handler: EventListener */{},
          deregisterCapturedInteractionHandler: function deregisterCapturedInteractionHandler() /* evtType: string, handler: EventListener */{},
          registerActionClickHandler: function registerActionClickHandler() /* handler: EventListener */{},
          deregisterActionClickHandler: function deregisterActionClickHandler() /* handler: EventListener */{},
          registerTransitionEndHandler: function registerTransitionEndHandler() /* handler: EventListener */{},
          deregisterTransitionEndHandler: function deregisterTransitionEndHandler() /* handler: EventListener */{},
          notifyShow: function notifyShow() {},
          notifyHide: function notifyHide() {}
        };
      }
    }]);

    function MDCSnackbarFoundation(adapter) {
      classCallCheck(this, MDCSnackbarFoundation);

      var _this = possibleConstructorReturn(this, (MDCSnackbarFoundation.__proto__ || Object.getPrototypeOf(MDCSnackbarFoundation)).call(this, _extends(MDCSnackbarFoundation.defaultAdapter, adapter)));

      _this.active_ = false;
      _this.actionWasClicked_ = false;
      _this.dismissOnAction_ = true;
      _this.firstFocus_ = true;
      _this.pointerDownRecognized_ = false;
      _this.snackbarHasFocus_ = false;
      _this.snackbarData_ = null;
      _this.queue_ = [];
      _this.actionClickHandler_ = function () {
        _this.actionWasClicked_ = true;
        _this.invokeAction_();
      };
      _this.visibilitychangeHandler_ = function () {
        clearTimeout(_this.timeoutId_);
        _this.snackbarHasFocus_ = true;

        if (!_this.adapter_.visibilityIsHidden()) {
          setTimeout(_this.cleanup_.bind(_this), _this.snackbarData_.timeout || numbers$5.MESSAGE_TIMEOUT);
        }
      };
      _this.interactionHandler_ = function (evt) {
        if (evt.type == 'touchstart' || evt.type == 'mousedown') {
          _this.pointerDownRecognized_ = true;
        }
        _this.handlePossibleTabKeyboardFocus_(evt);

        if (evt.type == 'focus') {
          _this.pointerDownRecognized_ = false;
        }
      };
      _this.blurHandler_ = function () {
        clearTimeout(_this.timeoutId_);
        _this.snackbarHasFocus_ = false;
        _this.timeoutId_ = setTimeout(_this.cleanup_.bind(_this), _this.snackbarData_.timeout || numbers$5.MESSAGE_TIMEOUT);
      };
      return _this;
    }

    createClass(MDCSnackbarFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.registerActionClickHandler(this.actionClickHandler_);
        this.adapter_.setAriaHidden();
        this.adapter_.setActionAriaHidden();
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this2 = this;

        this.adapter_.deregisterActionClickHandler(this.actionClickHandler_);
        this.adapter_.deregisterCapturedBlurHandler(this.blurHandler_);
        this.adapter_.deregisterVisibilityChangeHandler(this.visibilitychangeHandler_);
        ['touchstart', 'mousedown', 'focus'].forEach(function (evtType) {
          _this2.adapter_.deregisterCapturedInteractionHandler(evtType, _this2.interactionHandler_);
        });
      }
    }, {
      key: 'dismissesOnAction',
      value: function dismissesOnAction() {
        return this.dismissOnAction_;
      }
    }, {
      key: 'setDismissOnAction',
      value: function setDismissOnAction(dismissOnAction) {
        this.dismissOnAction_ = !!dismissOnAction;
      }
    }, {
      key: 'show',
      value: function show(data) {
        var _this3 = this;

        if (!data) {
          throw new Error('Please provide a data object with at least a message to display.');
        }
        if (!data.message) {
          throw new Error('Please provide a message to be displayed.');
        }
        if (data.actionHandler && !data.actionText) {
          throw new Error('Please provide action text with the handler.');
        }
        if (this.active) {
          this.queue_.push(data);
          return;
        }
        clearTimeout(this.timeoutId_);
        this.snackbarData_ = data;
        this.firstFocus_ = true;
        this.adapter_.registerVisibilityChangeHandler(this.visibilitychangeHandler_);
        this.adapter_.registerCapturedBlurHandler(this.blurHandler_);
        ['touchstart', 'mousedown', 'focus'].forEach(function (evtType) {
          _this3.adapter_.registerCapturedInteractionHandler(evtType, _this3.interactionHandler_);
        });

        var ACTIVE = cssClasses$h.ACTIVE,
            MULTILINE = cssClasses$h.MULTILINE,
            ACTION_ON_BOTTOM = cssClasses$h.ACTION_ON_BOTTOM;


        this.adapter_.setMessageText(this.snackbarData_.message);

        if (this.snackbarData_.multiline) {
          this.adapter_.addClass(MULTILINE);
          if (this.snackbarData_.actionOnBottom) {
            this.adapter_.addClass(ACTION_ON_BOTTOM);
          }
        }

        if (this.snackbarData_.actionHandler) {
          this.adapter_.setActionText(this.snackbarData_.actionText);
          this.actionHandler_ = this.snackbarData_.actionHandler;
          this.setActionHidden_(false);
        } else {
          this.setActionHidden_(true);
          this.actionHandler_ = null;
          this.adapter_.setActionText(null);
        }

        this.active_ = true;
        this.adapter_.addClass(ACTIVE);
        this.adapter_.unsetAriaHidden();
        this.adapter_.notifyShow();

        this.timeoutId_ = setTimeout(this.cleanup_.bind(this), this.snackbarData_.timeout || numbers$5.MESSAGE_TIMEOUT);
      }
    }, {
      key: 'handlePossibleTabKeyboardFocus_',
      value: function handlePossibleTabKeyboardFocus_() {
        var hijackFocus = this.firstFocus_ && !this.pointerDownRecognized_;

        if (hijackFocus) {
          this.setFocusOnAction_();
        }

        this.firstFocus_ = false;
      }
    }, {
      key: 'setFocusOnAction_',
      value: function setFocusOnAction_() {
        this.adapter_.setFocus();
        this.snackbarHasFocus_ = true;
        this.firstFocus_ = false;
      }
    }, {
      key: 'invokeAction_',
      value: function invokeAction_() {
        try {
          if (!this.actionHandler_) {
            return;
          }

          this.actionHandler_();
        } finally {
          if (this.dismissOnAction_) {
            this.cleanup_();
          }
        }
      }
    }, {
      key: 'cleanup_',
      value: function cleanup_() {
        var _this4 = this;

        var allowDismissal = !this.snackbarHasFocus_ || this.actionWasClicked_;

        if (allowDismissal) {
          var ACTIVE = cssClasses$h.ACTIVE,
              MULTILINE = cssClasses$h.MULTILINE,
              ACTION_ON_BOTTOM = cssClasses$h.ACTION_ON_BOTTOM;


          this.adapter_.removeClass(ACTIVE);

          var handler = function handler() {
            clearTimeout(_this4.timeoutId_);
            _this4.adapter_.deregisterTransitionEndHandler(handler);
            _this4.adapter_.removeClass(MULTILINE);
            _this4.adapter_.removeClass(ACTION_ON_BOTTOM);
            _this4.setActionHidden_(true);
            _this4.adapter_.setAriaHidden();
            _this4.active_ = false;
            _this4.snackbarHasFocus_ = false;
            _this4.adapter_.notifyHide();
            _this4.showNext_();
          };

          this.adapter_.registerTransitionEndHandler(handler);
        }
      }
    }, {
      key: 'showNext_',
      value: function showNext_() {
        if (!this.queue_.length) {
          return;
        }
        this.show(this.queue_.shift());
      }
    }, {
      key: 'setActionHidden_',
      value: function setActionHidden_(isHidden) {
        if (isHidden) {
          this.adapter_.setActionAriaHidden();
        } else {
          this.adapter_.unsetActionAriaHidden();
        }
      }
    }]);
    return MDCSnackbarFoundation;
  }(MDCFoundation);

  var mdcSnackbar = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { ref: "root", staticClass: "mdc-snackbar", class: _vm.classes, attrs: { "aria-hidden": _vm.hidden, "aria-live": "assertive", "aria-atomic": "true" } }, [_c('div', { staticClass: "mdc-snackbar__text" }, [_vm._v(_vm._s(_vm.message))]), _vm._v(" "), _c('div', { staticClass: "mdc-snackbar__action-wrapper" }, [_c('button', { ref: "button", staticClass: "mdc-snackbar__action-button", attrs: { "aria-hidden": _vm.actionHidden, "type": "button" } }, [_vm._v(_vm._s(_vm.actionText))])])]);
    }, staticRenderFns: [],
    name: 'mdc-snackbar',
    model: {
      prop: 'snack',
      event: 'queued'
    },
    props: {
      'align-start': Boolean,
      snack: Object,
      event: String,
      'event-source': {
        type: Object,
        required: false,
        default: function _default() {
          return this.$root;
        }
      },
      'dismisses-on-action': {
        type: Boolean,
        default: true
      }
    },
    data: function data() {
      return {
        classes: {
          'mdc-snackbar--align-start': this.alignStart
        },
        message: '',
        actionText: '',
        hidden: false,
        actionHidden: false
      };
    },

    watch: {
      snack: 'onSnack'
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCSnackbarFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        setAriaHidden: function setAriaHidden() {
          return _this.hidden = true;
        },
        unsetAriaHidden: function unsetAriaHidden() {
          return _this.hidden = false;
        },
        setActionAriaHidden: function setActionAriaHidden() {
          return _this.actionHidden = true;
        },
        unsetActionAriaHidden: function unsetActionAriaHidden() {
          return _this.actionHidden = false;
        },
        setActionText: function setActionText(text) {
          _this.actionText = text;
        },
        setMessageText: function setMessageText(text) {
          _this.message = text;
        },
        setFocus: function setFocus() {
          return _this.$refs.button.focus();
        },
        visibilityIsHidden: function visibilityIsHidden() {
          return document.hidden;
        },
        registerCapturedBlurHandler: function registerCapturedBlurHandler(handler) {
          return _this.$refs.button.addEventListener('blur', handler, true);
        },
        deregisterCapturedBlurHandler: function deregisterCapturedBlurHandler(handler) {
          return _this.$refs.button.removeEventListener('blur', handler, true);
        },
        registerVisibilityChangeHandler: function registerVisibilityChangeHandler(handler) {
          return document.addEventListener('visibilitychange', handler);
        },
        deregisterVisibilityChangeHandler: function deregisterVisibilityChangeHandler(handler) {
          return document.removeEventListener('visibilitychange', handler);
        },
        registerCapturedInteractionHandler: function registerCapturedInteractionHandler(evt, handler) {
          return document.body.addEventListener(evt, handler, true);
        },
        deregisterCapturedInteractionHandler: function deregisterCapturedInteractionHandler(evt, handler) {
          return document.body.removeEventListener(evt, handler, true);
        },
        registerActionClickHandler: function registerActionClickHandler(handler) {
          return _this.$refs.button.addEventListener('click', handler);
        },
        deregisterActionClickHandler: function deregisterActionClickHandler(handler) {
          return _this.$refs.button.removeEventListener('click', handler);
        },
        registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
          var root = _this.$refs.root;
          root && root.addEventListener(getCorrectEventName(window, 'transitionend'), handler);
        },
        deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
          var root = _this.$refs.root;
          root && root.removeEventListener(getCorrectEventName(window, 'transitionend'), handler);
        },
        notifyShow: function notifyShow() {
          return _this.$emit('show');
        },
        notifyHide: function notifyHide() {
          return _this.$emit('hide');
        }
      });
      this.foundation.init();

      // if event specified use it, else if no snack prop then use default.
      this.eventName = this.event || (this.snack === void 0 ? 'show-snackbar' : null);
      if (this.eventName) {
        this.eventSource.$on(this.eventName, this.show);
      }
      this.foundation.setDismissOnAction(this.dismissesOnAction);
    },
    beforeDestroy: function beforeDestroy() {
      if (this.eventSource) {
        this.eventSource.$off(this.eventName, this.show);
      }
      this.foundation.destroy();
    },

    methods: {
      onSnack: function onSnack(snack) {
        if (snack && snack.message) {
          this.foundation.show(snack);
          this.$emit('queued', snack);
        }
      },
      show: function show(data) {
        this.foundation.show(data);
      }
    }
  };

  var VueMDCSnackbar = BasePlugin({
    mdcSnackbar: mdcSnackbar
  });

  var mdcSwitch = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-switch-wrapper", class: { 'mdc-form-field': _vm.hasLabel, 'mdc-form-field--align-end': _vm.hasLabel && _vm.alignEnd } }, [_c('div', { staticClass: "mdc-switch", class: { 'mdc-switch--disabled': _vm.disabled } }, [_c('input', { ref: "control", staticClass: "mdc-switch__native-control", attrs: { "name": _vm.name, "id": _vm.vma_uid_, "disabled": _vm.disabled, "type": "checkbox" }, domProps: { "checked": _vm.checked }, on: { "change": _vm.onChanged } }), _vm._v(" "), _vm._m(0)]), _vm._v(" "), _vm.hasLabel ? _c('label', { staticClass: "mdc-switch-label", attrs: { "for": _vm.vma_uid_ } }, [_vm._t("default", [_vm._v(_vm._s(_vm.label))])], 2) : _vm._e()]);
    }, staticRenderFns: [function () {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-switch__background" }, [_c('div', { staticClass: "mdc-switch__knob" })]);
    }],
    name: 'mdc-switch',
    mixins: [DispatchFocusMixin, VMAUniqueIdMixin],
    model: {
      prop: 'checked',
      event: 'change'
    },
    props: {
      checked: Boolean,
      label: String,
      alignEnd: Boolean,
      disabled: Boolean,
      value: {
        type: String,
        default: function _default() {
          return 'on';
        }
      },
      name: String
    },
    computed: {
      hasLabel: function hasLabel() {
        return this.label || this.$slots.default;
      }
    },
    methods: {
      onChanged: function onChanged(event) {
        this.$emit('change', event.target.checked);
      }
    }
  };

  var VueMDCSwitch = BasePlugin({
    mdcSwitch: mdcSwitch
  });

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$i = {
    ACTIVE: 'mdc-tab--active'
  };

  var strings$h = {
    SELECTED_EVENT: 'MDCTab:selected'
  };

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCTabFoundation = function (_MDCFoundation) {
    inherits(MDCTabFoundation, _MDCFoundation);
    createClass(MDCTabFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$i;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$h;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
          getOffsetWidth: function getOffsetWidth() {
            return (/* number */0
            );
          },
          getOffsetLeft: function getOffsetLeft() {
            return (/* number */0
            );
          },
          notifySelected: function notifySelected() {}
        };
      }
    }]);

    function MDCTabFoundation() {
      var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      classCallCheck(this, MDCTabFoundation);

      var _this = possibleConstructorReturn(this, (MDCTabFoundation.__proto__ || Object.getPrototypeOf(MDCTabFoundation)).call(this, _extends(MDCTabFoundation.defaultAdapter, adapter)));

      _this.computedWidth_ = 0;
      _this.computedLeft_ = 0;
      _this.isActive_ = false;
      _this.preventDefaultOnClick_ = false;

      _this.clickHandler_ = function (evt) {
        if (_this.preventDefaultOnClick_) {
          evt.preventDefault();
        }
        _this.adapter_.notifySelected();
      };

      _this.keydownHandler_ = function (evt) {
        if (evt.key && evt.key === 'Enter' || evt.keyCode === 13) {
          _this.adapter_.notifySelected();
        }
      };
      return _this;
    }

    createClass(MDCTabFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.registerInteractionHandler('click', this.clickHandler_);
        this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
        this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
      }
    }, {
      key: 'getComputedWidth',
      value: function getComputedWidth() {
        return this.computedWidth_;
      }
    }, {
      key: 'getComputedLeft',
      value: function getComputedLeft() {
        return this.computedLeft_;
      }
    }, {
      key: 'isActive',
      value: function isActive() {
        return this.isActive_;
      }
    }, {
      key: 'setActive',
      value: function setActive(isActive) {
        this.isActive_ = isActive;
        if (this.isActive_) {
          this.adapter_.addClass(cssClasses$i.ACTIVE);
        } else {
          this.adapter_.removeClass(cssClasses$i.ACTIVE);
        }
      }
    }, {
      key: 'preventsDefaultOnClick',
      value: function preventsDefaultOnClick() {
        return this.preventDefaultOnClick_;
      }
    }, {
      key: 'setPreventDefaultOnClick',
      value: function setPreventDefaultOnClick(preventDefaultOnClick) {
        this.preventDefaultOnClick_ = preventDefaultOnClick;
      }
    }, {
      key: 'measureSelf',
      value: function measureSelf() {
        this.computedWidth_ = this.adapter_.getOffsetWidth();
        this.computedLeft_ = this.adapter_.getOffsetLeft();
      }
    }]);
    return MDCTabFoundation;
  }(MDCFoundation);

  var mdcTab = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-link', _vm._g({ staticClass: "mdc-tab", class: _vm.classes, style: _vm.styles, attrs: { "link": _vm.link } }, _vm.listeners), [!!_vm.hasIcon ? _c('i', { ref: "icon", staticClass: "mdc-tab__icon", class: _vm.hasIcon.classes, attrs: { "tabindex": "0" } }, [_vm._t("icon", [_vm._v(_vm._s(_vm.hasIcon.content))])], 2) : _vm._e(), _vm._v(" "), _vm.hasText ? _c('span', { class: { 'mdc-tab__icon-text': !!_vm.hasIcon } }, [_vm._t("default")], 2) : _vm._e()]);
    }, staticRenderFns: [],
    name: 'mdc-tab',
    mixins: [CustomLinkMixin, DispatchEventMixin],
    props: {
      active: Boolean,
      icon: [String, Array, Object]
    },
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },

    computed: {
      hasIcon: function hasIcon() {
        if (this.icon || this.$slots.icon) {
          return this.icon ? extractIconProp(this.icon) : {};
        }
        return false;
      },
      hasText: function hasText() {
        return !!this.$slots.default;
      }
    },
    watch: {
      active: function active(value) {
        if (value) {
          this.foundation.adapter_.notifySelected();
        }
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCTabFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          return _this.$el.addEventListener(type, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          return _this.$el.removeEventListener(type, handler);
        },
        getOffsetWidth: function getOffsetWidth() {
          return _this.$el.offsetWidth;
        },
        getOffsetLeft: function getOffsetLeft() {
          return _this.$el.offsetLeft;
        },
        notifySelected: function notifySelected() {
          emitCustomEvent(_this.$el, MDCTabFoundation.strings.SELECTED_EVENT, { tab: _this }, true);
        }
      });
      this.foundation.init();
      this.setActive(this.active);
      this.ripple = new RippleBase(this);
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
      this.ripple.destroy();
    },

    methods: {
      getComputedWidth: function getComputedWidth() {
        return this.foundation.getComputedWidth();
      },
      getComputedLeft: function getComputedLeft() {
        return this.foundation.getComputedLeft();
      },
      isActive: function isActive() {
        return this.foundation.isActive();
      },
      setActive: function setActive(isActive) {
        this.foundation.setActive(isActive);
      },
      isDefaultPreventedOnClick: function isDefaultPreventedOnClick() {
        return this.foundation.preventsDefaultOnClick();
      },
      setPreventDefaultOnClick: function setPreventDefaultOnClick(preventDefaultOnClick) {
        this.foundation.setPreventDefaultOnClick(preventDefaultOnClick);
      },
      measureSelf: function measureSelf() {
        this.foundation.measureSelf();
      }
    }
  };

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$j = {
    UPGRADED: 'mdc-tab-bar-upgraded'
  };

  var strings$i = {
    TAB_SELECTOR: '.mdc-tab',
    INDICATOR_SELECTOR: '.mdc-tab-bar__indicator',
    CHANGE_EVENT: 'MDCTabBar:change'
  };

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCTabBarFoundation = function (_MDCFoundation) {
    inherits(MDCTabBarFoundation, _MDCFoundation);
    createClass(MDCTabBarFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$j;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$i;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          bindOnMDCTabSelectedEvent: function bindOnMDCTabSelectedEvent() {},
          unbindOnMDCTabSelectedEvent: function unbindOnMDCTabSelectedEvent() {},
          registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
          deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
          getOffsetWidth: function getOffsetWidth() {
            return (/* number */0
            );
          },
          setStyleForIndicator: function setStyleForIndicator() /* propertyName: string, value: string */{},
          getOffsetWidthForIndicator: function getOffsetWidthForIndicator() {
            return (/* number */0
            );
          },
          notifyChange: function notifyChange() /* evtData: {activeTabIndex: number} */{},
          getNumberOfTabs: function getNumberOfTabs() {
            return (/* number */0
            );
          },
          isTabActiveAtIndex: function isTabActiveAtIndex() {
            return (/* index: number */ /* boolean */false
            );
          },
          setTabActiveAtIndex: function setTabActiveAtIndex() /* index: number, isActive: true */{},
          isDefaultPreventedOnClickForTabAtIndex: function isDefaultPreventedOnClickForTabAtIndex() {
            return (/* index: number */ /* boolean */false
            );
          },
          setPreventDefaultOnClickForTabAtIndex: function setPreventDefaultOnClickForTabAtIndex() /* index: number, preventDefaultOnClick: boolean */{},
          measureTabAtIndex: function measureTabAtIndex() /* index: number */{},
          getComputedWidthForTabAtIndex: function getComputedWidthForTabAtIndex() {
            return (/* index: number */ /* number */0
            );
          },
          getComputedLeftForTabAtIndex: function getComputedLeftForTabAtIndex() {
            return (/* index: number */ /* number */0
            );
          }
        };
      }
    }]);

    function MDCTabBarFoundation(adapter) {
      classCallCheck(this, MDCTabBarFoundation);

      var _this = possibleConstructorReturn(this, (MDCTabBarFoundation.__proto__ || Object.getPrototypeOf(MDCTabBarFoundation)).call(this, _extends(MDCTabBarFoundation.defaultAdapter, adapter)));

      _this.isIndicatorShown_ = false;
      _this.computedWidth_ = 0;
      _this.computedLeft_ = 0;
      _this.activeTabIndex_ = 0;
      _this.layoutFrame_ = 0;
      _this.resizeHandler_ = function () {
        return _this.layout();
      };
      return _this;
    }

    createClass(MDCTabBarFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.addClass(cssClasses$j.UPGRADED);
        this.adapter_.bindOnMDCTabSelectedEvent();
        this.adapter_.registerResizeHandler(this.resizeHandler_);
        var activeTabIndex = this.findActiveTabIndex_();
        if (activeTabIndex >= 0) {
          this.activeTabIndex_ = activeTabIndex;
        }
        this.layout();
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.removeClass(cssClasses$j.UPGRADED);
        this.adapter_.unbindOnMDCTabSelectedEvent();
        this.adapter_.deregisterResizeHandler(this.resizeHandler_);
      }
    }, {
      key: 'layoutInternal_',
      value: function layoutInternal_() {
        var _this2 = this;

        this.forEachTabIndex_(function (index) {
          return _this2.adapter_.measureTabAtIndex(index);
        });
        this.computedWidth_ = this.adapter_.getOffsetWidth();
        this.layoutIndicator_();
      }
    }, {
      key: 'layoutIndicator_',
      value: function layoutIndicator_() {
        var isIndicatorFirstRender = !this.isIndicatorShown_;

        // Ensure that indicator appears in the right position immediately for correct first render.
        if (isIndicatorFirstRender) {
          this.adapter_.setStyleForIndicator('transition', 'none');
        }

        var translateAmtForActiveTabLeft = this.adapter_.getComputedLeftForTabAtIndex(this.activeTabIndex_);
        var scaleAmtForActiveTabWidth = this.adapter_.getComputedWidthForTabAtIndex(this.activeTabIndex_) / this.adapter_.getOffsetWidth();

        var transformValue = 'translateX(' + translateAmtForActiveTabLeft + 'px) scale(' + scaleAmtForActiveTabWidth + ', 1)';
        this.adapter_.setStyleForIndicator(getCorrectPropertyName(window, 'transform'), transformValue);

        if (isIndicatorFirstRender) {
          // Force layout so that transform styles to take effect.
          this.adapter_.getOffsetWidthForIndicator();
          this.adapter_.setStyleForIndicator('transition', '');
          this.adapter_.setStyleForIndicator('visibility', 'visible');
          this.isIndicatorShown_ = true;
        }
      }
    }, {
      key: 'findActiveTabIndex_',
      value: function findActiveTabIndex_() {
        var _this3 = this;

        var activeTabIndex = -1;
        this.forEachTabIndex_(function (index) {
          if (_this3.adapter_.isTabActiveAtIndex(index)) {
            activeTabIndex = index;
            return true;
          }
        });
        return activeTabIndex;
      }
    }, {
      key: 'forEachTabIndex_',
      value: function forEachTabIndex_(iterator) {
        var numTabs = this.adapter_.getNumberOfTabs();
        for (var index = 0; index < numTabs; index++) {
          var shouldBreak = iterator(index);
          if (shouldBreak) {
            break;
          }
        }
      }
    }, {
      key: 'layout',
      value: function layout() {
        var _this4 = this;

        if (this.layoutFrame_) {
          cancelAnimationFrame(this.layoutFrame_);
        }

        this.layoutFrame_ = requestAnimationFrame(function () {
          _this4.layoutInternal_();
          _this4.layoutFrame_ = 0;
        });
      }
    }, {
      key: 'switchToTabAtIndex',
      value: function switchToTabAtIndex(index, shouldNotify) {
        var _this5 = this;

        if (index === this.activeTabIndex_) {
          return;
        }

        if (index < 0 || index >= this.adapter_.getNumberOfTabs()) {
          throw new Error('Out of bounds index specified for tab: ' + index);
        }

        var prevActiveTabIndex = this.activeTabIndex_;
        this.activeTabIndex_ = index;
        requestAnimationFrame(function () {
          if (prevActiveTabIndex >= 0) {
            _this5.adapter_.setTabActiveAtIndex(prevActiveTabIndex, false);
          }
          _this5.adapter_.setTabActiveAtIndex(_this5.activeTabIndex_, true);
          _this5.layoutIndicator_();
          if (shouldNotify) {
            _this5.adapter_.notifyChange({ activeTabIndex: _this5.activeTabIndex_ });
          }
        });
      }
    }, {
      key: 'getActiveTabIndex',
      value: function getActiveTabIndex() {
        return this.findActiveTabIndex_();
      }
    }]);
    return MDCTabBarFoundation;
  }(MDCFoundation);

  var mdcTabBar = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('nav', _vm._g({ staticClass: "mdc-tab-bar", class: _vm.classes }, _vm.$listeners), [_vm._t("default"), _vm._v(" "), _c('span', { ref: "indicator", staticClass: "mdc-tab-bar__indicator", style: _vm.indicatorStyles })], 2);
    }, staticRenderFns: [],
    name: 'mdc-tab-bar',
    data: function data() {
      return {
        classes: {},
        indicatorStyles: {},
        tabs: []
      };
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCTabBarFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        bindOnMDCTabSelectedEvent: function bindOnMDCTabSelectedEvent() {
          _this.$el.addEventListener(MDCTabFoundation.strings.SELECTED_EVENT, _this.onSelect);
        },
        unbindOnMDCTabSelectedEvent: function unbindOnMDCTabSelectedEvent() {
          return _this.$el.removeEventListener(MDCTabFoundation.strings.SELECTED_EVENT, _this.onSelect);
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          return window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          return window.removeEventListener('resize', handler);
        },
        getOffsetWidth: function getOffsetWidth() {
          return _this.$el.offsetWidth;
        },
        setStyleForIndicator: function setStyleForIndicator(propertyName, value) {
          return _this.$set(_this.indicatorStyles, propertyName, value);
        },
        getOffsetWidthForIndicator: function getOffsetWidthForIndicator() {
          return _this.$refs.indicator.offsetWidth;
        },
        notifyChange: function notifyChange(evtData) {
          _this.$emit('change', evtData.activeTabIndex);
        },
        getNumberOfTabs: function getNumberOfTabs() {
          return _this.tabs.length;
        },
        isTabActiveAtIndex: function isTabActiveAtIndex(index) {
          return _this.tabs[index].isActive();
        },
        setTabActiveAtIndex: function setTabActiveAtIndex(index, isActive) {
          // pgbr: 2018-04-07
          // since it is possible to change the number of tabs programatically
          // we need to detect the foundation deactivating a tab
          // that no longer exists but was previously active.
          if (!isActive && index >= _this.tabs.length) {
            return;
          }
          _this.tabs[index].setActive(isActive);
        },
        isDefaultPreventedOnClickForTabAtIndex: function isDefaultPreventedOnClickForTabAtIndex(index) {
          return _this.tabs[index].isDefaultPreventedOnClick();
        },
        setPreventDefaultOnClickForTabAtIndex: function setPreventDefaultOnClickForTabAtIndex(index, preventDefaultOnClick) {
          _this.tabs[index].setPreventDefaultOnClick(preventDefaultOnClick);
        },
        measureTabAtIndex: function measureTabAtIndex(index) {
          return _this.tabs[index].measureSelf();
        },
        getComputedWidthForTabAtIndex: function getComputedWidthForTabAtIndex(index) {
          return _this.tabs[index].getComputedWidth();
        },
        getComputedLeftForTabAtIndex: function getComputedLeftForTabAtIndex(index) {
          return _this.tabs[index].getComputedLeft();
        }
      });

      var resetTabs = function resetTabs() {
        var tabElements = [].slice.call(_this.$el.querySelectorAll(MDCTabBarFoundation.strings.TAB_SELECTOR));
        _this.tabs = tabElements.map(function (el) {
          return el.__vue__;
        });

        var hasText = void 0,
            hasIcon = void 0;
        var tabs = _this.tabs;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = tabs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var tab = _step.value;

            if (tab.hasText) {
              hasText = true;
              break;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = tabs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _tab = _step2.value;

            if (_tab.hasIcon) {
              hasIcon = true;
              break;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        if (hasText && hasIcon) {
          _this.$set(_this.classes, 'mdc-tab-bar--icons-with-text', true);
        } else if (hasIcon) {
          _this.$set(_this.classes, 'mdc-tab-bar--icon-tab-bar', true);
        }

        if (_this.foundation) {
          var activeTabIndex = _this.foundation.getActiveTabIndex();
          if (activeTabIndex >= 0) {
            _this.foundation.switchToTabAtIndex(activeTabIndex, true);
          } else {
            _this.foundation.switchToTabAtIndex(0, true);
          }
          _this.foundation.layout();
        }
      };

      resetTabs();

      this.slotObserver = new MutationObserver(function () {
        return resetTabs();
      });
      this.slotObserver.observe(this.$el, { childList: true, subtree: true });

      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.slotObserver.disconnect();
      this.foundation.destroy();
    },

    methods: {
      onSelect: function onSelect(_ref) {
        var detail = _ref.detail;
        var tab = detail.tab;

        var index = this.tabs.indexOf(tab);
        if (index < 0) {
          throw new Error('mdc-tab-bar internal error: index not found');
        }
        this.foundation.switchToTabAtIndex(index, true);
      }
    }
  };

  var VueMDCTabs = BasePlugin({
    mdcTab: mdcTab,
    mdcTabBar: mdcTabBar
  });

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Text Field Helper Text.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the TextField helper text into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCTextFieldHelperTextAdapter = function () {
    function MDCTextFieldHelperTextAdapter() {
      classCallCheck(this, MDCTextFieldHelperTextAdapter);
    }

    createClass(MDCTextFieldHelperTextAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the helper text element.
       * @param {string} className
       */
      value: function addClass(className) {}

      /**
       * Removes a class from the helper text element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * Returns whether or not the helper text element contains the given class.
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}

      /**
       * Sets an attribute with a given value on the helper text element.
       * @param {string} attr
       * @param {string} value
       */

    }, {
      key: "setAttr",
      value: function setAttr(attr, value) {}

      /**
       * Removes an attribute from the helper text element.
       * @param {string} attr
       */

    }, {
      key: "removeAttr",
      value: function removeAttr(attr) {}

      /**
       * Sets the text content for the helper text element.
       * @param {string} content
       */

    }, {
      key: "setContent",
      value: function setContent(content) {}
    }]);
    return MDCTextFieldHelperTextAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings$j = {
    ARIA_HIDDEN: 'aria-hidden',
    ROLE: 'role'
  };

  /** @enum {string} */
  var cssClasses$k = {
    HELPER_TEXT_PERSISTENT: 'mdc-text-field-helper-text--persistent',
    HELPER_TEXT_VALIDATION_MSG: 'mdc-text-field-helper-text--validation-msg'
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCTextFieldHelperTextAdapter>}
   * @final
   */

  var MDCTextFieldHelperTextFoundation = function (_MDCFoundation) {
    inherits(MDCTextFieldHelperTextFoundation, _MDCFoundation);
    createClass(MDCTextFieldHelperTextFoundation, null, [{
      key: 'cssClasses',

      /** @return enum {string} */
      get: function get$$1() {
        return cssClasses$k;
      }

      /** @return enum {string} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$j;
      }

      /**
       * {@see MDCTextFieldHelperTextAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCTextFieldHelperTextAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCTextFieldHelperTextAdapter} */{
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {},
            setAttr: function setAttr() {},
            removeAttr: function removeAttr() {},
            setContent: function setContent() {}
          }
        );
      }

      /**
       * @param {!MDCTextFieldHelperTextAdapter} adapter
       */

    }]);

    function MDCTextFieldHelperTextFoundation(adapter) {
      classCallCheck(this, MDCTextFieldHelperTextFoundation);
      return possibleConstructorReturn(this, (MDCTextFieldHelperTextFoundation.__proto__ || Object.getPrototypeOf(MDCTextFieldHelperTextFoundation)).call(this, _extends(MDCTextFieldHelperTextFoundation.defaultAdapter, adapter)));
    }

    /**
     * Sets the content of the helper text field.
     * @param {string} content
     */


    createClass(MDCTextFieldHelperTextFoundation, [{
      key: 'setContent',
      value: function setContent(content) {
        this.adapter_.setContent(content);
      }

      /** @param {boolean} isPersistent Sets the persistency of the helper text. */

    }, {
      key: 'setPersistent',
      value: function setPersistent(isPersistent) {
        if (isPersistent) {
          this.adapter_.addClass(cssClasses$k.HELPER_TEXT_PERSISTENT);
        } else {
          this.adapter_.removeClass(cssClasses$k.HELPER_TEXT_PERSISTENT);
        }
      }

      /**
       * @param {boolean} isValidation True to make the helper text act as an
       *   error validation message.
       */

    }, {
      key: 'setValidation',
      value: function setValidation(isValidation) {
        if (isValidation) {
          this.adapter_.addClass(cssClasses$k.HELPER_TEXT_VALIDATION_MSG);
        } else {
          this.adapter_.removeClass(cssClasses$k.HELPER_TEXT_VALIDATION_MSG);
        }
      }

      /** Makes the helper text visible to the screen reader. */

    }, {
      key: 'showToScreenReader',
      value: function showToScreenReader() {
        this.adapter_.removeAttr(strings$j.ARIA_HIDDEN);
      }

      /**
       * Sets the validity of the helper text based on the input validity.
       * @param {boolean} inputIsValid
       */

    }, {
      key: 'setValidity',
      value: function setValidity(inputIsValid) {
        var helperTextIsPersistent = this.adapter_.hasClass(cssClasses$k.HELPER_TEXT_PERSISTENT);
        var helperTextIsValidationMsg = this.adapter_.hasClass(cssClasses$k.HELPER_TEXT_VALIDATION_MSG);
        var validationMsgNeedsDisplay = helperTextIsValidationMsg && !inputIsValid;

        if (validationMsgNeedsDisplay) {
          this.adapter_.setAttr(strings$j.ROLE, 'alert');
        } else {
          this.adapter_.removeAttr(strings$j.ROLE);
        }

        if (!helperTextIsPersistent && !validationMsgNeedsDisplay) {
          this.hide_();
        }
      }

      /**
       * Hides the help text from screen readers.
       * @private
       */

    }, {
      key: 'hide_',
      value: function hide_() {
        this.adapter_.setAttr(strings$j.ARIA_HIDDEN, 'true');
      }
    }]);
    return MDCTextFieldHelperTextFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Text Field Icon.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the text field icon into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCTextFieldIconAdapter = function () {
    function MDCTextFieldIconAdapter() {
      classCallCheck(this, MDCTextFieldIconAdapter);
    }

    createClass(MDCTextFieldIconAdapter, [{
      key: "getAttr",

      /**
       * Gets the value of an attribute on the icon element.
       * @param {string} attr
       * @return {string}
       */
      value: function getAttr(attr) {}

      /**
       * Sets an attribute on the icon element.
       * @param {string} attr
       * @param {string} value
       */

    }, {
      key: "setAttr",
      value: function setAttr(attr, value) {}

      /**
       * Removes an attribute from the icon element.
       * @param {string} attr
       */

    }, {
      key: "removeAttr",
      value: function removeAttr(attr) {}

      /**
       * Sets the text content of the icon element.
       * @param {string} content
       */

    }, {
      key: "setContent",
      value: function setContent(content) {}

      /**
       * Registers an event listener on the icon element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(evtType, handler) {}

      /**
       * Deregisters an event listener on the icon element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(evtType, handler) {}

      /**
       * Emits a custom event "MDCTextField:icon" denoting a user has clicked the icon.
       */

    }, {
      key: "notifyIconAction",
      value: function notifyIconAction() {}
    }]);
    return MDCTextFieldIconAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings$k = {
    ICON_EVENT: 'MDCTextField:icon',
    ICON_ROLE: 'button'
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCTextFieldIconAdapter>}
   * @final
   */

  var MDCTextFieldIconFoundation = function (_MDCFoundation) {
    inherits(MDCTextFieldIconFoundation, _MDCFoundation);
    createClass(MDCTextFieldIconFoundation, null, [{
      key: 'strings',

      /** @return enum {string} */
      get: function get$$1() {
        return strings$k;
      }

      /**
       * {@see MDCTextFieldIconAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCTextFieldIconAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCTextFieldIconAdapter} */{
            getAttr: function getAttr() {},
            setAttr: function setAttr() {},
            removeAttr: function removeAttr() {},
            setContent: function setContent() {},
            registerInteractionHandler: function registerInteractionHandler() {},
            deregisterInteractionHandler: function deregisterInteractionHandler() {},
            notifyIconAction: function notifyIconAction() {}
          }
        );
      }

      /**
       * @param {!MDCTextFieldIconAdapter} adapter
       */

    }]);

    function MDCTextFieldIconFoundation(adapter) {
      classCallCheck(this, MDCTextFieldIconFoundation);

      /** @private {string?} */
      var _this = possibleConstructorReturn(this, (MDCTextFieldIconFoundation.__proto__ || Object.getPrototypeOf(MDCTextFieldIconFoundation)).call(this, _extends(MDCTextFieldIconFoundation.defaultAdapter, adapter)));

      _this.savedTabIndex_ = null;

      /** @private {function(!Event): undefined} */
      _this.interactionHandler_ = function (evt) {
        return _this.handleInteraction(evt);
      };
      return _this;
    }

    createClass(MDCTextFieldIconFoundation, [{
      key: 'init',
      value: function init() {
        var _this2 = this;

        this.savedTabIndex_ = this.adapter_.getAttr('tabindex');

        ['click', 'keydown'].forEach(function (evtType) {
          _this2.adapter_.registerInteractionHandler(evtType, _this2.interactionHandler_);
        });
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this3 = this;

        ['click', 'keydown'].forEach(function (evtType) {
          _this3.adapter_.deregisterInteractionHandler(evtType, _this3.interactionHandler_);
        });
      }

      /** @param {boolean} disabled */

    }, {
      key: 'setDisabled',
      value: function setDisabled(disabled) {
        if (!this.savedTabIndex_) {
          return;
        }

        if (disabled) {
          this.adapter_.setAttr('tabindex', '-1');
          this.adapter_.removeAttr('role');
        } else {
          this.adapter_.setAttr('tabindex', this.savedTabIndex_);
          this.adapter_.setAttr('role', strings$k.ICON_ROLE);
        }
      }

      /** @param {string} label */

    }, {
      key: 'setAriaLabel',
      value: function setAriaLabel(label) {
        this.adapter_.setAttr('aria-label', label);
      }

      /** @param {string} content */

    }, {
      key: 'setContent',
      value: function setContent(content) {
        this.adapter_.setContent(content);
      }

      /**
       * Handles an interaction event
       * @param {!Event} evt
       */

    }, {
      key: 'handleInteraction',
      value: function handleInteraction(evt) {
        if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
          this.adapter_.notifyIconAction();
        }
      }
    }]);
    return MDCTextFieldIconFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Adapter for MDC Text Field.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Text Field into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */

  var MDCTextFieldAdapter = function () {
    function MDCTextFieldAdapter() {
      classCallCheck(this, MDCTextFieldAdapter);
    }

    createClass(MDCTextFieldAdapter, [{
      key: 'addClass',

      /**
       * Adds a class to the root Element.
       * @param {string} className
       */
      value: function addClass(className) {}

      /**
       * Removes a class from the root Element.
       * @param {string} className
       */

    }, {
      key: 'removeClass',
      value: function removeClass(className) {}

      /**
       * Returns true if the root element contains the given class name.
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: 'hasClass',
      value: function hasClass(className) {}

      /**
       * Registers an event handler on the root element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: 'registerTextFieldInteractionHandler',
      value: function registerTextFieldInteractionHandler(type, handler) {}

      /**
       * Deregisters an event handler on the root element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: 'deregisterTextFieldInteractionHandler',
      value: function deregisterTextFieldInteractionHandler(type, handler) {}

      /**
       * Registers an event listener on the native input element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: 'registerInputInteractionHandler',
      value: function registerInputInteractionHandler(evtType, handler) {}

      /**
       * Deregisters an event listener on the native input element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: 'deregisterInputInteractionHandler',
      value: function deregisterInputInteractionHandler(evtType, handler) {}

      /**
       * Registers a validation attribute change listener on the input element.
       * Handler accepts list of attribute names.
       * @param {function(!Array<string>): undefined} handler
       * @return {!MutationObserver}
       */

    }, {
      key: 'registerValidationAttributeChangeHandler',
      value: function registerValidationAttributeChangeHandler(handler) {}

      /**
       * Disconnects a validation attribute observer on the input element.
       * @param {!MutationObserver} observer
       */

    }, {
      key: 'deregisterValidationAttributeChangeHandler',
      value: function deregisterValidationAttributeChangeHandler(observer) {}

      /**
       * Returns an object representing the native text input element, with a
       * similar API shape. The object returned should include the value, disabled
       * and badInput properties, as well as the checkValidity() function. We never
       * alter the value within our code, however we do update the disabled
       * property, so if you choose to duck-type the return value for this method
       * in your implementation it's important to keep this in mind. Also note that
       * this method can return null, which the foundation will handle gracefully.
       * @return {?Element|?NativeInputType}
       */

    }, {
      key: 'getNativeInput',
      value: function getNativeInput() {}

      /**
       * Returns true if the textfield is focused.
       * We achieve this via `document.activeElement === this.root_`.
       * @return {boolean}
       */

    }, {
      key: 'isFocused',
      value: function isFocused() {}

      /**
       * Returns true if the direction of the root element is set to RTL.
       * @return {boolean}
       */

    }, {
      key: 'isRtl',
      value: function isRtl() {}

      /**
       * Activates the line ripple.
       */

    }, {
      key: 'activateLineRipple',
      value: function activateLineRipple() {}

      /**
       * Deactivates the line ripple.
       */

    }, {
      key: 'deactivateLineRipple',
      value: function deactivateLineRipple() {}

      /**
       * Sets the transform origin of the line ripple.
       * @param {number} normalizedX
       */

    }, {
      key: 'setLineRippleTransformOrigin',
      value: function setLineRippleTransformOrigin(normalizedX) {}

      /**
       * Only implement if label exists.
       * Shakes label if shouldShake is true.
       * @param {boolean} shouldShake
       */

    }, {
      key: 'shakeLabel',
      value: function shakeLabel(shouldShake) {}

      /**
       * Only implement if label exists.
       * Floats the label above the input element if shouldFloat is true.
       * @param {boolean} shouldFloat
       */

    }, {
      key: 'floatLabel',
      value: function floatLabel(shouldFloat) {}

      /**
       * Returns true if label element exists, false if it doesn't.
       * @return {boolean}
       */

    }, {
      key: 'hasLabel',
      value: function hasLabel() {}

      /**
       * Only implement if label exists.
       * Returns width of label in pixels.
       * @return {number}
       */

    }, {
      key: 'getLabelWidth',
      value: function getLabelWidth() {}

      /**
       * Returns true if outline element exists, false if it doesn't.
       * @return {boolean}
       */

    }, {
      key: 'hasOutline',
      value: function hasOutline() {}

      /**
       * Only implement if outline element exists.
       * Updates SVG Path and outline element based on the
       * label element width and RTL context.
       * @param {number} labelWidth
       * @param {boolean=} isRtl
       */

    }, {
      key: 'notchOutline',
      value: function notchOutline(labelWidth, isRtl) {}

      /**
       * Only implement if outline element exists.
       * Closes notch in outline element.
       */

    }, {
      key: 'closeOutline',
      value: function closeOutline() {}
    }]);
    return MDCTextFieldAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var strings$l = {
    ARIA_CONTROLS: 'aria-controls',
    INPUT_SELECTOR: '.mdc-text-field__input',
    LABEL_SELECTOR: '.mdc-floating-label',
    ICON_SELECTOR: '.mdc-text-field__icon',
    OUTLINE_SELECTOR: '.mdc-notched-outline',
    LINE_RIPPLE_SELECTOR: '.mdc-line-ripple'
  };

  /** @enum {string} */
  var cssClasses$l = {
    ROOT: 'mdc-text-field',
    UPGRADED: 'mdc-text-field--upgraded',
    DISABLED: 'mdc-text-field--disabled',
    DENSE: 'mdc-text-field--dense',
    FOCUSED: 'mdc-text-field--focused',
    INVALID: 'mdc-text-field--invalid',
    BOX: 'mdc-text-field--box',
    OUTLINED: 'mdc-text-field--outlined'
  };

  /** @enum {number} */
  var numbers$6 = {
    LABEL_SCALE: 0.75,
    DENSE_LABEL_SCALE: 0.923
  };

  // whitelist based off of https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation
  // under section: `Validation-related attributes`
  var VALIDATION_ATTR_WHITELIST = ['pattern', 'min', 'max', 'required', 'step', 'minlength', 'maxlength'];

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCTextFieldAdapter>}
   * @final
   */

  var MDCTextFieldFoundation = function (_MDCFoundation) {
    inherits(MDCTextFieldFoundation, _MDCFoundation);
    createClass(MDCTextFieldFoundation, [{
      key: 'shouldShake',


      /** @return {boolean} */
      get: function get$$1() {
        return !this.isValid() && !this.isFocused_;
      }

      /** @return {boolean} */

    }, {
      key: 'shouldFloat',
      get: function get$$1() {
        return this.isFocused_ || !!this.getValue() || this.isBadInput_();
      }

      /**
       * {@see MDCTextFieldAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCTextFieldAdapter}
       */

    }], [{
      key: 'cssClasses',

      /** @return enum {string} */
      get: function get$$1() {
        return cssClasses$l;
      }

      /** @return enum {string} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$l;
      }

      /** @return enum {string} */

    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers$6;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCTextFieldAdapter} */{
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {},
            registerTextFieldInteractionHandler: function registerTextFieldInteractionHandler() {},
            deregisterTextFieldInteractionHandler: function deregisterTextFieldInteractionHandler() {},
            registerInputInteractionHandler: function registerInputInteractionHandler() {},
            deregisterInputInteractionHandler: function deregisterInputInteractionHandler() {},
            registerValidationAttributeChangeHandler: function registerValidationAttributeChangeHandler() {},
            deregisterValidationAttributeChangeHandler: function deregisterValidationAttributeChangeHandler() {},
            getNativeInput: function getNativeInput() {},
            isFocused: function isFocused() {},
            isRtl: function isRtl() {},
            activateLineRipple: function activateLineRipple() {},
            deactivateLineRipple: function deactivateLineRipple() {},
            setLineRippleTransformOrigin: function setLineRippleTransformOrigin() {},
            shakeLabel: function shakeLabel() {},
            floatLabel: function floatLabel() {},
            hasLabel: function hasLabel() {},
            getLabelWidth: function getLabelWidth() {},
            hasOutline: function hasOutline() {},
            notchOutline: function notchOutline() {},
            closeOutline: function closeOutline() {}
          }
        );
      }

      /**
       * @param {!MDCTextFieldAdapter} adapter
       * @param {!FoundationMapType=} foundationMap Map from subcomponent names to their subfoundations.
       */

    }]);

    function MDCTextFieldFoundation(adapter) {
      var foundationMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /** @type {!FoundationMapType} */{};
      classCallCheck(this, MDCTextFieldFoundation);

      /** @type {!MDCTextFieldHelperTextFoundation|undefined} */
      var _this = possibleConstructorReturn(this, (MDCTextFieldFoundation.__proto__ || Object.getPrototypeOf(MDCTextFieldFoundation)).call(this, _extends(MDCTextFieldFoundation.defaultAdapter, adapter)));

      _this.helperText_ = foundationMap.helperText;
      /** @type {!MDCTextFieldIconFoundation|undefined} */
      _this.icon_ = foundationMap.icon;

      /** @private {boolean} */
      _this.isFocused_ = false;
      /** @private {boolean} */
      _this.receivedUserInput_ = false;
      /** @private {boolean} */
      _this.useCustomValidityChecking_ = false;
      /** @private {boolean} */
      _this.isValid_ = true;
      /** @private {function(): undefined} */
      _this.inputFocusHandler_ = function () {
        return _this.activateFocus();
      };
      /** @private {function(): undefined} */
      _this.inputBlurHandler_ = function () {
        return _this.deactivateFocus();
      };
      /** @private {function(): undefined} */
      _this.inputInputHandler_ = function () {
        return _this.autoCompleteFocus();
      };
      /** @private {function(!Event): undefined} */
      _this.setPointerXOffset_ = function (evt) {
        return _this.setTransformOrigin(evt);
      };
      /** @private {function(!Event): undefined} */
      _this.textFieldInteractionHandler_ = function () {
        return _this.handleTextFieldInteraction();
      };
      /** @private {function(!Array): undefined} */
      _this.validationAttributeChangeHandler_ = function (attributesList) {
        return _this.handleValidationAttributeChange(attributesList);
      };

      /** @private {!MutationObserver} */
      _this.validationObserver_;
      return _this;
    }

    createClass(MDCTextFieldFoundation, [{
      key: 'init',
      value: function init() {
        var _this2 = this;

        this.adapter_.addClass(MDCTextFieldFoundation.cssClasses.UPGRADED);
        // Ensure label does not collide with any pre-filled value.
        if (this.adapter_.hasLabel() && (this.getValue() || this.isBadInput_())) {
          this.adapter_.floatLabel(this.shouldFloat);
          this.notchOutline(this.shouldFloat);
        }

        if (this.adapter_.isFocused()) {
          this.inputFocusHandler_();
        }

        this.adapter_.registerInputInteractionHandler('focus', this.inputFocusHandler_);
        this.adapter_.registerInputInteractionHandler('blur', this.inputBlurHandler_);
        this.adapter_.registerInputInteractionHandler('input', this.inputInputHandler_);
        ['mousedown', 'touchstart'].forEach(function (evtType) {
          _this2.adapter_.registerInputInteractionHandler(evtType, _this2.setPointerXOffset_);
        });
        ['click', 'keydown'].forEach(function (evtType) {
          _this2.adapter_.registerTextFieldInteractionHandler(evtType, _this2.textFieldInteractionHandler_);
        });
        this.validationObserver_ = this.adapter_.registerValidationAttributeChangeHandler(this.validationAttributeChangeHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this3 = this;

        this.adapter_.removeClass(MDCTextFieldFoundation.cssClasses.UPGRADED);
        this.adapter_.deregisterInputInteractionHandler('focus', this.inputFocusHandler_);
        this.adapter_.deregisterInputInteractionHandler('blur', this.inputBlurHandler_);
        this.adapter_.deregisterInputInteractionHandler('input', this.inputInputHandler_);
        ['mousedown', 'touchstart'].forEach(function (evtType) {
          _this3.adapter_.deregisterInputInteractionHandler(evtType, _this3.setPointerXOffset_);
        });
        ['click', 'keydown'].forEach(function (evtType) {
          _this3.adapter_.deregisterTextFieldInteractionHandler(evtType, _this3.textFieldInteractionHandler_);
        });
        this.adapter_.deregisterValidationAttributeChangeHandler(this.validationObserver_);
      }

      /**
       * Handles user interactions with the Text Field.
       */

    }, {
      key: 'handleTextFieldInteraction',
      value: function handleTextFieldInteraction() {
        if (this.adapter_.getNativeInput().disabled) {
          return;
        }
        this.receivedUserInput_ = true;
      }

      /**
       * Handles validation attribute changes
       * @param {!Array<string>} attributesList
       */

    }, {
      key: 'handleValidationAttributeChange',
      value: function handleValidationAttributeChange(attributesList) {
        var _this4 = this;

        attributesList.some(function (attributeName) {
          if (VALIDATION_ATTR_WHITELIST.indexOf(attributeName) > -1) {
            _this4.styleValidity_(true);
            return true;
          }
        });
      }

      /**
       * Opens/closes the notched outline.
       * @param {boolean} openNotch
       */

    }, {
      key: 'notchOutline',
      value: function notchOutline(openNotch) {
        if (!this.adapter_.hasOutline() || !this.adapter_.hasLabel()) {
          return;
        }

        if (openNotch) {
          var isDense = this.adapter_.hasClass(cssClasses$l.DENSE);
          var labelScale = isDense ? numbers$6.DENSE_LABEL_SCALE : numbers$6.LABEL_SCALE;
          var labelWidth = this.adapter_.getLabelWidth() * labelScale;
          var isRtl = this.adapter_.isRtl();
          this.adapter_.notchOutline(labelWidth, isRtl);
        } else {
          this.adapter_.closeOutline();
        }
      }

      /**
       * Activates the text field focus state.
       */

    }, {
      key: 'activateFocus',
      value: function activateFocus() {
        this.isFocused_ = true;
        this.styleFocused_(this.isFocused_);
        this.adapter_.activateLineRipple();
        this.notchOutline(this.shouldFloat);
        if (this.adapter_.hasLabel()) {
          this.adapter_.shakeLabel(this.shouldShake);
          this.adapter_.floatLabel(this.shouldFloat);
        }
        if (this.helperText_) {
          this.helperText_.showToScreenReader();
        }
      }

      /**
       * Sets the line ripple's transform origin, so that the line ripple activate
       * animation will animate out from the user's click location.
       * @param {!Event} evt
       */

    }, {
      key: 'setTransformOrigin',
      value: function setTransformOrigin(evt) {
        var targetClientRect = evt.target.getBoundingClientRect();
        var evtCoords = { x: evt.clientX, y: evt.clientY };
        var normalizedX = evtCoords.x - targetClientRect.left;
        this.adapter_.setLineRippleTransformOrigin(normalizedX);
      }

      /**
       * Activates the Text Field's focus state in cases when the input value
       * changes without user input (e.g. programatically).
       */

    }, {
      key: 'autoCompleteFocus',
      value: function autoCompleteFocus() {
        if (!this.receivedUserInput_) {
          this.activateFocus();
        }
      }

      /**
       * Deactivates the Text Field's focus state.
       */

    }, {
      key: 'deactivateFocus',
      value: function deactivateFocus() {
        this.isFocused_ = false;
        this.adapter_.deactivateLineRipple();
        var input = this.getNativeInput_();
        var shouldRemoveLabelFloat = !input.value && !this.isBadInput_();
        var isValid = this.isValid();
        this.styleValidity_(isValid);
        this.styleFocused_(this.isFocused_);
        if (this.adapter_.hasLabel()) {
          this.adapter_.shakeLabel(this.shouldShake);
          this.adapter_.floatLabel(this.shouldFloat);
          this.notchOutline(this.shouldFloat);
        }
        if (shouldRemoveLabelFloat) {
          this.receivedUserInput_ = false;
        }
      }

      /**
       * @return {string} The value of the input Element.
       */

    }, {
      key: 'getValue',
      value: function getValue() {
        return this.getNativeInput_().value;
      }

      /**
       * @param {string} value The value to set on the input Element.
       */

    }, {
      key: 'setValue',
      value: function setValue(value) {
        this.getNativeInput_().value = value;
        var isValid = this.isValid();
        this.styleValidity_(isValid);
        if (this.adapter_.hasLabel()) {
          this.adapter_.shakeLabel(this.shouldShake);
          this.adapter_.floatLabel(this.shouldFloat);
          this.notchOutline(this.shouldFloat);
        }
      }

      /**
       * @return {boolean} If a custom validity is set, returns that value.
       *     Otherwise, returns the result of native validity checks.
       */

    }, {
      key: 'isValid',
      value: function isValid() {
        return this.useCustomValidityChecking_ ? this.isValid_ : this.isNativeInputValid_();
      }

      /**
       * @param {boolean} isValid Sets the validity state of the Text Field.
       */

    }, {
      key: 'setValid',
      value: function setValid(isValid) {
        this.useCustomValidityChecking_ = true;
        this.isValid_ = isValid;
        // Retrieve from the getter to ensure correct logic is applied.
        isValid = this.isValid();
        this.styleValidity_(isValid);
        if (this.adapter_.hasLabel()) {
          this.adapter_.shakeLabel(this.shouldShake);
        }
      }

      /**
       * @return {boolean} True if the Text Field is disabled.
       */

    }, {
      key: 'isDisabled',
      value: function isDisabled() {
        return this.getNativeInput_().disabled;
      }

      /**
       * @param {boolean} disabled Sets the text-field disabled or enabled.
       */

    }, {
      key: 'setDisabled',
      value: function setDisabled(disabled) {
        this.getNativeInput_().disabled = disabled;
        this.styleDisabled_(disabled);
      }

      /**
       * @param {string} content Sets the content of the helper text.
       */

    }, {
      key: 'setHelperTextContent',
      value: function setHelperTextContent(content) {
        if (this.helperText_) {
          this.helperText_.setContent(content);
        }
      }

      /**
       * Sets the aria label of the icon.
       * @param {string} label
       */

    }, {
      key: 'setIconAriaLabel',
      value: function setIconAriaLabel(label) {
        if (this.icon_) {
          this.icon_.setAriaLabel(label);
        }
      }

      /**
       * Sets the text content of the icon.
       * @param {string} content
       */

    }, {
      key: 'setIconContent',
      value: function setIconContent(content) {
        if (this.icon_) {
          this.icon_.setContent(content);
        }
      }

      /**
       * @return {boolean} True if the Text Field input fails in converting the
       *     user-supplied value.
       * @private
       */

    }, {
      key: 'isBadInput_',
      value: function isBadInput_() {
        return this.getNativeInput_().validity.badInput;
      }

      /**
       * @return {boolean} The result of native validity checking
       *     (ValidityState.valid).
       */

    }, {
      key: 'isNativeInputValid_',
      value: function isNativeInputValid_() {
        return this.getNativeInput_().validity.valid;
      }

      /**
       * Styles the component based on the validity state.
       * @param {boolean} isValid
       * @private
       */

    }, {
      key: 'styleValidity_',
      value: function styleValidity_(isValid) {
        var INVALID = MDCTextFieldFoundation.cssClasses.INVALID;

        if (isValid) {
          this.adapter_.removeClass(INVALID);
        } else {
          this.adapter_.addClass(INVALID);
        }
        if (this.helperText_) {
          this.helperText_.setValidity(isValid);
        }
      }

      /**
       * Styles the component based on the focused state.
       * @param {boolean} isFocused
       * @private
       */

    }, {
      key: 'styleFocused_',
      value: function styleFocused_(isFocused) {
        var FOCUSED = MDCTextFieldFoundation.cssClasses.FOCUSED;

        if (isFocused) {
          this.adapter_.addClass(FOCUSED);
        } else {
          this.adapter_.removeClass(FOCUSED);
        }
      }

      /**
       * Styles the component based on the disabled state.
       * @param {boolean} isDisabled
       * @private
       */

    }, {
      key: 'styleDisabled_',
      value: function styleDisabled_(isDisabled) {
        var _MDCTextFieldFoundati = MDCTextFieldFoundation.cssClasses,
            DISABLED = _MDCTextFieldFoundati.DISABLED,
            INVALID = _MDCTextFieldFoundati.INVALID;

        if (isDisabled) {
          this.adapter_.addClass(DISABLED);
          this.adapter_.removeClass(INVALID);
        } else {
          this.adapter_.removeClass(DISABLED);
        }
        if (this.icon_) {
          this.icon_.setDisabled(isDisabled);
        }
      }

      /**
       * @return {!Element|!NativeInputType} The native text input from the
       * host environment, or a dummy if none exists.
       * @private
       */

    }, {
      key: 'getNativeInput_',
      value: function getNativeInput_() {
        return this.adapter_.getNativeInput() ||
        /** @type {!NativeInputType} */{
          value: '',
          disabled: false,
          validity: {
            badInput: false,
            valid: true
          }
        };
      }
    }]);
    return MDCTextFieldFoundation;
  }(MDCFoundation);

  var mdcTextField = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-textfield-wrapper", style: { width: _vm.fullwidth ? '100%' : undefined }, attrs: { "id": _vm.id } }, [_c('div', { ref: "root", class: _vm.rootClasses }, [!!_vm.hasLeadingIcon ? _c('i', { ref: "icon", staticClass: "mdc-text-field__icon", class: _vm.hasLeadingIcon.classes, attrs: { "tabindex": "0" } }, [_vm._t("leading-icon", [_vm._v(_vm._s(_vm.hasLeadingIcon.content))])], 2) : _vm._e(), _vm._v(" "), _vm.multiline ? _c('textarea', _vm._g(_vm._b({ ref: "input", class: _vm.inputClasses, attrs: { "id": _vm.vma_uid_, "minlength": _vm.minlength, "maxlength": _vm.maxlength, "placeholder": _vm.inputPlaceHolder, "aria-label": _vm.inputPlaceHolder, "aria-controls": _vm.inputAriaControls, "rows": _vm.rows, "cols": _vm.cols }, on: { "input": function input($event) {
            _vm.updateValue($event.target.value);
          } } }, 'textarea', _vm.$attrs, false), _vm.$listeners)) : _c('input', _vm._g(_vm._b({ ref: "input", class: _vm.inputClasses, attrs: { "id": _vm.vma_uid_, "type": _vm.type, "minlength": _vm.minlength, "maxlength": _vm.maxlength, "placeholder": _vm.inputPlaceHolder, "aria-label": _vm.inputPlaceHolder, "aria-controls": _vm.inputAriaControls }, on: { "input": function input($event) {
            _vm.updateValue($event.target.value);
          } } }, 'input', _vm.$attrs, false), _vm.$listeners)), _vm._v(" "), _vm.hasLabel ? _c('label', { ref: "label", class: _vm.labelClassesUpgraded, attrs: { "for": _vm.vma_uid_ } }, [_vm._v(" " + _vm._s(_vm.label) + " ")]) : _vm._e(), _vm._v(" "), !!_vm.hasTrailingIcon ? _c('i', { ref: "icon", staticClass: "mdc-text-field__icon", class: _vm.hasTrailingIcon.classes, attrs: { "tabindex": "0" } }, [_vm._t("trailing-icon", [_vm._v(_vm._s(_vm.hasTrailingIcon.content))])], 2) : _vm._e(), _vm._v(" "), _vm.hasOutline ? _c('div', { ref: "outline", staticClass: "mdc-notched-outline", class: _vm.outlineClasses }, [_c('svg', [_c('path', { staticClass: "mdc-notched-outline__path", attrs: { "d": _vm.outlinePathAttr } })])]) : _vm._e(), _vm._v(" "), _vm.hasOutline ? _c('div', { ref: "outlineIdle", staticClass: "mdc-notched-outline__idle" }) : _vm._e(), _vm._v(" "), _vm.hasLineRipple ? _c('div', { ref: "lineRipple", class: _vm.lineRippleClasses, style: _vm.lineRippleStyles }) : _vm._e()]), _vm._v(" "), _vm.helptext ? _c('p', { ref: "help", class: _vm.helpClasses, attrs: { "id": 'help-' + _vm.vma_uid_, "aria-hidden": "true" } }, [_vm._v(" " + _vm._s(_vm.helptext) + " ")]) : _vm._e()]);
    }, staticRenderFns: [],
    name: 'mdc-textfield',
    mixins: [CustomElementMixin, DispatchFocusMixin, VMAUniqueIdMixin],
    inheritAttrs: false,
    model: {
      prop: 'value',
      event: 'model'
    },
    props: {
      value: String,
      type: {
        type: String,
        default: 'text',
        validator: function validator(value) {
          return ['text', 'email', 'search', 'password', 'tel', 'url', 'number'].indexOf(value) !== -1;
        }
      },
      dense: Boolean,
      label: String,
      helptext: String,
      helptextPersistent: Boolean,
      helptextValidation: Boolean,
      box: Boolean,
      outline: Boolean,
      disabled: Boolean,
      required: Boolean,
      valid: { type: Boolean, default: undefined },
      fullwidth: Boolean,
      multiline: Boolean,
      leadingIcon: [String, Array, Object],
      trailingIcon: [String, Array, Object],
      size: { type: [Number, String], default: 20 },
      minlength: { type: [Number, String], default: undefined },
      maxlength: { type: [Number, String], default: undefined },
      rows: { type: [Number, String], default: 8 },
      cols: { type: [Number, String], default: 40 },
      id: { type: String }
    },
    data: function data() {
      return {
        text: this.value,
        rootClasses: {
          'mdc-textfield': true,
          'mdc-text-field': true,
          'mdc-text-field--upgraded': true,
          'mdc-text-field--disabled': this.disabled,
          'mdc-text-field--dense': this.dense,
          'mdc-text-field--fullwidth': this.fullwidth,
          'mdc-text-field--textarea': this.multiline,
          'mdc-text-field--box': !this.fullwidth && this.box,
          'mdc-text-field--outlined': !this.fullwidth && this.outline
        },
        inputClasses: {
          'mdc-text-field__input': true
        },
        labelClasses: {
          'mdc-floating-label': true
        },
        lineRippleClasses: {
          'mdc-line-ripple': true
        },
        lineRippleStyles: {},
        helpClasses: {
          'mdc-text-field-helper-text': true,
          'mdc-text-field-helper-text--persistent': this.helptextPersistent,
          'mdc-text-field-helper-text--validation-msg': this.helptextValidation
        },
        outlineClasses: {},
        outlinePathAttr: undefined
      };
    },
    computed: {
      inputPlaceHolder: function inputPlaceHolder() {
        return this.fullwidth ? this.label : undefined;
      },
      inputAriaControls: function inputAriaControls() {
        return this.help ? 'help-' + this.vma_uid_ : undefined;
      },
      hasLabel: function hasLabel() {
        return !this.fullwidth && this.label;
      },
      hasOutline: function hasOutline() {
        return !this.fullwidth && this.outline;
      },
      hasLineRipple: function hasLineRipple() {
        return !this.hasOutline && !this.multiline;
      },
      hasLeadingIcon: function hasLeadingIcon() {
        if ((this.leadingIcon || this.$slots['leading-icon']) && !(this.trailingIcon || this.$slots['trailing-icon'])) {
          return this.leadingIcon ? extractIconProp(this.leadingIcon) : {};
        }
        return false;
      },
      hasTrailingIcon: function hasTrailingIcon() {
        if (this.trailingIcon || this.$slots['trailing-icon']) {
          return this.trailingIcon ? extractIconProp(this.trailingIcon) : {};
        }
        return false;
      },
      labelClassesUpgraded: function labelClassesUpgraded() {
        return _extends(this.labelClasses, {
          'mdc-floating-label--float-above': this.value
        });
      }
    },
    watch: {
      disabled: function disabled() {
        this.foundation && this.foundation.setDisabled(this.disabled);
      },
      required: function required() {
        this.$refs.input && (this.$refs.input.required = this.required);
      },
      valid: function valid() {
        if (typeof this.valid !== 'undefined') {
          this.foundation && this.foundation.setValid(this.valid);
        }
      },
      dense: function dense() {
        this.$set(this.rootClasses, 'mdc-text-field--dense', this.dense);
      },
      helptextPersistent: function helptextPersistent() {
        this.helperTextFoundation && this.helperTextFoundation.setPersistent(this.helptextPersistent);
      },
      helptextValidation: function helptextValidation() {
        this.helperTextFoundation && this.helperTextFoundation.setValidation(this.helptextValidation);
      },
      value: function value(_value) {
        if (this.foundation) {
          if (_value !== this.foundation.getValue()) {
            this.foundation.setValue(_value);
          }
        }
      }
    },
    mounted: function mounted() {
      var _this = this;

      if (this.$refs.lineRipple) {
        this.lineRippleFoundation = new MDCLineRippleFoundation({
          addClass: function addClass(className) {
            _this.$set(_this.lineRippleClasses, className, true);
          },
          removeClass: function removeClass(className) {
            _this.$delete(_this.lineRippleClasses, className);
          },
          hasClass: function hasClass(className) {
            _this.$refs.lineRipple.classList.contains(className);
          },
          setStyle: function setStyle(name, value) {
            _this.$set(_this.lineRippleStyles, name, value);
          },
          registerEventHandler: function registerEventHandler(evtType, handler) {
            _this.$refs.lineRipple.addEventListener(evtType, handler);
          },
          deregisterEventHandler: function deregisterEventHandler(evtType, handler) {
            _this.$refs.lineRipple.removeEventListener(evtType, handler);
          }
        });
        this.lineRippleFoundation.init();
      }

      if (this.$refs.help) {
        this.helperTextFoundation = new MDCTextFieldHelperTextFoundation({
          addClass: function addClass(className) {
            _this.$set(_this.helpClasses, className, true);
          },
          removeClass: function removeClass(className) {
            _this.$delete(_this.helpClasses, className);
          },
          hasClass: function hasClass(className) {
            return _this.$refs.help.classList.contains(className);
          },
          setAttr: function setAttr(name, value) {
            _this.$refs.help.setAttribute(name, value);
          },
          removeAttr: function removeAttr(name) {
            _this.$refs.help.removeAttribute(name);
          },
          setContent: function setContent() /*content*/{
            // help text get's updated from {{helptext}}
            // this.$refs.help.textContent = content;
          }
        });
        this.helperTextFoundation.init();
      }

      if (this.$refs.icon) {
        if (this.hasLeadingIcon) {
          this.$set(this.rootClasses, 'mdc-text-field--with-leading-icon', true);
        } else if (this.hasTrailingIcon) {
          this.$set(this.rootClasses, 'mdc-text-field--with-trailing-icon', true);
        }

        this.iconFoundation = new MDCTextFieldIconFoundation({
          setAttr: function setAttr(attr, value) {
            return _this.$refs.icon.setAttribute(attr, value);
          },
          getAttr: function getAttr(attr) {
            return _this.$refs.icon.getAttribute(attr);
          },
          removeAttr: function removeAttr(attr) {
            return _this.$refs.icon.removeAttribute(attr);
          },
          setContent: function setContent() /*content*/{
            // icon text get's updated from {{{{ hasTrailingIcon.content }}}}
            // this.$refs.icon.textContent = content;
          },
          registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
            _this.$refs.icon.addEventListener(evtType, handler);
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
            _this.$refs.icon.removeEventListener(evtType, handler);
          },
          notifyIconAction: function notifyIconAction() {
            return _this.$emit('icon-action');
          }
        });
        this.iconFoundation.init();
      }

      if (this.$refs.label) {
        this.labelFoundation = new MDCFloatingLabelFoundation({
          addClass: function addClass(className) {
            _this.$set(_this.labelClasses, className, true);
          },
          removeClass: function removeClass(className) {
            _this.$delete(_this.labelClasses, className);
          },
          getWidth: function getWidth() {
            return _this.$refs.label.offsetWidth;
          },
          registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
            _this.$refs.label.addEventListener(evtType, handler);
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
            _this.$refs.label.removeEventListener(evtType, handler);
          }
        });
        this.labelFoundation.init();
      }

      if (this.$refs.outline) {
        this.outlineFoundation = new MDCNotchedOutlineFoundation({
          getWidth: function getWidth() {
            return _this.$refs.outline.offsetWidth;
          },
          getHeight: function getHeight() {
            return _this.$refs.outline.offsetHeight;
          },
          addClass: function addClass(className) {
            _this.$set(_this.outlineClasses, className, true);
          },
          removeClass: function removeClass(className) {
            _this.$delete(_this.outlineClasses, className);
          },
          setOutlinePathAttr: function setOutlinePathAttr(value) {
            _this.outlinePathAttr = value;
          },
          getIdleOutlineStyleValue: function getIdleOutlineStyleValue(propertyName) {
            var idleOutlineElement = _this.$refs.outlineIdle;
            if (idleOutlineElement) {
              return window.getComputedStyle(idleOutlineElement).getPropertyValue(propertyName);
            }
          }
        });
        this.outlineFoundation.init();
      }

      this.foundation = new MDCTextFieldFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.rootClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.rootClasses, className);
        },
        hasClass: function hasClass(className) {
          _this.$refs.root.classList.contains(className);
        },
        registerTextFieldInteractionHandler: function registerTextFieldInteractionHandler(evtType, handler) {
          _this.$refs.root.addEventListener(evtType, handler);
        },
        deregisterTextFieldInteractionHandler: function deregisterTextFieldInteractionHandler(evtType, handler) {
          _this.$refs.root.removeEventListener(evtType, handler);
        },
        isFocused: function isFocused() {
          return document.activeElement === _this.$refs.input;
        },
        isRtl: function isRtl() {
          return window.getComputedStyle(_this.$refs.root).getPropertyValue('direction') === 'rtl';
        },
        deactivateLineRipple: function deactivateLineRipple() {
          if (_this.lineRippleFoundation) {
            _this.lineRippleFoundation.deactivate();
          }
        },
        activateLineRipple: function activateLineRipple() {
          if (_this.lineRippleFoundation) {
            _this.lineRippleFoundation.activate();
          }
        },
        setLineRippleTransformOrigin: function setLineRippleTransformOrigin(normalizedX) {
          if (_this.lineRippleFoundation) {
            _this.lineRippleFoundation.setRippleCenter(normalizedX);
          }
        },
        registerInputInteractionHandler: function registerInputInteractionHandler(evtType, handler) {
          _this.$refs.input.addEventListener(evtType, handler, applyPassive());
        },
        deregisterInputInteractionHandler: function deregisterInputInteractionHandler(evtType, handler) {
          _this.$refs.input.removeEventListener(evtType, handler, applyPassive());
        },
        registerValidationAttributeChangeHandler: function registerValidationAttributeChangeHandler(handler) {
          var getAttributesList = function getAttributesList(mutationsList) {
            return mutationsList.map(function (mutation) {
              return mutation.attributeName;
            });
          };
          var observer = new MutationObserver(function (mutationsList) {
            return handler(getAttributesList(mutationsList));
          });
          var targetNode = _this.$refs.input;
          var config = { attributes: true };
          observer.observe(targetNode, config);
          return observer;
        },
        deregisterValidationAttributeChangeHandler: function deregisterValidationAttributeChangeHandler(observer) {
          observer.disconnect();
        },
        shakeLabel: function shakeLabel(shouldShake) {
          _this.labelFoundation.shake(shouldShake);
        },
        floatLabel: function floatLabel(shouldFloat) {
          _this.labelFoundation.float(shouldFloat);
        },
        hasLabel: function hasLabel() {
          return !!_this.$refs.label;
        },
        getLabelWidth: function getLabelWidth() {
          return _this.labelFoundation.getWidth();
        },
        getNativeInput: function getNativeInput() {
          return _this.$refs.input;
        },
        hasOutline: function hasOutline() {
          return !!_this.hasOutline;
        },
        notchOutline: function notchOutline(notchWidth, isRtl) {
          return _this.outlineFoundation.notch(notchWidth, isRtl);
        },
        closeOutline: function closeOutline() {
          return _this.outlineFoundation.closeNotch();
        }
      }, {
        helperText: this.helperTextFoundation,
        icon: this.iconFoundation
      });

      this.foundation.init();
      this.foundation.setValue(this.value);
      this.foundation.setDisabled(this.disabled);
      this.$refs.input && (this.$refs.input.required = this.required);
      if (typeof this.valid !== 'undefined') {
        this.foundation.setValid(this.valid);
      }

      if (this.textbox) {
        this.ripple = new RippleBase(this);
        this.ripple.init();
      }
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation && this.foundation.destroy();
      this.lineRippleFoundation && this.lineRippleFoundation.destroy();
      this.helperTextFoundation && this.helperTextFoundation.destroy();
      this.iconFoundation && this.iconFoundation.destroy();
      this.labelFoundation && this.labelFoundation.destroy();
      this.outlineFoundation && this.outlineFoundation.destroy();
      this.ripple && this.ripple.destroy();
    },

    methods: {
      updateValue: function updateValue(value) {
        this.$emit('model', value);
      },
      focus: function focus() {
        this.$refs.input && this.$refs.input.focus();
      },
      blur: function blur() {
        this.$refs.input && this.$refs.input.blur();
      }
    }
  };

  var VueMDCTextfield = BasePlugin({
    mdcTextField: mdcTextField
  });

  var THEME_COLORS = ['primary', 'secondary', 'background', 'primary-light', 'secondary-light', 'secondary-dark', 'primary-dark'];

  var THEME_STYLES = ['text-primary', 'text-secondary', 'text-hint', 'text-icon', 'text-disabled'];

  var mdcTheme = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-element', { staticClass: "mdc-theme", class: _vm.classes, attrs: { "tag": _vm.tag } }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-theme',
    components: {
      CustomElement: CustomElement
    },
    props: {
      tag: { type: String, default: 'div' },
      color: String,
      background: String
    },
    computed: {
      classes: function classes() {
        var classes = {};

        if (this.color && THEME_COLORS.indexOf(this.color) !== -1) {
          classes['mdc-theme--' + this.color] = true;
        }

        if (this.background && THEME_COLORS.indexOf(this.background) !== -1) {
          classes['mdc-theme--' + this.background + '-bg'] = true;

          if (this.color && THEME_STYLES.indexOf(this.color) !== -1) {
            classes['mdc-theme--' + this.color + '-on-' + this.background] = true;
          }
        }
        return classes;
      }
    }
  };

  var VueMDCTheme = BasePlugin({
    mdcTheme: mdcTheme
  });

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$m = {
    FIXED: 'mdc-toolbar--fixed',
    FIXED_LASTROW: 'mdc-toolbar--fixed-lastrow-only',
    FIXED_AT_LAST_ROW: 'mdc-toolbar--fixed-at-last-row',
    TOOLBAR_ROW_FLEXIBLE: 'mdc-toolbar--flexible',
    FLEXIBLE_DEFAULT_BEHAVIOR: 'mdc-toolbar--flexible-default-behavior',
    FLEXIBLE_MAX: 'mdc-toolbar--flexible-space-maximized',
    FLEXIBLE_MIN: 'mdc-toolbar--flexible-space-minimized'
  };

  var strings$m = {
    TITLE_SELECTOR: '.mdc-toolbar__title',
    ICON_SELECTOR: '.mdc-toolbar__icon',
    FIRST_ROW_SELECTOR: '.mdc-toolbar__row:first-child',
    CHANGE_EVENT: 'MDCToolbar:change'
  };

  var numbers$7 = {
    MAX_TITLE_SIZE: 2.125,
    MIN_TITLE_SIZE: 1.25,
    TOOLBAR_ROW_HEIGHT: 64,
    TOOLBAR_ROW_MOBILE_HEIGHT: 56,
    TOOLBAR_MOBILE_BREAKPOINT: 600
  };

  /**
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCToolbarFoundation = function (_MDCFoundation) {
    inherits(MDCToolbarFoundation, _MDCFoundation);
    createClass(MDCToolbarFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$m;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$m;
      }
    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers$7;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          hasClass: function hasClass() {
            return (/* className: string */ /* boolean */false
            );
          },
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          registerScrollHandler: function registerScrollHandler() /* handler: EventListener */{},
          deregisterScrollHandler: function deregisterScrollHandler() /* handler: EventListener */{},
          registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
          deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
          getViewportWidth: function getViewportWidth() {
            return (/* number */0
            );
          },
          getViewportScrollY: function getViewportScrollY() {
            return (/* number */0
            );
          },
          getOffsetHeight: function getOffsetHeight() {
            return (/* number */0
            );
          },
          getFirstRowElementOffsetHeight: function getFirstRowElementOffsetHeight() {
            return (/* number */0
            );
          },
          notifyChange: function notifyChange() /* evtData: {flexibleExpansionRatio: number} */{},
          setStyle: function setStyle() /* property: string, value: string */{},
          setStyleForTitleElement: function setStyleForTitleElement() /* property: string, value: string */{},
          setStyleForFlexibleRowElement: function setStyleForFlexibleRowElement() /* property: string, value: string */{},
          setStyleForFixedAdjustElement: function setStyleForFixedAdjustElement() /* property: string, value: string */{}
        };
      }
    }]);

    function MDCToolbarFoundation(adapter) {
      classCallCheck(this, MDCToolbarFoundation);

      var _this = possibleConstructorReturn(this, (MDCToolbarFoundation.__proto__ || Object.getPrototypeOf(MDCToolbarFoundation)).call(this, _extends(MDCToolbarFoundation.defaultAdapter, adapter)));

      _this.resizeHandler_ = function () {
        return _this.checkRowHeight_();
      };
      _this.scrollHandler_ = function () {
        return _this.updateToolbarStyles_();
      };
      _this.checkRowHeightFrame_ = 0;
      _this.scrollFrame_ = 0;
      _this.executedLastChange_ = false;

      _this.calculations_ = {
        toolbarRowHeight: 0,
        // Calculated Height ratio. We use ratio to calculate corresponding heights in resize event.
        toolbarRatio: 0, // The ratio of toolbar height to row height
        flexibleExpansionRatio: 0, // The ratio of flexible space height to row height
        maxTranslateYRatio: 0, // The ratio of max toolbar move up distance to row height
        scrollThresholdRatio: 0, // The ratio of max scrollTop that we should listen to to row height
        // Derived Heights based on the above key ratios.
        toolbarHeight: 0,
        flexibleExpansionHeight: 0, // Flexible row minus toolbar height (derived)
        maxTranslateYDistance: 0, // When toolbar only fix last row (derived)
        scrollThreshold: 0
      };
      // Toolbar fixed behavior
      // If toolbar is fixed
      _this.fixed_ = false;
      // If fixed is targeted only at the last row
      _this.fixedLastrow_ = false;
      // Toolbar flexible behavior
      // If the first row is flexible
      _this.hasFlexibleRow_ = false;
      // If use the default behavior
      _this.useFlexDefaultBehavior_ = false;
      return _this;
    }

    createClass(MDCToolbarFoundation, [{
      key: 'init',
      value: function init() {
        this.fixed_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.FIXED);
        this.fixedLastrow_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.FIXED_LASTROW) & this.fixed_;
        this.hasFlexibleRow_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.TOOLBAR_ROW_FLEXIBLE);
        if (this.hasFlexibleRow_) {
          this.useFlexDefaultBehavior_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_DEFAULT_BEHAVIOR);
        }
        this.initKeyRatio_();
        this.setKeyHeights_();
        this.adapter_.registerResizeHandler(this.resizeHandler_);
        this.adapter_.registerScrollHandler(this.scrollHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterResizeHandler(this.resizeHandler_);
        this.adapter_.deregisterScrollHandler(this.scrollHandler_);
      }
    }, {
      key: 'updateAdjustElementStyles',
      value: function updateAdjustElementStyles() {
        if (this.fixed_) {
          this.adapter_.setStyleForFixedAdjustElement('margin-top', this.calculations_.toolbarHeight + 'px');
        }
      }
    }, {
      key: 'getFlexibleExpansionRatio_',
      value: function getFlexibleExpansionRatio_(scrollTop) {
        // To prevent division by zero when there is no flexibleExpansionHeight
        var delta = 0.0001;
        return Math.max(0, 1 - scrollTop / (this.calculations_.flexibleExpansionHeight + delta));
      }
    }, {
      key: 'checkRowHeight_',
      value: function checkRowHeight_() {
        var _this2 = this;

        cancelAnimationFrame(this.checkRowHeightFrame_);
        this.checkRowHeightFrame_ = requestAnimationFrame(function () {
          return _this2.setKeyHeights_();
        });
      }
    }, {
      key: 'setKeyHeights_',
      value: function setKeyHeights_() {
        var newToolbarRowHeight = this.getRowHeight_();
        if (newToolbarRowHeight !== this.calculations_.toolbarRowHeight) {
          this.calculations_.toolbarRowHeight = newToolbarRowHeight;
          this.calculations_.toolbarHeight = this.calculations_.toolbarRatio * this.calculations_.toolbarRowHeight;
          this.calculations_.flexibleExpansionHeight = this.calculations_.flexibleExpansionRatio * this.calculations_.toolbarRowHeight;
          this.calculations_.maxTranslateYDistance = this.calculations_.maxTranslateYRatio * this.calculations_.toolbarRowHeight;
          this.calculations_.scrollThreshold = this.calculations_.scrollThresholdRatio * this.calculations_.toolbarRowHeight;
          this.updateAdjustElementStyles();
          this.updateToolbarStyles_();
        }
      }
    }, {
      key: 'updateToolbarStyles_',
      value: function updateToolbarStyles_() {
        var _this3 = this;

        cancelAnimationFrame(this.scrollFrame_);
        this.scrollFrame_ = requestAnimationFrame(function () {
          var scrollTop = _this3.adapter_.getViewportScrollY();
          var hasScrolledOutOfThreshold = _this3.scrolledOutOfThreshold_(scrollTop);

          if (hasScrolledOutOfThreshold && _this3.executedLastChange_) {
            return;
          }

          var flexibleExpansionRatio = _this3.getFlexibleExpansionRatio_(scrollTop);

          _this3.updateToolbarFlexibleState_(flexibleExpansionRatio);
          if (_this3.fixedLastrow_) {
            _this3.updateToolbarFixedState_(scrollTop);
          }
          if (_this3.hasFlexibleRow_) {
            _this3.updateFlexibleRowElementStyles_(flexibleExpansionRatio);
          }
          _this3.executedLastChange_ = hasScrolledOutOfThreshold;
          _this3.adapter_.notifyChange({ flexibleExpansionRatio: flexibleExpansionRatio });
        });
      }
    }, {
      key: 'scrolledOutOfThreshold_',
      value: function scrolledOutOfThreshold_(scrollTop) {
        return scrollTop > this.calculations_.scrollThreshold;
      }
    }, {
      key: 'initKeyRatio_',
      value: function initKeyRatio_() {
        var toolbarRowHeight = this.getRowHeight_();
        var firstRowMaxRatio = this.adapter_.getFirstRowElementOffsetHeight() / toolbarRowHeight;
        this.calculations_.toolbarRatio = this.adapter_.getOffsetHeight() / toolbarRowHeight;
        this.calculations_.flexibleExpansionRatio = firstRowMaxRatio - 1;
        this.calculations_.maxTranslateYRatio = this.fixedLastrow_ ? this.calculations_.toolbarRatio - firstRowMaxRatio : 0;
        this.calculations_.scrollThresholdRatio = (this.fixedLastrow_ ? this.calculations_.toolbarRatio : firstRowMaxRatio) - 1;
      }
    }, {
      key: 'getRowHeight_',
      value: function getRowHeight_() {
        var breakpoint = MDCToolbarFoundation.numbers.TOOLBAR_MOBILE_BREAKPOINT;
        return this.adapter_.getViewportWidth() < breakpoint ? MDCToolbarFoundation.numbers.TOOLBAR_ROW_MOBILE_HEIGHT : MDCToolbarFoundation.numbers.TOOLBAR_ROW_HEIGHT;
      }
    }, {
      key: 'updateToolbarFlexibleState_',
      value: function updateToolbarFlexibleState_(flexibleExpansionRatio) {
        this.adapter_.removeClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MAX);
        this.adapter_.removeClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MIN);
        if (flexibleExpansionRatio === 1) {
          this.adapter_.addClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MAX);
        } else if (flexibleExpansionRatio === 0) {
          this.adapter_.addClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MIN);
        }
      }
    }, {
      key: 'updateToolbarFixedState_',
      value: function updateToolbarFixedState_(scrollTop) {
        var translateDistance = Math.max(0, Math.min(scrollTop - this.calculations_.flexibleExpansionHeight, this.calculations_.maxTranslateYDistance));
        this.adapter_.setStyle('transform', 'translateY(' + -translateDistance + 'px)');

        if (translateDistance === this.calculations_.maxTranslateYDistance) {
          this.adapter_.addClass(MDCToolbarFoundation.cssClasses.FIXED_AT_LAST_ROW);
        } else {
          this.adapter_.removeClass(MDCToolbarFoundation.cssClasses.FIXED_AT_LAST_ROW);
        }
      }
    }, {
      key: 'updateFlexibleRowElementStyles_',
      value: function updateFlexibleRowElementStyles_(flexibleExpansionRatio) {
        if (this.fixed_) {
          var height = this.calculations_.flexibleExpansionHeight * flexibleExpansionRatio;
          this.adapter_.setStyleForFlexibleRowElement('height', height + this.calculations_.toolbarRowHeight + 'px');
        }
        if (this.useFlexDefaultBehavior_) {
          this.updateElementStylesDefaultBehavior_(flexibleExpansionRatio);
        }
      }
    }, {
      key: 'updateElementStylesDefaultBehavior_',
      value: function updateElementStylesDefaultBehavior_(flexibleExpansionRatio) {
        var maxTitleSize = MDCToolbarFoundation.numbers.MAX_TITLE_SIZE;
        var minTitleSize = MDCToolbarFoundation.numbers.MIN_TITLE_SIZE;
        var currentTitleSize = (maxTitleSize - minTitleSize) * flexibleExpansionRatio + minTitleSize;

        this.adapter_.setStyleForTitleElement('font-size', currentTitleSize + 'rem');
      }
    }]);
    return MDCToolbarFoundation;
  }(MDCFoundation);

  var mdcToolbar = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('header', { staticClass: "mdc-toolbar-wrapper" }, [_c('div', { ref: "root", class: _vm.rootClasses, style: _vm.rootStyles }, [_vm._t("default")], 2), _vm._v(" "), _vm.fixed || _vm.waterfall || _vm.fixedLastrow ? _c('div', { ref: "fixed-adjust", staticClass: "mdc-toolbar-fixed-adjust", style: _vm.adjustStyles }) : _vm._e()]);
    }, staticRenderFns: [],
    name: 'mdc-toolbar',
    props: {
      fixed: Boolean,
      waterfall: Boolean,
      'fixed-lastrow': Boolean,
      flexible: Boolean,
      'flexible-default': { type: Boolean, default: true }
    },
    data: function data() {
      return {
        rootClasses: {
          'mdc-toolbar': true,
          'mdc-toolbar--fixed': this.fixed || this.waterfall || this.fixedLastrow,
          'mdc-toolbar--waterfall': this.waterfall,
          'mdc-toolbar--fixed-lastrow-only': this.fixedLastrow,
          'mdc-toolbar--flexible': this.flexible,
          'mdc-toolbar--flexible-default-behavior': this.flexible && this.flexibleDefault
        },
        rootStyles: {},
        adjustStyles: {
          // to avoid top margin collapse with :after el
          // 0.1 px should be rounded to 0px
          // TODO: find a better trick
          // height: '0.1px'
        },
        foundation: null
      };
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCToolbarFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.rootClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.rootClasses, className);
        },
        hasClass: function hasClass(className) {
          return _this.$refs.root.classList.contains(className);
        },
        registerScrollHandler: function registerScrollHandler(handler) {
          window.addEventListener('scroll', handler);
        },
        deregisterScrollHandler: function deregisterScrollHandler(handler) {
          window.removeEventListener('scroll', handler);
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          window.removeEventListener('resize', handler);
        },
        getViewportWidth: function getViewportWidth() {
          return window.innerWidth;
        },
        getViewportScrollY: function getViewportScrollY() {
          return window.pageYOffset;
        },
        getOffsetHeight: function getOffsetHeight() {
          return _this.$refs.root.offsetHeight;
        },
        getFirstRowElementOffsetHeight: function getFirstRowElementOffsetHeight() {
          var el = _this.$refs.root.querySelector(MDCToolbarFoundation.strings.FIRST_ROW_SELECTOR);
          return el ? el.offsetHeight : undefined;
        },
        notifyChange: function notifyChange(evtData) {
          _this.$emit('change', evtData);
        },
        setStyle: function setStyle(property, value) {
          _this.$set(_this.rootStyles, property, value);
        },
        setStyleForTitleElement: function setStyleForTitleElement(property, value) {
          var el = _this.$refs.root.querySelector(MDCToolbarFoundation.strings.TITLE_SELECTOR);
          if (el) el.style.setProperty(property, value);
        },
        setStyleForFlexibleRowElement: function setStyleForFlexibleRowElement(property, value) {
          var el = _this.$refs.root.querySelector(MDCToolbarFoundation.strings.FIRST_ROW_SELECTOR);
          if (el) el.style.setProperty(property, value);
        },
        setStyleForFixedAdjustElement: function setStyleForFixedAdjustElement(property, value) {
          _this.$set(_this.adjustStyles, property, value);
        }
      });
      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    }
  };

  var mdcToolbarRow = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-toolbar-row mdc-toolbar__row" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-toolbar-row'
  };

  var mdcToolbarSection = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('section', { staticClass: "mdc-toolbar-section mdc-toolbar__section", class: _vm.classes }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-toolbar-section',
    props: {
      'align-start': Boolean,
      'align-end': Boolean,
      'shrink-to-fit': Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-toolbar__section--align-start': this.alignStart,
          'mdc-toolbar__section--align-end': this.alignEnd,
          'mdc-toolbar__section--shrink-to-fit': this.shrinkToFit
        }
      };
    }
  };

  var mdcToolbarMenuIcon = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('a', _vm._g({ staticClass: "mdc-toolbar-menu-icon mdc-toolbar__menu-icon", class: { 'material-icons': !!_vm.icon } }, _vm.listeners), [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2);
    }, staticRenderFns: [],
    name: 'mdc-toolbar-menu-icon',
    mixins: [DispatchEventMixin],
    props: {
      icon: { type: String, default: 'menu' }
    }
  };

  var mdcToolbarTitle = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('a', _vm._g({ staticClass: "mdc-toolbar-title mdc-toolbar__title" }, _vm.listeners), [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-toolbar-title',
    mixins: [DispatchEventMixin]
  };

  var mdcToolbarIcon = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('a', _vm._g({ staticClass: "mdc-toolbar-icon mdc-toolbar__icon", class: { 'material-icons': !!_vm.icon } }, _vm.listeners), [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2);
    }, staticRenderFns: [],
    name: 'mdc-toolbar-icon',
    mixins: [DispatchEventMixin],
    props: {
      icon: String
    }
  };

  var VueMDCToolbar = BasePlugin({
    mdcToolbar: mdcToolbar,
    mdcToolbarRow: mdcToolbarRow,
    mdcToolbarSection: mdcToolbarSection,
    mdcToolbarMenuIcon: mdcToolbarMenuIcon,
    mdcToolbarTitle: mdcToolbarTitle,
    mdcToolbarIcon: mdcToolbarIcon
  });

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses$n = {
    FIXED_CLASS: 'mdc-top-app-bar--fixed',
    FIXED_SCROLLED_CLASS: 'mdc-top-app-bar--fixed-scrolled',
    SHORT_CLASS: 'mdc-top-app-bar--short',
    SHORT_HAS_ACTION_ITEM_CLASS: 'mdc-top-app-bar--short-has-action-item',
    SHORT_COLLAPSED_CLASS: 'mdc-top-app-bar--short-collapsed'
  };

  /** @enum {number} */
  var numbers$8 = {
    DEBOUNCE_THROTTLE_RESIZE_TIME_MS: 100,
    MAX_TOP_APP_BAR_HEIGHT: 128
  };

  /** @enum {string} */
  var strings$n = {
    ACTION_ITEM_SELECTOR: '.mdc-top-app-bar__action-item',
    NAVIGATION_EVENT: 'MDCTopAppBar:nav',
    NAVIGATION_ICON_SELECTOR: '.mdc-top-app-bar__navigation-icon',
    ROOT_SELECTOR: '.mdc-top-app-bar',
    TITLE_SELECTOR: '.mdc-top-app-bar__title'
  };

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Top App Bar
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Top App Bar into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCTopAppBarAdapter = function () {
    function MDCTopAppBarAdapter() {
      classCallCheck(this, MDCTopAppBarAdapter);
    }

    createClass(MDCTopAppBarAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the root Element.
       * @param {string} className
       */
      value: function addClass(className) {}

      /**
       * Removes a class from the root Element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * Returns true if the root Element contains the given class.
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}

      /**
       * Sets the specified inline style property on the root Element to the given value.
       * @param {string} property
       * @param {string} value
       */

    }, {
      key: "setStyle",
      value: function setStyle(property, value) {}

      /**
       * Gets the height of the top app bar.
       * @return {number}
       */

    }, {
      key: "getTopAppBarHeight",
      value: function getTopAppBarHeight() {}

      /**
       * Registers an event handler on the navigation icon element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerNavigationIconInteractionHandler",
      value: function registerNavigationIconInteractionHandler(type, handler) {}

      /**
       * Deregisters an event handler on the navigation icon element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterNavigationIconInteractionHandler",
      value: function deregisterNavigationIconInteractionHandler(type, handler) {}

      /**
       * Emits an event when the navigation icon is clicked.
       */

    }, {
      key: "notifyNavigationIconClicked",
      value: function notifyNavigationIconClicked() {}

      /** @param {function(!Event)} handler */

    }, {
      key: "registerScrollHandler",
      value: function registerScrollHandler(handler) {}

      /** @param {function(!Event)} handler */

    }, {
      key: "deregisterScrollHandler",
      value: function deregisterScrollHandler(handler) {}

      /** @param {function(!Event)} handler */

    }, {
      key: "registerResizeHandler",
      value: function registerResizeHandler(handler) {}

      /** @param {function(!Event)} handler */

    }, {
      key: "deregisterResizeHandler",
      value: function deregisterResizeHandler(handler) {}

      /** @return {number} */

    }, {
      key: "getViewportScrollY",
      value: function getViewportScrollY() {}

      /** @return {number} */

    }, {
      key: "getTotalActionItems",
      value: function getTotalActionItems() {}
    }]);
    return MDCTopAppBarAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCFoundation<!MDCTopAppBarAdapter>}
   */

  var MDCTopAppBarBaseFoundation = function (_MDCFoundation) {
    inherits(MDCTopAppBarBaseFoundation, _MDCFoundation);
    createClass(MDCTopAppBarBaseFoundation, null, [{
      key: 'strings',

      /** @return enum {string} */
      get: function get$$1() {
        return strings$n;
      }

      /** @return enum {string} */

    }, {
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$n;
      }

      /** @return enum {number} */

    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers$8;
      }

      /**
       * {@see MDCTopAppBarAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCTopAppBarAdapter}
       */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCTopAppBarAdapter} */{
            hasClass: function hasClass() /* className: string */{},
            addClass: function addClass() /* className: string */{},
            removeClass: function removeClass() /* className: string */{},
            setStyle: function setStyle() /* property: string, value: string */{},
            getTopAppBarHeight: function getTopAppBarHeight() {},
            registerNavigationIconInteractionHandler: function registerNavigationIconInteractionHandler() /* type: string, handler: EventListener */{},
            deregisterNavigationIconInteractionHandler: function deregisterNavigationIconInteractionHandler() /* type: string, handler: EventListener */{},
            notifyNavigationIconClicked: function notifyNavigationIconClicked() {},
            registerScrollHandler: function registerScrollHandler() /* handler: EventListener */{},
            deregisterScrollHandler: function deregisterScrollHandler() /* handler: EventListener */{},
            registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
            deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
            getViewportScrollY: function getViewportScrollY() {
              return (/* number */0
              );
            },
            getTotalActionItems: function getTotalActionItems() {
              return (/* number */0
              );
            }
          }
        );
      }

      /**
       * @param {!MDCTopAppBarAdapter} adapter
       */

    }]);

    function MDCTopAppBarBaseFoundation( /** @type {!MDCTopAppBarAdapter} */adapter) {
      classCallCheck(this, MDCTopAppBarBaseFoundation);

      var _this = possibleConstructorReturn(this, (MDCTopAppBarBaseFoundation.__proto__ || Object.getPrototypeOf(MDCTopAppBarBaseFoundation)).call(this, _extends(MDCTopAppBarBaseFoundation.defaultAdapter, adapter)));

      _this.navClickHandler_ = function () {
        return _this.adapter_.notifyNavigationIconClicked();
      };
      return _this;
    }

    createClass(MDCTopAppBarBaseFoundation, [{
      key: 'init',
      value: function init() {
        this.adapter_.registerNavigationIconInteractionHandler('click', this.navClickHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterNavigationIconInteractionHandler('click', this.navClickHandler_);
      }
    }]);
    return MDCTopAppBarBaseFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2018 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @extends {MDCTopAppBarBaseFoundation<!MDCShortTopAppBarFoundation>}
   * @final
   */

  var MDCShortTopAppBarFoundation = function (_MDCTopAppBarBaseFoun) {
    inherits(MDCShortTopAppBarFoundation, _MDCTopAppBarBaseFoun);

    /**
     * @param {!MDCTopAppBarAdapter} adapter
     */
    function MDCShortTopAppBarFoundation(adapter) {
      classCallCheck(this, MDCShortTopAppBarFoundation);

      // State variable for the current top app bar state
      var _this = possibleConstructorReturn(this, (MDCShortTopAppBarFoundation.__proto__ || Object.getPrototypeOf(MDCShortTopAppBarFoundation)).call(this, adapter));

      _this.isCollapsed = false;

      _this.scrollHandler_ = function () {
        return _this.shortAppBarScrollHandler_();
      };
      return _this;
    }

    createClass(MDCShortTopAppBarFoundation, [{
      key: 'init',
      value: function init() {
        get(MDCShortTopAppBarFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCShortTopAppBarFoundation.prototype), 'init', this).call(this);
        var isAlwaysCollapsed = this.adapter_.hasClass(cssClasses$n.SHORT_COLLAPSED_CLASS);

        if (this.adapter_.getTotalActionItems() > 0) {
          this.adapter_.addClass(cssClasses$n.SHORT_HAS_ACTION_ITEM_CLASS);
        }

        if (!isAlwaysCollapsed) {
          this.adapter_.registerScrollHandler(this.scrollHandler_);
          this.shortAppBarScrollHandler_();
        }
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        get(MDCShortTopAppBarFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCShortTopAppBarFoundation.prototype), 'destroy', this).call(this);
        this.adapter_.deregisterScrollHandler(this.scrollHandler_);
      }

      /**
       * Scroll handler for applying/removing the collapsed modifier class
       * on the short top app bar.
       * @private
       */

    }, {
      key: 'shortAppBarScrollHandler_',
      value: function shortAppBarScrollHandler_() {
        var currentScroll = this.adapter_.getViewportScrollY();

        if (currentScroll <= 0) {
          if (this.isCollapsed) {
            this.adapter_.removeClass(cssClasses$n.SHORT_COLLAPSED_CLASS);
            this.isCollapsed = false;
          }
        } else {
          if (!this.isCollapsed) {
            this.adapter_.addClass(cssClasses$n.SHORT_COLLAPSED_CLASS);
            this.isCollapsed = true;
          }
        }
      }
    }]);
    return MDCShortTopAppBarFoundation;
  }(MDCTopAppBarBaseFoundation);

  var mdcTopAppBar = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('header', _vm._g({ ref: "root", class: _vm.rootClasses, style: _vm.rootStyles }, _vm.$listeners), [_c('div', { staticClass: "mdc-top-app-bar__row" }, [_c('section', { staticClass: "mdc-top-app-bar__section mdc-top-app-bar__section--align-start" }, [_vm.haveNavigationIcon ? _c('a', _vm._g({ ref: "navigationIcon", class: _vm.naviconClasses, attrs: { "href": "#" } }, _vm.listeners), [_vm._v(_vm._s(_vm.icon))]) : _vm._e(), _vm._v(" "), !!_vm.title ? _c('span', { staticClass: "mdc-top-app-bar__title" }, [_vm._v(_vm._s(_vm.title))]) : _vm._e()]), _vm._v(" "), _vm.$slots.default ? _c('section', { staticClass: "mdc-top-app-bar__section mdc-top-app-bar__section--align-end" }, [_vm._t("default")], 2) : _vm._e()]), _vm._v(" "), _vm.$slots.tabs ? _c('div', { staticClass: "mdc-top-app-bar__row" }, [_vm._t("tabs")], 2) : _vm._e()]);
    }, staticRenderFns: [],
    name: 'mdc-top-app-bar',
    mixins: [DispatchEventMixin],
    props: {
      short: Boolean,
      shortCollapsed: Boolean,
      prominent: Boolean,
      fixed: Boolean,
      title: String,
      icon: {
        type: String,
        default: 'menu'
      },
      iconClasses: Object,
      dense: Boolean
    },
    data: function data() {
      return {
        rootStyles: {},
        rootClasses: {
          'mdc-top-app-bar': true,
          'mdc-top-app-bar--dense': this.dense,
          'mdc-top-app-bar--short': this.short,
          'mdc-top-app-bar--short-collapsed': this.shortCollapsed,
          'mdc-top-app-bar--prominent': this.prominent,
          'mdc-top-app-bar--fixed': this.fixed
        },
        foundation: null
      };
    },

    computed: {
      haveNavigationIcon: function haveNavigationIcon() {
        return !!this.icon || this.iconClasses;
      },
      naviconClasses: function naviconClasses() {
        return _extends({
          'mdc-top-app-bar__navigation-icon': true,
          'material-icons': !!this.icon
        }, this.iconClasses);
      }
    },
    mounted: function mounted() {
      var _this = this;

      var adapter = {
        addClass: function addClass(className) {
          _this.$set(_this.rootClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.rootClasses, className);
        },
        hasClass: function hasClass(className) {
          return _this.$refs.root.classList.contains(className);
        },
        setStyle: function setStyle(property, value) {
          _this.$set(_this.rootStyles, property, value);
        },
        getTopAppBarHeight: function getTopAppBarHeight() {
          return _this.$el.clientHeight;
        },
        registerNavigationIconInteractionHandler: function registerNavigationIconInteractionHandler(type, handler) {
          if (_this.$refs.navigationIcon) {
            _this.$refs.navigationIcon.addEventListener(type, handler);
          }
        },
        deregisterNavigationIconInteractionHandler: function deregisterNavigationIconInteractionHandler(type, handler) {
          if (_this.$refs.navigationIcon) {
            _this.$refs.navigationIcon.removeEventListener(type, handler);
          }
        },
        notifyNavigationIconClicked: function notifyNavigationIconClicked() {
          _this.$emit('nav');
        },
        registerScrollHandler: function registerScrollHandler(handler) {
          window.addEventListener('scroll', handler);
        },
        deregisterScrollHandler: function deregisterScrollHandler(handler) {
          window.removeEventListener('scroll', handler);
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          return window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          return window.removeEventListener('resize', handler);
        },

        getViewportScrollY: function getViewportScrollY() {
          return window.pageYOffset;
        },
        getTotalActionItems: function getTotalActionItems() {
          return _this.$refs.root.querySelectorAll(MDCTopAppBarBaseFoundation.strings.ACTION_ITEM_SELECTOR).length;
        }
      };

      this.foundation = this.short ? new MDCShortTopAppBarFoundation(adapter) : new MDCTopAppBarBaseFoundation(adapter);

      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    }
  };

  var mdcTopAppBarAction = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('a', _vm._g({ staticClass: "mdc-top-app-bar-action mdc-top-app-bar--action mdc-top-app-bar__action-item", class: _vm.actioniconClasses, attrs: { "href": "#" } }, _vm.listeners), [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])], 2);
    }, staticRenderFns: [],
    name: 'mdc-top-app-bar-action',
    mixins: [DispatchEventMixin, RippleMixin],
    props: {
      icon: String,
      iconClasses: Object
    },
    computed: {
      actioniconClasses: function actioniconClasses() {
        return _extends({
          'material-icons': !!this.icon
        }, this.iconClasses);
      }
    }
  };

  var VueMDCTopAppBar = BasePlugin({
    mdcTopAppBar: mdcTopAppBar,
    mdcTopAppBarAction: mdcTopAppBarAction
  });

  var typos = ['headline1', 'headline2', 'headline3', 'headline4', 'headline5', 'headline6', 'subtitle1', 'subtitle2', 'body1', 'body2', 'caption', 'button', 'overline'];

  var mdcTypoMixin = function mdcTypoMixin(name) {
    return {
      render: function render(createElement) {
        var _class;

        return createElement(this.tag, {
          class: (_class = {
            'mdc-typo': true
          }, defineProperty(_class, name, true), defineProperty(_class, 'mdc-typography--' + this.typo, true), _class),
          attrs: this.$attrs,
          on: this.$listeners
        }, this.$slots.default);
      }
    };
  };

  function mdcTypoPropMixin(defaultTag, defaultTypo, validTypos) {
    return {
      props: {
        tag: {
          type: String,
          default: defaultTag
        },
        typo: {
          type: String,
          default: defaultTypo,
          validator: function validator(value) {
            return validTypos.indexOf(value) !== -1;
          }
        }
      }
    };
  }

  var mdcTextSection = {
    name: 'mdc-text-section',
    props: {
      tag: {
        type: String,
        default: 'section'
      }
    },
    render: function render(createElement) {
      return createElement(this.tag, {
        class: {
          'mdc-typography': true,
          'mdc-text-section': true
        },
        attrs: this.$attrs,
        on: this.$listeners
      }, this.$slots.default);
    }
  };

  var mdcText = {
    name: 'mdc-text',
    mixins: [mdcTypoMixin('mdc-text'), mdcTypoPropMixin('p', 'body1', typos)]
  };

  var mdcDisplay = {
    name: 'mdc-display',
    mixins: [mdcTypoMixin('mdc-display'), mdcTypoPropMixin('h1', 'headline4', ['headline4', 'headline3', 'headline2', 'headline1'])]
  };

  var mdcHeadline = {
    name: 'mdc-headline',
    mixins: [mdcTypoMixin('mdc-headline'), mdcTypoPropMixin('h2', 'headline5', ['headline5'])]
  };

  var mdcTitle = {
    name: 'mdc-title',
    mixins: [mdcTypoMixin('mdc-title'), mdcTypoPropMixin('h3', 'headline6', ['headline6'])]
  };

  var mdcSubHeading = {
    name: 'mdc-subheading',
    mixins: [mdcTypoMixin('mdc-subheading'), mdcTypoPropMixin('h4', 'subtitle2', ['subtitle1', 'subtitle2'])]
  };

  var mdcBody = {
    name: 'mdc-body',
    mixins: [mdcTypoMixin('mdc-body'), mdcTypoPropMixin('p', 'body1', ['body1', 'body2'])]
  };

  var mdcCaption = {
    name: 'mdc-caption',
    mixins: [mdcTypoMixin('mdc-caption'), mdcTypoPropMixin('span', 'caption', ['caption'])]
  };

  var VueMDCTypography = BasePlugin({
    mdcTextSection: mdcTextSection,
    mdcText: mdcText,
    mdcBody: mdcBody,
    mdcCaption: mdcCaption,
    mdcDisplay: mdcDisplay,
    mdcHeadline: mdcHeadline,
    mdcSubHeading: mdcSubHeading,
    mdcTitle: mdcTitle
  });

  //

  var plugin = {
    version: '0.17.0',
    install: function install(vm) {
      vm.use(VueMDCButton);
      vm.use(VueMDCCard);
      vm.use(VueMDCCheckbox);
      vm.use(VueMDCChipSet);
      vm.use(VueMDCDialog);
      vm.use(VueMDCDrawer);
      vm.use(VueMDCElevation);
      vm.use(VueMDCFab);
      vm.use(VueMDCGridList);
      vm.use(VueMDCIcon);
      vm.use(VueMDCIconToggle);
      vm.use(VueMDCLayoutApp);
      vm.use(VueMDCLayoutGrid);
      vm.use(VueMDCLinearProgress);
      vm.use(VueMDCList);
      vm.use(VueMDCMenu);
      vm.use(VueMDCRadio);
      vm.use(VueMDCRipple);
      vm.use(VueMDCSelect);
      vm.use(VueMDCSlider);
      vm.use(VueMDCSnackbar);
      vm.use(VueMDCSwitch);
      vm.use(VueMDCTabs);
      vm.use(VueMDCTextfield);
      vm.use(VueMDCTheme);
      vm.use(VueMDCToolbar);
      vm.use(VueMDCTopAppBar);
      vm.use(VueMDCTypography);
    }
  };

  autoInit(plugin);

  return plugin;

})));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidnVlLW1kYy1hZGFwdGVyLmpzIiwic291cmNlcyI6WyIuLi9jb21wb25lbnRzL2Jhc2UvYXBwbHktcGFzc2l2ZS5qcyIsIi4uL2NvbXBvbmVudHMvYmFzZS9hdXRvLWluaXQuanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvYmFzZS1wbHVnaW4uanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvY3VzdG9tLWVsZW1lbnQuanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvY3VzdG9tLWxpbmsuanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvY3VzdG9tLWV2ZW50LmpzIiwiLi4vY29tcG9uZW50cy9iYXNlL2N1c3RvbS1idXR0b24uanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvY3VzdG9tLWljb24uanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvZGlzcGF0Y2gtZXZlbnQtbWl4aW4uanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvZGlzcGF0Y2gtZm9jdXMtbWl4aW4uanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvdW5pcXVlaWQtbWl4aW4uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvcmlwcGxlL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS91dGlsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yaXBwbGUvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvcmlwcGxlL21kYy1yaXBwbGUtYmFzZS5qcyIsIi4uL2NvbXBvbmVudHMvcmlwcGxlL21kYy1yaXBwbGUudnVlIiwiLi4vY29tcG9uZW50cy9yaXBwbGUvaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2J1dHRvbi9tZGMtYnV0dG9uLWJhc2UudnVlIiwiLi4vY29tcG9uZW50cy9idXR0b24vbWRjLWJ1dHRvbi52dWUiLCIuLi9jb21wb25lbnRzL2J1dHRvbi9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvY2FyZC9tZGMtY2FyZC52dWUiLCIuLi9jb21wb25lbnRzL2NhcmQvbWRjLWNhcmQtcHJpbWFyeS1hY3Rpb24udnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLW1lZGlhLnZ1ZSIsIi4uL2NvbXBvbmVudHMvY2FyZC9tZGMtY2FyZC1oZWFkZXIudnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLXRpdGxlLnZ1ZSIsIi4uL2NvbXBvbmVudHMvY2FyZC9tZGMtY2FyZC1zdWJ0aXRsZS52dWUiLCIuLi9jb21wb25lbnRzL2NhcmQvbWRjLWNhcmQtdGV4dC52dWUiLCIuLi9jb21wb25lbnRzL2NhcmQvbWRjLWNhcmQtYWN0aW9ucy52dWUiLCIuLi9jb21wb25lbnRzL2NhcmQvbWRjLWNhcmQtYWN0aW9uLWJ1dHRvbnMudnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLWFjdGlvbi1idXR0b24udnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLWFjdGlvbi1pY29ucy52dWUiLCIuLi9jb21wb25lbnRzL2NhcmQvbWRjLWNhcmQtYWN0aW9uLWljb24udnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9iYXNlL2NvbXBvbmVudC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvcmlwcGxlL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9zZWxlY3Rpb24tY29udHJvbC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvY2hlY2tib3gvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvY2hlY2tib3gvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9jaGVja2JveC9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9mb3JtLWZpZWxkL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2Zvcm0tZmllbGQvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9mb3JtLWZpZWxkL2ZvdW5kYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2FuaW1hdGlvbi9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvY2hlY2tib3gvbWRjLWNoZWNrYm94LnZ1ZSIsIi4uL2NvbXBvbmVudHMvY2hlY2tib3gvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2NoaXBzL2NoaXAvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvY2hpcHMvY2hpcC9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2NoaXBzL2NoaXAvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvY2hpcHMvbWRjLWNoaXAudnVlIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9jaGlwcy9jaGlwLXNldC9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9jaGlwcy9jaGlwLXNldC9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2NoaXBzL2NoaXAtc2V0L2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL2NoaXBzL21kYy1jaGlwLXNldC52dWUiLCIuLi9jb21wb25lbnRzL2NoaXBzL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9iYXNlL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kaWFsb2cvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kaWFsb2cvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy90YWJiYWJsZS9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9mb2N1cy10cmFwL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kaWFsb2cvdXRpbC5qcyIsIi4uL2NvbXBvbmVudHMvZGlhbG9nL21kYy1kaWFsb2cudnVlIiwiLi4vY29tcG9uZW50cy9kaWFsb2cvaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2RyYXdlci9tZGMtcGVybWFuZW50LWRyYXdlci52dWUiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RyYXdlci9zbGlkYWJsZS9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RyYXdlci9zbGlkYWJsZS9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kcmF3ZXIvc2xpZGFibGUvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RyYXdlci9wZXJzaXN0ZW50L2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZHJhd2VyL3BlcnNpc3RlbnQvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZHJhd2VyL3V0aWwuanMiLCIuLi9jb21wb25lbnRzL2RyYXdlci9tZGMtcGVyc2lzdGVudC1kcmF3ZXIudnVlIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kcmF3ZXIvdGVtcG9yYXJ5L2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZHJhd2VyL3RlbXBvcmFyeS9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvbWRjLXRlbXBvcmFyeS1kcmF3ZXIudnVlIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvbWRjLWRyYXdlci52dWUiLCIuLi9jb21wb25lbnRzL2RyYXdlci9tZGMtZHJhd2VyLWxheW91dC52dWUiLCIuLi9jb21wb25lbnRzL2RyYXdlci9tZGMtZHJhd2VyLWhlYWRlci52dWUiLCIuLi9jb21wb25lbnRzL2RyYXdlci9tZGMtZHJhd2VyLWxpc3QudnVlIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvbWRjLWRyYXdlci1pdGVtLnZ1ZSIsIi4uL2NvbXBvbmVudHMvZHJhd2VyL21kYy1kcmF3ZXItZGl2aWRlci52dWUiLCIuLi9jb21wb25lbnRzL2RyYXdlci9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvZWxldmF0aW9uL21kYy1lbGV2YXRpb24udnVlIiwiLi4vY29tcG9uZW50cy9lbGV2YXRpb24vaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2ZhYi9tZGMtZmFiLnZ1ZSIsIi4uL2NvbXBvbmVudHMvZmFiL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9ncmlkLWxpc3QvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9ncmlkLWxpc3QvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvZ3JpZC1saXN0L21kYy1ncmlkLWxpc3QudnVlIiwiLi4vY29tcG9uZW50cy9ncmlkLWxpc3QvbWRjLWdyaWQtdGlsZS52dWUiLCIuLi9jb21wb25lbnRzL2dyaWQtbGlzdC9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvaWNvbi9tZGMtaWNvbi52dWUiLCIuLi9jb21wb25lbnRzL2ljb24vaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2ljb24tdG9nZ2xlL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2ljb24tdG9nZ2xlL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvaWNvbi10b2dnbGUvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvaWNvbi10b2dnbGUvbWRjLWljb24tdG9nZ2xlLnZ1ZSIsIi4uL2NvbXBvbmVudHMvaWNvbi10b2dnbGUvaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2xheW91dC1hcHAvbWRjLWxheW91dC1hcHAudnVlIiwiLi4vY29tcG9uZW50cy9sYXlvdXQtYXBwL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9sYXlvdXQtZ3JpZC9tZGMtbGF5b3V0LWdyaWQudnVlIiwiLi4vY29tcG9uZW50cy9sYXlvdXQtZ3JpZC9tZGMtbGF5b3V0LWNlbGwudnVlIiwiLi4vY29tcG9uZW50cy9sYXlvdXQtZ3JpZC9tZGMtbGF5b3V0LWlubmVyLWdyaWQudnVlIiwiLi4vY29tcG9uZW50cy9sYXlvdXQtZ3JpZC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvbGluZWFyLXByb2dyZXNzL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvbGluZWFyLXByb2dyZXNzL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL2xpbmVhci1wcm9ncmVzcy9tZGMtbGluZWFyLXByb2dyZXNzLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbGluZWFyLXByb2dyZXNzL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9saXN0L21kYy1saXN0LnZ1ZSIsIi4uL2NvbXBvbmVudHMvbGlzdC9tZGMtbGlzdC1pdGVtLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbGlzdC9tZGMtbGlzdC1kaXZpZGVyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbGlzdC9tZGMtbGlzdC1ncm91cC52dWUiLCIuLi9jb21wb25lbnRzL2xpc3QvbWRjLWxpc3QtZ3JvdXAtaGVhZGVyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbGlzdC9tZGMtbGlzdC1ncm91cC1kaXZpZGVyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbGlzdC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvbWVudS9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9tZW51L2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvbWVudS9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9tZW51L3V0aWwuanMiLCIuLi9jb21wb25lbnRzL21lbnUvbWRjLW1lbnUudnVlIiwiLi4vY29tcG9uZW50cy9tZW51L21kYy1tZW51LWl0ZW0udnVlIiwiLi4vY29tcG9uZW50cy9tZW51L21kYy1tZW51LWRpdmlkZXIudnVlIiwiLi4vY29tcG9uZW50cy9tZW51L21kYy1tZW51LWFuY2hvci52dWUiLCIuLi9jb21wb25lbnRzL21lbnUvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JhZGlvL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JhZGlvL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvcmFkaW8vZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvcmFkaW8vbWRjLXJhZGlvLnZ1ZSIsIi4uL2NvbXBvbmVudHMvcmFkaW8vaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3NlbGVjdC9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3NlbGVjdC9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9mbG9hdGluZy1sYWJlbC9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9mbG9hdGluZy1sYWJlbC9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2Zsb2F0aW5nLWxhYmVsL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL3NlbGVjdC9tZGMtc2VsZWN0LWxhYmVsLnZ1ZSIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvbGluZS1yaXBwbGUvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvbGluZS1yaXBwbGUvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9saW5lLXJpcHBsZS9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy9zZWxlY3QvbWRjLXNlbGVjdC1saW5lLXJpcHBsZS52dWUiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL25vdGNoZWQtb3V0bGluZS9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9ub3RjaGVkLW91dGxpbmUvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9ub3RjaGVkLW91dGxpbmUvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvc2VsZWN0L21kYy1zZWxlY3Qtbm90Y2hlZC1vdXRsaW5lLnZ1ZSIsIi4uL2NvbXBvbmVudHMvc2VsZWN0L21kYy1zZWxlY3QudnVlIiwiLi4vY29tcG9uZW50cy9zZWxlY3QvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3NsaWRlci9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3NsaWRlci9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9zbGlkZXIvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvc2xpZGVyL21kYy1zbGlkZXIudnVlIiwiLi4vY29tcG9uZW50cy9zbGlkZXIvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3NuYWNrYmFyL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc25hY2tiYXIvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvc25hY2tiYXIvbWRjLXNuYWNrYmFyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvc25hY2tiYXIvaW5kZXguanMiLCIuLi9jb21wb25lbnRzL3N3aXRjaC9tZGMtc3dpdGNoLnZ1ZSIsIi4uL2NvbXBvbmVudHMvc3dpdGNoL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWJzL3RhYi9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYnMvdGFiL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL3RhYnMvbWRjLXRhYi52dWUiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYnMvdGFiLWJhci9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYnMvdGFiLWJhci9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy90YWJzL21kYy10YWItYmFyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvdGFicy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGV4dGZpZWxkL2hlbHBlci10ZXh0L2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RleHRmaWVsZC9oZWxwZXItdGV4dC9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RleHRmaWVsZC9oZWxwZXItdGV4dC9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvaWNvbi9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvaWNvbi9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RleHRmaWVsZC9pY29uL2ZvdW5kYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RleHRmaWVsZC9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvdGV4dGZpZWxkL21kYy10ZXh0ZmllbGQudnVlIiwiLi4vY29tcG9uZW50cy90ZXh0ZmllbGQvaW5kZXguanMiLCIuLi9jb21wb25lbnRzL3RoZW1lL21kYy10aGVtZS52dWUiLCIuLi9jb21wb25lbnRzL3RoZW1lL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90b29sYmFyL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdG9vbGJhci9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy90b29sYmFyL21kYy10b29sYmFyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvdG9vbGJhci9tZGMtdG9vbGJhci1yb3cudnVlIiwiLi4vY29tcG9uZW50cy90b29sYmFyL21kYy10b29sYmFyLXNlY3Rpb24udnVlIiwiLi4vY29tcG9uZW50cy90b29sYmFyL21kYy10b29sYmFyLW1lbnUtaWNvbi52dWUiLCIuLi9jb21wb25lbnRzL3Rvb2xiYXIvbWRjLXRvb2xiYXItdGl0bGUudnVlIiwiLi4vY29tcG9uZW50cy90b29sYmFyL21kYy10b29sYmFyLWljb24udnVlIiwiLi4vY29tcG9uZW50cy90b29sYmFyL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90b3AtYXBwLWJhci9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RvcC1hcHAtYmFyL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RvcC1hcHAtYmFyL2ZvdW5kYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RvcC1hcHAtYmFyL3Nob3J0L2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL3RvcC1hcHAtYmFyL21kYy10b3AtYXBwLWJhci52dWUiLCIuLi9jb21wb25lbnRzL3RvcC1hcHAtYmFyL21kYy10b3AtYXBwLWJhci1hY3Rpb24udnVlIiwiLi4vY29tcG9uZW50cy90b3AtYXBwLWJhci9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvdHlwb2dyYXBoeS9tZGMtdHlwb2dyYXBoeS5qcyIsIi4uL2NvbXBvbmVudHMvdHlwb2dyYXBoeS9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2VudHJ5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImxldCBzdXBwb3J0c1Bhc3NpdmVfXG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGN1cnJlbnQgYnJvd3NlciBzdXBwb3J0cyBwYXNzaXZlIGV2ZW50IGxpc3RlbmVycywgYW5kIGlmIHNvLCB1c2UgdGhlbS5cbiAqIEBwYXJhbSB7IVdpbmRvdz19IGdsb2JhbE9ialxuICogQHBhcmFtIHtib29sZWFuPX0gZm9yY2VSZWZyZXNoXG4gKiBAcmV0dXJuIHtib29sZWFufHtwYXNzaXZlOiBib29sZWFufX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UGFzc2l2ZShnbG9iYWxPYmogPSB3aW5kb3csIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gIGlmIChzdXBwb3J0c1Bhc3NpdmVfID09PSB1bmRlZmluZWQgfHwgZm9yY2VSZWZyZXNoKSB7XG4gICAgbGV0IGlzU3VwcG9ydGVkID0gZmFsc2VcbiAgICB0cnkge1xuICAgICAgZ2xvYmFsT2JqLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCB7XG4gICAgICAgIGdldCBwYXNzaXZlKCkge1xuICAgICAgICAgIGlzU3VwcG9ydGVkID0geyBwYXNzaXZlOiB0cnVlIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvL2VtcHR5XG4gICAgfVxuXG4gICAgc3VwcG9ydHNQYXNzaXZlXyA9IGlzU3VwcG9ydGVkXG4gIH1cblxuICByZXR1cm4gc3VwcG9ydHNQYXNzaXZlX1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGF1dG9Jbml0KHBsdWdpbikge1xuICAvLyBBdXRvLWluc3RhbGxcbiAgbGV0IF9WdWUgPSBudWxsXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIF9WdWUgPSB3aW5kb3cuVnVlXG4gIH0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvKmdsb2JhbCBnbG9iYWwqL1xuICAgIF9WdWUgPSBnbG9iYWwuVnVlXG4gIH1cbiAgaWYgKF9WdWUpIHtcbiAgICBfVnVlLnVzZShwbHVnaW4pXG4gIH1cbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBCYXNlUGx1Z2luKGNvbXBvbmVudHMpIHtcbiAgcmV0dXJuIHtcbiAgICB2ZXJzaW9uOiAnX19WRVJTSU9OX18nLFxuICAgIGluc3RhbGw6IHZtID0+IHtcbiAgICAgIGZvciAobGV0IGtleSBpbiBjb21wb25lbnRzKSB7XG4gICAgICAgIGxldCBjb21wb25lbnQgPSBjb21wb25lbnRzW2tleV1cbiAgICAgICAgdm0uY29tcG9uZW50KGNvbXBvbmVudC5uYW1lLCBjb21wb25lbnQpXG4gICAgICB9XG4gICAgfSxcbiAgICBjb21wb25lbnRzXG4gIH1cbn1cbiIsImV4cG9ydCBjb25zdCBDdXN0b21FbGVtZW50ID0ge1xuICBmdW5jdGlvbmFsOiB0cnVlLFxuICByZW5kZXIoY3JlYXRlRWxlbWVudCwgY29udGV4dCkge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFxuICAgICAgY29udGV4dC5wcm9wcy5pcyB8fCBjb250ZXh0LnByb3BzLnRhZyB8fCAnZGl2JyxcbiAgICAgIGNvbnRleHQuZGF0YSxcbiAgICAgIGNvbnRleHQuY2hpbGRyZW5cbiAgICApXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEN1c3RvbUVsZW1lbnRNaXhpbiA9IHtcbiAgY29tcG9uZW50czoge1xuICAgIEN1c3RvbUVsZW1lbnRcbiAgfVxufVxuIiwiZXhwb3J0IGNvbnN0IEN1c3RvbUxpbmsgPSB7XG4gIG5hbWU6ICdjdXN0b20tbGluaycsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgdGFnOiB7IHR5cGU6IFN0cmluZywgZGVmYXVsdDogJ2EnIH0sXG4gICAgbGluazogT2JqZWN0XG4gIH0sXG4gIHJlbmRlcihoLCBjb250ZXh0KSB7XG4gICAgbGV0IGVsZW1lbnRcbiAgICBsZXQgZGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIGNvbnRleHQuZGF0YSlcblxuICAgIGlmIChjb250ZXh0LnByb3BzLmxpbmsgJiYgY29udGV4dC5wYXJlbnQuJHJvdXRlcikge1xuICAgICAgLy8gcm91dGVyLWxpbmsgY2FzZVxuICAgICAgZWxlbWVudCA9IGNvbnRleHQucGFyZW50LiRyb290LiRvcHRpb25zLmNvbXBvbmVudHNbJ3JvdXRlci1saW5rJ11cbiAgICAgIGRhdGEucHJvcHMgPSBPYmplY3QuYXNzaWduKHsgdGFnOiBjb250ZXh0LnByb3BzLnRhZyB9LCBjb250ZXh0LnByb3BzLmxpbmspXG4gICAgICBpZiAoZGF0YS5vbi5jbGljaykge1xuICAgICAgICBkYXRhLm5hdGl2ZU9uID0geyBjbGljazogZGF0YS5vbi5jbGljayB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVsZW1lbnQgZmFsbGJhY2tcbiAgICAgIGVsZW1lbnQgPSBjb250ZXh0LnByb3BzLnRhZ1xuICAgIH1cblxuICAgIHJldHVybiBoKGVsZW1lbnQsIGRhdGEsIGNvbnRleHQuY2hpbGRyZW4pXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEN1c3RvbUxpbmtNaXhpbiA9IHtcbiAgcHJvcHM6IHtcbiAgICB0bzogW1N0cmluZywgT2JqZWN0XSxcbiAgICBleGFjdDogQm9vbGVhbixcbiAgICBhcHBlbmQ6IEJvb2xlYW4sXG4gICAgcmVwbGFjZTogQm9vbGVhbixcbiAgICBhY3RpdmVDbGFzczogU3RyaW5nLFxuICAgIGV4YWN0QWN0aXZlQ2xhc3M6IFN0cmluZ1xuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGxpbmsoKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB0aGlzLnRvICYmIHtcbiAgICAgICAgICB0bzogdGhpcy50byxcbiAgICAgICAgICBleGFjdDogdGhpcy5leGFjdCxcbiAgICAgICAgICBhcHBlbmQ6IHRoaXMuYXBwZW5kLFxuICAgICAgICAgIHJlcGxhY2U6IHRoaXMucmVwbGFjZSxcbiAgICAgICAgICBhY3RpdmVDbGFzczogdGhpcy5hY3RpdmVDbGFzcyxcbiAgICAgICAgICBleGFjdEFjdGl2ZUNsYXNzOiB0aGlzLmV4YWN0QWN0aXZlQ2xhc3NcbiAgICAgICAgfVxuICAgICAgKVxuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50czoge1xuICAgIEN1c3RvbUxpbmtcbiAgfVxufVxuIiwiLyogZ2xvYmFsIEN1c3RvbUV2ZW50ICovXG5cbmV4cG9ydCBmdW5jdGlvbiBlbWl0Q3VzdG9tRXZlbnQoZWwsIGV2dFR5cGUsIGV2dERhdGEsIHNob3VsZEJ1YmJsZSA9IGZhbHNlKSB7XG4gIGxldCBldnRcbiAgaWYgKHR5cGVvZiBDdXN0b21FdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV2dCA9IG5ldyBDdXN0b21FdmVudChldnRUeXBlLCB7XG4gICAgICBkZXRhaWw6IGV2dERhdGEsXG4gICAgICBidWJibGVzOiBzaG91bGRCdWJibGVcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpXG4gICAgZXZ0LmluaXRDdXN0b21FdmVudChldnRUeXBlLCBzaG91bGRCdWJibGUsIGZhbHNlLCBldnREYXRhKVxuICB9XG4gIGVsLmRpc3BhdGNoRXZlbnQoZXZ0KVxufVxuIiwiZXhwb3J0IGNvbnN0IEN1c3RvbUJ1dHRvbiA9IHtcbiAgbmFtZTogJ2N1c3RvbS1idXR0b24nLFxuICBmdW5jdGlvbmFsOiB0cnVlLFxuICBwcm9wczoge1xuICAgIGxpbms6IE9iamVjdFxuICB9LFxuICByZW5kZXIoaCwgY29udGV4dCkge1xuICAgIGxldCBlbGVtZW50XG4gICAgbGV0IGRhdGEgPSBPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0LmRhdGEpXG5cbiAgICBpZiAoY29udGV4dC5wcm9wcy5saW5rICYmIGNvbnRleHQucGFyZW50LiRyb3V0ZXIpIHtcbiAgICAgIC8vIHJvdXRlci1saW5rIGNhc2VcbiAgICAgIGVsZW1lbnQgPSBjb250ZXh0LnBhcmVudC4kcm9vdC4kb3B0aW9ucy5jb21wb25lbnRzWydyb3V0ZXItbGluayddXG4gICAgICBkYXRhLnByb3BzID0gT2JqZWN0LmFzc2lnbih7IHRhZzogY29udGV4dC5wcm9wcy50YWcgfSwgY29udGV4dC5wcm9wcy5saW5rKVxuICAgICAgZGF0YS5hdHRycy5yb2xlID0gJ2J1dHRvbidcbiAgICAgIGlmIChkYXRhLm9uLmNsaWNrKSB7XG4gICAgICAgIGRhdGEubmF0aXZlT24gPSB7IGNsaWNrOiBkYXRhLm9uLmNsaWNrIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy5ocmVmKSB7XG4gICAgICAvLyBocmVmIGNhc2VcbiAgICAgIGVsZW1lbnQgPSAnYSdcbiAgICAgIGRhdGEuYXR0cnMucm9sZSA9ICdidXR0b24nXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGJ1dHRvbiBmYWxsYmFja1xuICAgICAgZWxlbWVudCA9ICdidXR0b24nXG4gICAgfVxuXG4gICAgcmV0dXJuIGgoZWxlbWVudCwgZGF0YSwgY29udGV4dC5jaGlsZHJlbilcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgQ3VzdG9tQnV0dG9uTWl4aW4gPSB7XG4gIHByb3BzOiB7XG4gICAgaHJlZjogU3RyaW5nLFxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgIHRvOiBbU3RyaW5nLCBPYmplY3RdLFxuICAgIGV4YWN0OiBCb29sZWFuLFxuICAgIGFwcGVuZDogQm9vbGVhbixcbiAgICByZXBsYWNlOiBCb29sZWFuLFxuICAgIGFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgZXhhY3RBY3RpdmVDbGFzczogU3RyaW5nXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgbGluaygpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMudG8gJiYge1xuICAgICAgICAgIHRvOiB0aGlzLnRvLFxuICAgICAgICAgIGV4YWN0OiB0aGlzLmV4YWN0LFxuICAgICAgICAgIGFwcGVuZDogdGhpcy5hcHBlbmQsXG4gICAgICAgICAgcmVwbGFjZTogdGhpcy5yZXBsYWNlLFxuICAgICAgICAgIGFjdGl2ZUNsYXNzOiB0aGlzLmFjdGl2ZUNsYXNzLFxuICAgICAgICAgIGV4YWN0QWN0aXZlQ2xhc3M6IHRoaXMuZXhhY3RBY3RpdmVDbGFzc1xuICAgICAgICB9XG4gICAgICApXG4gICAgfVxuICB9LFxuICBjb21wb25lbnRzOiB7XG4gICAgQ3VzdG9tQnV0dG9uXG4gIH1cbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBleHRyYWN0SWNvblByb3AoaWNvblByb3ApIHtcbiAgaWYgKHR5cGVvZiBpY29uUHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3NlczogeyAnbWF0ZXJpYWwtaWNvbnMnOiB0cnVlIH0sXG4gICAgICBjb250ZW50OiBpY29uUHJvcFxuICAgIH1cbiAgfSBlbHNlIGlmIChpY29uUHJvcCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IGljb25Qcm9wLnJlZHVjZShcbiAgICAgICAgKHJlc3VsdCwgdmFsdWUpID0+IE9iamVjdC5hc3NpZ24ocmVzdWx0LCB7IFt2YWx1ZV06IHRydWUgfSksXG4gICAgICAgIHt9XG4gICAgICApXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBpY29uUHJvcCA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3NlczogaWNvblByb3AuY2xhc3NOYW1lXG4gICAgICAgIC5zcGxpdCgnICcpXG4gICAgICAgIC5yZWR1Y2UoXG4gICAgICAgICAgKHJlc3VsdCwgdmFsdWUpID0+IE9iamVjdC5hc3NpZ24ocmVzdWx0LCB7IFt2YWx1ZV06IHRydWUgfSksXG4gICAgICAgICAge31cbiAgICAgICAgKSxcbiAgICAgIGNvbnRlbnQ6IGljb25Qcm9wLnRleHRDb250ZW50XG4gICAgfVxuICB9XG59XG4iLCJleHBvcnQgY29uc3QgRGlzcGF0Y2hFdmVudE1peGluID0ge1xuICBwcm9wczoge1xuICAgIGV2ZW50OiBTdHJpbmcsXG4gICAgJ2V2ZW50LXRhcmdldCc6IE9iamVjdCxcbiAgICAnZXZlbnQtYXJncyc6IEFycmF5XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBkaXNwYXRjaEV2ZW50KGV2dCkge1xuICAgICAgZXZ0ICYmIHRoaXMuJGVtaXQoZXZ0LnR5cGUsIGV2dClcbiAgICAgIGlmICh0aGlzLmV2ZW50KSB7XG4gICAgICAgIGxldCB0YXJnZXQgPSB0aGlzLmV2ZW50VGFyZ2V0IHx8IHRoaXMuJHJvb3RcbiAgICAgICAgbGV0IGFyZ3MgPSB0aGlzLmV2ZW50QXJncyB8fCBbXVxuICAgICAgICB0YXJnZXQuJGVtaXQodGhpcy5ldmVudCwgLi4uYXJncylcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgbGlzdGVuZXJzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4udGhpcy4kbGlzdGVuZXJzLFxuICAgICAgICBjbGljazogZSA9PiB0aGlzLmRpc3BhdGNoRXZlbnQoZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsImV4cG9ydCBjb25zdCBEaXNwYXRjaEZvY3VzTWl4aW4gPSB7XG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHsgaGFzRm9jdXM6IGZhbHNlIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uTW91c2VEb3duKCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZVxuICAgIH0sXG4gICAgb25Nb3VzZVVwKCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2VcbiAgICB9LFxuICAgIG9uRm9jdXNFdmVudCgpIHtcbiAgICAgIC8vIGRpc3BhdGNoIGFzeW5jIHRvIGxldCB0aW1lIHRvIG90aGVyIGZvY3VzIGV2ZW50IHRvIHByb3BhZ2F0ZVxuICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmRpc3BhdGNoRm9jdXNFdmVudCgpLCAwKVxuICAgIH0sXG4gICAgb25CbHVyRXZlbnQoKSB7XG4gICAgICAvLyBkaXNwYXRjaCBhc3luYyB0byBsZXQgdGltZSB0byBvdGhlciBmb2N1cyBldmVudCB0byBwcm9wYWdhdGVcbiAgICAgIC8vIGFsc28gZmlsdHVyIGJsdXIgaWYgbW91c2Vkb3duXG4gICAgICB0aGlzLl9hY3RpdmUgfHwgc2V0VGltZW91dCgoKSA9PiB0aGlzLmRpc3BhdGNoRm9jdXNFdmVudCgpLCAwKVxuICAgIH0sXG4gICAgZGlzcGF0Y2hGb2N1c0V2ZW50KCkge1xuICAgICAgbGV0IGhhc0ZvY3VzID1cbiAgICAgICAgdGhpcy4kZWwgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHxcbiAgICAgICAgdGhpcy4kZWwuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudClcbiAgICAgIGlmIChoYXNGb2N1cyAhPSB0aGlzLmhhc0ZvY3VzKSB7XG4gICAgICAgIHRoaXMuJGVtaXQoaGFzRm9jdXMgPyAnZm9jdXMnIDogJ2JsdXInKVxuICAgICAgICB0aGlzLmhhc0ZvY3VzID0gaGFzRm9jdXNcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIHRoaXMub25Gb2N1c0V2ZW50KVxuICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgdGhpcy5vbkJsdXJFdmVudClcbiAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2VEb3duKVxuICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLm9uTW91c2VVcClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgdGhpcy5vbkZvY3VzRXZlbnQpXG4gICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCB0aGlzLm9uQmx1ckV2ZW50KVxuICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24pXG4gICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwKVxuICB9XG59XG4iLCJjb25zdCBzY29wZSA9XG4gIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE1hdGguZmxvb3IoMHgxMDAwMDAwMCkpLnRvU3RyaW5nKCkgKyAnLSdcblxuZXhwb3J0IGNvbnN0IFZNQVVuaXF1ZUlkTWl4aW4gPSB7XG4gIGJlZm9yZUNyZWF0ZSgpIHtcbiAgICB0aGlzLnZtYV91aWRfID0gc2NvcGUgKyB0aGlzLl91aWRcbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIEFcbiAqL1xuY2xhc3MgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW17Y3NzQ2xhc3Nlc30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gYW4gb2JqZWN0IHdoaWNoIGV4cG9ydHMgZXZlcnlcbiAgICAvLyBDU1MgY2xhc3MgdGhlIGZvdW5kYXRpb24gY2xhc3MgbmVlZHMgYXMgYSBwcm9wZXJ0eS4gZS5nLiB7QUNUSVZFOiAnbWRjLWNvbXBvbmVudC0tYWN0aXZlJ31cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVte3N0cmluZ3N9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIHNob3VsZCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGFuIG9iamVjdCB3aGljaCBleHBvcnRzIGFsbFxuICAgIC8vIHNlbWFudGljIHN0cmluZ3MgYXMgY29uc3RhbnRzLiBlLmcuIHtBUklBX1JPTEU6ICd0YWJsaXN0J31cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVte251bWJlcnN9ICovXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIHNob3VsZCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGFuIG9iamVjdCB3aGljaCBleHBvcnRzIGFsbFxuICAgIC8vIG9mIGl0cyBzZW1hbnRpYyBudW1iZXJzIGFzIGNvbnN0YW50cy4gZS5nLiB7QU5JTUFUSU9OX0RFTEFZX01TOiAzNTB9XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqIEByZXR1cm4geyFPYmplY3R9ICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBtYXkgY2hvb3NlIHRvIGltcGxlbWVudCB0aGlzIGdldHRlciBpbiBvcmRlciB0byBwcm92aWRlIGEgY29udmVuaWVudFxuICAgIC8vIHdheSBvZiB2aWV3aW5nIHRoZSBuZWNlc3NhcnkgbWV0aG9kcyBvZiBhbiBhZGFwdGVyLiBJbiB0aGUgZnV0dXJlLCB0aGlzIGNvdWxkIGFsc28gYmUgdXNlZCBmb3IgYWRhcHRlclxuICAgIC8vIHZhbGlkYXRpb24uXG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QT19IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIgPSB7fSkge1xuICAgIC8qKiBAcHJvdGVjdGVkIHshQX0gKi9cbiAgICB0aGlzLmFkYXB0ZXJfID0gYWRhcHRlcjtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcGVyZm9ybSBpbml0aWFsaXphdGlvbiByb3V0aW5lcyAocmVnaXN0ZXJpbmcgZXZlbnRzLCBldGMuKVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICAvLyBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwZXJmb3JtIGRlLWluaXRpYWxpemF0aW9uIHJvdXRpbmVzIChkZS1yZWdpc3RlcmluZyBldmVudHMsIGV0Yy4pXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDRm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgUmlwcGxlLiBQcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIG1hbmFnaW5nXG4gKiAtIGNsYXNzZXNcbiAqIC0gZG9tXG4gKiAtIENTUyB2YXJpYWJsZXNcbiAqIC0gcG9zaXRpb25cbiAqIC0gZGltZW5zaW9uc1xuICogLSBzY3JvbGwgcG9zaXRpb25cbiAqIC0gZXZlbnQgaGFuZGxlcnNcbiAqIC0gdW5ib3VuZGVkLCBhY3RpdmUgYW5kIGRpc2FibGVkIHN0YXRlc1xuICpcbiAqIEFkZGl0aW9uYWxseSwgcHJvdmlkZXMgdHlwZSBpbmZvcm1hdGlvbiBmb3IgdGhlIGFkYXB0ZXIgdG8gdGhlIENsb3N1cmVcbiAqIGNvbXBpbGVyLlxuICpcbiAqIEltcGxlbWVudCB0aGlzIGFkYXB0ZXIgZm9yIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZSB0byBkZWxlZ2F0ZSB1cGRhdGVzIHRvXG4gKiB0aGUgY29tcG9uZW50IGluIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZS4gU2VlIGFyY2hpdGVjdHVyZSBkb2N1bWVudGF0aW9uXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9jb2RlL2FyY2hpdGVjdHVyZS5tZFxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDUmlwcGxlQWRhcHRlciB7XG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBicm93c2VyU3VwcG9ydHNDc3NWYXJzKCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNVbmJvdW5kZWQoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc1N1cmZhY2VBY3RpdmUoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc1N1cmZhY2VEaXNhYmxlZCgpIHt9XG5cbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHBhcmFtIHshRXZlbnRUYXJnZXR9IHRhcmdldCAqL1xuICBjb250YWluc0V2ZW50VGFyZ2V0KHRhcmdldCkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVyUmVzaXplSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhck5hbWVcbiAgICogQHBhcmFtIHs/bnVtYmVyfHN0cmluZ30gdmFsdWVcbiAgICovXG4gIHVwZGF0ZUNzc1ZhcmlhYmxlKHZhck5hbWUsIHZhbHVlKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHshQ2xpZW50UmVjdH0gKi9cbiAgY29tcHV0ZUJvdW5kaW5nUmVjdCgpIHt9XG5cbiAgLyoqIEByZXR1cm4ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19ICovXG4gIGdldFdpbmRvd1BhZ2VPZmZzZXQoKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENSaXBwbGVBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIC8vIFJpcHBsZSBpcyBhIHNwZWNpYWwgY2FzZSB3aGVyZSB0aGUgXCJyb290XCIgY29tcG9uZW50IGlzIHJlYWxseSBhIFwibWl4aW5cIiBvZiBzb3J0cyxcbiAgLy8gZ2l2ZW4gdGhhdCBpdCdzIGFuICd1cGdyYWRlJyB0byBhbiBleGlzdGluZyBjb21wb25lbnQuIFRoYXQgYmVpbmcgc2FpZCBpdCBpcyB0aGUgcm9vdFxuICAvLyBDU1MgY2xhc3MgdGhhdCBhbGwgb3RoZXIgQ1NTIGNsYXNzZXMgZGVyaXZlIGZyb20uXG4gIFJPT1Q6ICdtZGMtcmlwcGxlLXVwZ3JhZGVkJyxcbiAgVU5CT1VOREVEOiAnbWRjLXJpcHBsZS11cGdyYWRlZC0tdW5ib3VuZGVkJyxcbiAgQkdfRk9DVVNFRDogJ21kYy1yaXBwbGUtdXBncmFkZWQtLWJhY2tncm91bmQtZm9jdXNlZCcsXG4gIEZHX0FDVElWQVRJT046ICdtZGMtcmlwcGxlLXVwZ3JhZGVkLS1mb3JlZ3JvdW5kLWFjdGl2YXRpb24nLFxuICBGR19ERUFDVElWQVRJT046ICdtZGMtcmlwcGxlLXVwZ3JhZGVkLS1mb3JlZ3JvdW5kLWRlYWN0aXZhdGlvbicsXG59O1xuXG5jb25zdCBzdHJpbmdzID0ge1xuICBWQVJfTEVGVDogJy0tbWRjLXJpcHBsZS1sZWZ0JyxcbiAgVkFSX1RPUDogJy0tbWRjLXJpcHBsZS10b3AnLFxuICBWQVJfRkdfU0laRTogJy0tbWRjLXJpcHBsZS1mZy1zaXplJyxcbiAgVkFSX0ZHX1NDQUxFOiAnLS1tZGMtcmlwcGxlLWZnLXNjYWxlJyxcbiAgVkFSX0ZHX1RSQU5TTEFURV9TVEFSVDogJy0tbWRjLXJpcHBsZS1mZy10cmFuc2xhdGUtc3RhcnQnLFxuICBWQVJfRkdfVFJBTlNMQVRFX0VORDogJy0tbWRjLXJpcHBsZS1mZy10cmFuc2xhdGUtZW5kJyxcbn07XG5cbmNvbnN0IG51bWJlcnMgPSB7XG4gIFBBRERJTkc6IDEwLFxuICBJTklUSUFMX09SSUdJTl9TQ0FMRTogMC42LFxuICBERUFDVElWQVRJT05fVElNRU9VVF9NUzogMjI1LCAvLyBDb3JyZXNwb25kcyB0byAkbWRjLXJpcHBsZS10cmFuc2xhdGUtZHVyYXRpb24gKGkuZS4gYWN0aXZhdGlvbiBhbmltYXRpb24gZHVyYXRpb24pXG4gIEZHX0RFQUNUSVZBVElPTl9NUzogMTUwLCAvLyBDb3JyZXNwb25kcyB0byAkbWRjLXJpcHBsZS1mYWRlLW91dC1kdXJhdGlvbiAoaS5lLiBkZWFjdGl2YXRpb24gYW5pbWF0aW9uIGR1cmF0aW9uKVxuICBUQVBfREVMQVlfTVM6IDMwMCwgLy8gRGVsYXkgYmV0d2VlbiB0b3VjaCBhbmQgc2ltdWxhdGVkIG1vdXNlIGV2ZW50cyBvbiB0b3VjaCBkZXZpY2VzXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogU3RvcmVzIHJlc3VsdCBmcm9tIHN1cHBvcnRzQ3NzVmFyaWFibGVzIHRvIGF2b2lkIHJlZHVuZGFudCBwcm9jZXNzaW5nIHRvIGRldGVjdCBDU1MgY3VzdG9tIHZhcmlhYmxlIHN1cHBvcnQuXG4gKiBAcHJpdmF0ZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gKi9cbmxldCBzdXBwb3J0c0Nzc1ZhcmlhYmxlc187XG5cbi8qKlxuICogU3RvcmVzIHJlc3VsdCBmcm9tIGFwcGx5UGFzc2l2ZSB0byBhdm9pZCByZWR1bmRhbnQgcHJvY2Vzc2luZyB0byBkZXRlY3QgcGFzc2l2ZSBldmVudCBsaXN0ZW5lciBzdXBwb3J0LlxuICogQHByaXZhdGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICovXG5sZXQgc3VwcG9ydHNQYXNzaXZlXztcblxuLyoqXG4gKiBAcGFyYW0geyFXaW5kb3d9IHdpbmRvd09ialxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0RWRnZVBzZXVkb1ZhckJ1Zyh3aW5kb3dPYmopIHtcbiAgLy8gRGV0ZWN0IHZlcnNpb25zIG9mIEVkZ2Ugd2l0aCBidWdneSB2YXIoKSBzdXBwb3J0XG4gIC8vIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTE0OTU0NDgvXG4gIGNvbnN0IGRvY3VtZW50ID0gd2luZG93T2JqLmRvY3VtZW50O1xuICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIG5vZGUuY2xhc3NOYW1lID0gJ21kYy1yaXBwbGUtc3VyZmFjZS0tdGVzdC1lZGdlLXZhci1idWcnO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG5vZGUpO1xuXG4gIC8vIFRoZSBidWcgZXhpc3RzIGlmIDo6YmVmb3JlIHN0eWxlIGVuZHMgdXAgcHJvcGFnYXRpbmcgdG8gdGhlIHBhcmVudCBlbGVtZW50LlxuICAvLyBBZGRpdGlvbmFsbHksIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyBudWxsIGluIGlmcmFtZXMgd2l0aCBkaXNwbGF5OiBcIm5vbmVcIiBpbiBGaXJlZm94LFxuICAvLyBidXQgRmlyZWZveCBpcyBrbm93biB0byBzdXBwb3J0IENTUyBjdXN0b20gcHJvcGVydGllcyBjb3JyZWN0bHkuXG4gIC8vIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTQ4Mzk3XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSB3aW5kb3dPYmouZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgY29uc3QgaGFzUHNldWRvVmFyQnVnID0gY29tcHV0ZWRTdHlsZSAhPT0gbnVsbCAmJiBjb21wdXRlZFN0eWxlLmJvcmRlclRvcFN0eWxlID09PSAnc29saWQnO1xuICBub2RlLnJlbW92ZSgpO1xuICByZXR1cm4gaGFzUHNldWRvVmFyQnVnO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IVdpbmRvd30gd2luZG93T2JqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBmb3JjZVJlZnJlc2hcbiAqIEByZXR1cm4ge2Jvb2xlYW58dW5kZWZpbmVkfVxuICovXG5cbmZ1bmN0aW9uIHN1cHBvcnRzQ3NzVmFyaWFibGVzKHdpbmRvd09iaiwgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgbGV0IHN1cHBvcnRzQ3NzVmFyaWFibGVzID0gc3VwcG9ydHNDc3NWYXJpYWJsZXNfO1xuICBpZiAodHlwZW9mIHN1cHBvcnRzQ3NzVmFyaWFibGVzXyA9PT0gJ2Jvb2xlYW4nICYmICFmb3JjZVJlZnJlc2gpIHtcbiAgICByZXR1cm4gc3VwcG9ydHNDc3NWYXJpYWJsZXM7XG4gIH1cblxuICBjb25zdCBzdXBwb3J0c0Z1bmN0aW9uUHJlc2VudCA9IHdpbmRvd09iai5DU1MgJiYgdHlwZW9mIHdpbmRvd09iai5DU1Muc3VwcG9ydHMgPT09ICdmdW5jdGlvbic7XG4gIGlmICghc3VwcG9ydHNGdW5jdGlvblByZXNlbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBleHBsaWNpdGx5U3VwcG9ydHNDc3NWYXJzID0gd2luZG93T2JqLkNTUy5zdXBwb3J0cygnLS1jc3MtdmFycycsICd5ZXMnKTtcbiAgLy8gU2VlOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU0NjY5XG4gIC8vIFNlZTogUkVBRE1FIHNlY3Rpb24gb24gU2FmYXJpXG4gIGNvbnN0IHdlQXJlRmVhdHVyZURldGVjdGluZ1NhZmFyaTEwcGx1cyA9IChcbiAgICB3aW5kb3dPYmouQ1NTLnN1cHBvcnRzKCcoLS1jc3MtdmFyczogeWVzKScpICYmXG4gICAgd2luZG93T2JqLkNTUy5zdXBwb3J0cygnY29sb3InLCAnIzAwMDAwMDAwJylcbiAgKTtcblxuICBpZiAoZXhwbGljaXRseVN1cHBvcnRzQ3NzVmFycyB8fCB3ZUFyZUZlYXR1cmVEZXRlY3RpbmdTYWZhcmkxMHBsdXMpIHtcbiAgICBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyA9ICFkZXRlY3RFZGdlUHNldWRvVmFyQnVnKHdpbmRvd09iaik7XG4gIH0gZWxzZSB7XG4gICAgc3VwcG9ydHNDc3NWYXJpYWJsZXMgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICghZm9yY2VSZWZyZXNoKSB7XG4gICAgc3VwcG9ydHNDc3NWYXJpYWJsZXNfID0gc3VwcG9ydHNDc3NWYXJpYWJsZXM7XG4gIH1cbiAgcmV0dXJuIHN1cHBvcnRzQ3NzVmFyaWFibGVzO1xufVxuXG4vL1xuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgY3VycmVudCBicm93c2VyIHN1cHBvcnRzIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzLCBhbmQgaWYgc28sIHVzZSB0aGVtLlxuICogQHBhcmFtIHshV2luZG93PX0gZ2xvYmFsT2JqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBmb3JjZVJlZnJlc2hcbiAqIEByZXR1cm4ge2Jvb2xlYW58e3Bhc3NpdmU6IGJvb2xlYW59fVxuICovXG5mdW5jdGlvbiBhcHBseVBhc3NpdmUoZ2xvYmFsT2JqID0gd2luZG93LCBmb3JjZVJlZnJlc2ggPSBmYWxzZSkge1xuICBpZiAoc3VwcG9ydHNQYXNzaXZlXyA9PT0gdW5kZWZpbmVkIHx8IGZvcmNlUmVmcmVzaCkge1xuICAgIGxldCBpc1N1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBnbG9iYWxPYmouZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIHtnZXQgcGFzc2l2ZSgpIHtcbiAgICAgICAgaXNTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgfX0pO1xuICAgIH0gY2F0Y2ggKGUpIHsgfVxuXG4gICAgc3VwcG9ydHNQYXNzaXZlXyA9IGlzU3VwcG9ydGVkO1xuICB9XG5cbiAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZV8gPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFPYmplY3R9IEhUTUxFbGVtZW50UHJvdG90eXBlXG4gKiBAcmV0dXJuIHshQXJyYXk8c3RyaW5nPn1cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hlc1Byb3BlcnR5KEhUTUxFbGVtZW50UHJvdG90eXBlKSB7XG4gIHJldHVybiBbXG4gICAgJ3dlYmtpdE1hdGNoZXNTZWxlY3RvcicsICdtc01hdGNoZXNTZWxlY3RvcicsICdtYXRjaGVzJyxcbiAgXS5maWx0ZXIoKHApID0+IHAgaW4gSFRNTEVsZW1lbnRQcm90b3R5cGUpLnBvcCgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IUV2ZW50fSBldlxuICogQHBhcmFtIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSBwYWdlT2Zmc2V0XG4gKiBAcGFyYW0geyFDbGllbnRSZWN0fSBjbGllbnRSZWN0XG4gKiBAcmV0dXJuIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICovXG5mdW5jdGlvbiBnZXROb3JtYWxpemVkRXZlbnRDb29yZHMoZXYsIHBhZ2VPZmZzZXQsIGNsaWVudFJlY3QpIHtcbiAgY29uc3Qge3gsIHl9ID0gcGFnZU9mZnNldDtcbiAgY29uc3QgZG9jdW1lbnRYID0geCArIGNsaWVudFJlY3QubGVmdDtcbiAgY29uc3QgZG9jdW1lbnRZID0geSArIGNsaWVudFJlY3QudG9wO1xuXG4gIGxldCBub3JtYWxpemVkWDtcbiAgbGV0IG5vcm1hbGl6ZWRZO1xuICAvLyBEZXRlcm1pbmUgdG91Y2ggcG9pbnQgcmVsYXRpdmUgdG8gdGhlIHJpcHBsZSBjb250YWluZXIuXG4gIGlmIChldi50eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICBub3JtYWxpemVkWCA9IGV2LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYIC0gZG9jdW1lbnRYO1xuICAgIG5vcm1hbGl6ZWRZID0gZXYuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVkgLSBkb2N1bWVudFk7XG4gIH0gZWxzZSB7XG4gICAgbm9ybWFsaXplZFggPSBldi5wYWdlWCAtIGRvY3VtZW50WDtcbiAgICBub3JtYWxpemVkWSA9IGV2LnBhZ2VZIC0gZG9jdW1lbnRZO1xuICB9XG5cbiAgcmV0dXJuIHt4OiBub3JtYWxpemVkWCwgeTogbm9ybWFsaXplZFl9O1xufVxuXG5leHBvcnQge3N1cHBvcnRzQ3NzVmFyaWFibGVzLCBhcHBseVBhc3NpdmUsIGdldE1hdGNoZXNQcm9wZXJ0eSwgZ2V0Tm9ybWFsaXplZEV2ZW50Q29vcmRzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENSaXBwbGVBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7Z2V0Tm9ybWFsaXplZEV2ZW50Q29vcmRzfSBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGlzQWN0aXZhdGVkOiAoYm9vbGVhbnx1bmRlZmluZWQpLFxuICogICBoYXNEZWFjdGl2YXRpb25VWFJ1bjogKGJvb2xlYW58dW5kZWZpbmVkKSxcbiAqICAgd2FzQWN0aXZhdGVkQnlQb2ludGVyOiAoYm9vbGVhbnx1bmRlZmluZWQpLFxuICogICB3YXNFbGVtZW50TWFkZUFjdGl2ZTogKGJvb2xlYW58dW5kZWZpbmVkKSxcbiAqICAgYWN0aXZhdGlvbkV2ZW50OiBFdmVudCxcbiAqICAgaXNQcm9ncmFtbWF0aWM6IChib29sZWFufHVuZGVmaW5lZClcbiAqIH19XG4gKi9cbmxldCBBY3RpdmF0aW9uU3RhdGVUeXBlO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGFjdGl2YXRlOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gKiAgIGRlYWN0aXZhdGU6IChzdHJpbmd8dW5kZWZpbmVkKSxcbiAqICAgZm9jdXM6IChzdHJpbmd8dW5kZWZpbmVkKSxcbiAqICAgYmx1cjogKHN0cmluZ3x1bmRlZmluZWQpXG4gKiB9fVxuICovXG5sZXQgTGlzdGVuZXJJbmZvVHlwZTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBhY3RpdmF0ZTogZnVuY3Rpb24oIUV2ZW50KSxcbiAqICAgZGVhY3RpdmF0ZTogZnVuY3Rpb24oIUV2ZW50KSxcbiAqICAgZm9jdXM6IGZ1bmN0aW9uKCksXG4gKiAgIGJsdXI6IGZ1bmN0aW9uKClcbiAqIH19XG4gKi9cbmxldCBMaXN0ZW5lcnNUeXBlO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIHg6IG51bWJlcixcbiAqICAgeTogbnVtYmVyXG4gKiB9fVxuICovXG5sZXQgUG9pbnRUeXBlO1xuXG4vLyBBY3RpdmF0aW9uIGV2ZW50cyByZWdpc3RlcmVkIG9uIHRoZSByb290IGVsZW1lbnQgb2YgZWFjaCBpbnN0YW5jZSBmb3IgYWN0aXZhdGlvblxuY29uc3QgQUNUSVZBVElPTl9FVkVOVF9UWVBFUyA9IFsndG91Y2hzdGFydCcsICdwb2ludGVyZG93bicsICdtb3VzZWRvd24nLCAna2V5ZG93biddO1xuXG4vLyBEZWFjdGl2YXRpb24gZXZlbnRzIHJlZ2lzdGVyZWQgb24gZG9jdW1lbnRFbGVtZW50IHdoZW4gYSBwb2ludGVyLXJlbGF0ZWQgZG93biBldmVudCBvY2N1cnNcbmNvbnN0IFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTID0gWyd0b3VjaGVuZCcsICdwb2ludGVydXAnLCAnbW91c2V1cCddO1xuXG4vLyBUcmFja3MgYWN0aXZhdGlvbnMgdGhhdCBoYXZlIG9jY3VycmVkIG9uIHRoZSBjdXJyZW50IGZyYW1lLCB0byBhdm9pZCBzaW11bHRhbmVvdXMgbmVzdGVkIGFjdGl2YXRpb25zXG4vKiogQHR5cGUgeyFBcnJheTwhRXZlbnRUYXJnZXQ+fSAqL1xubGV0IGFjdGl2YXRlZFRhcmdldHMgPSBbXTtcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDUmlwcGxlQWRhcHRlcj59XG4gKi9cbmNsYXNzIE1EQ1JpcHBsZUZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIHJldHVybiBudW1iZXJzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYnJvd3NlclN1cHBvcnRzQ3NzVmFyczogKCkgPT4gLyogYm9vbGVhbiAtIGNhY2hlZCAqLyB7fSxcbiAgICAgIGlzVW5ib3VuZGVkOiAoKSA9PiAvKiBib29sZWFuICovIHt9LFxuICAgICAgaXNTdXJmYWNlQWN0aXZlOiAoKSA9PiAvKiBib29sZWFuICovIHt9LFxuICAgICAgaXNTdXJmYWNlRGlzYWJsZWQ6ICgpID0+IC8qIGJvb2xlYW4gKi8ge30sXG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgY29udGFpbnNFdmVudFRhcmdldDogKC8qIHRhcmdldDogIUV2ZW50VGFyZ2V0ICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0VHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnRUeXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dFR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnRUeXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgdXBkYXRlQ3NzVmFyaWFibGU6ICgvKiB2YXJOYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgY29tcHV0ZUJvdW5kaW5nUmVjdDogKCkgPT4gLyogQ2xpZW50UmVjdCAqLyB7fSxcbiAgICAgIGdldFdpbmRvd1BhZ2VPZmZzZXQ6ICgpID0+IC8qIHt4OiBudW1iZXIsIHk6IG51bWJlcn0gKi8ge30sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1JpcHBsZUZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMubGF5b3V0RnJhbWVfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUNsaWVudFJlY3R9ICovXG4gICAgdGhpcy5mcmFtZV8gPSAvKiogQHR5cGUgeyFDbGllbnRSZWN0fSAqLyAoe3dpZHRoOiAwLCBoZWlnaHQ6IDB9KTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUFjdGl2YXRpb25TdGF0ZVR5cGV9ICovXG4gICAgdGhpcy5hY3RpdmF0aW9uU3RhdGVfID0gdGhpcy5kZWZhdWx0QWN0aXZhdGlvblN0YXRlXygpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5pbml0aWFsU2l6ZV8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5tYXhSYWRpdXNfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KX0gKi9cbiAgICB0aGlzLmFjdGl2YXRlSGFuZGxlcl8gPSAoZSkgPT4gdGhpcy5hY3RpdmF0ZV8oZSk7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCl9ICovXG4gICAgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcl8gPSAoZSkgPT4gdGhpcy5kZWFjdGl2YXRlXyhlKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oP0V2ZW50PSl9ICovXG4gICAgdGhpcy5mb2N1c0hhbmRsZXJfID0gKCkgPT4gdGhpcy5oYW5kbGVGb2N1cygpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbig/RXZlbnQ9KX0gKi9cbiAgICB0aGlzLmJsdXJIYW5kbGVyXyA9ICgpID0+IHRoaXMuaGFuZGxlQmx1cigpO1xuXG4gICAgLyoqIEBwcml2YXRlIHshRnVuY3Rpb259ICovXG4gICAgdGhpcy5yZXNpemVIYW5kbGVyXyA9ICgpID0+IHRoaXMubGF5b3V0KCk7XG5cbiAgICAvKiogQHByaXZhdGUge3tsZWZ0OiBudW1iZXIsIHRvcDpudW1iZXJ9fSAqL1xuICAgIHRoaXMudW5ib3VuZGVkQ29vcmRzXyA9IHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgfTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuZmdTY2FsZV8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5hY3RpdmF0aW9uVGltZXJfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuZmdEZWFjdGl2YXRpb25SZW1vdmFsVGltZXJfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZF8gPSBmYWxzZTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUZ1bmN0aW9ufSAqL1xuICAgIHRoaXMuYWN0aXZhdGlvblRpbWVyQ2FsbGJhY2tfID0gKCkgPT4ge1xuICAgICAgdGhpcy5hY3RpdmF0aW9uQW5pbWF0aW9uSGFzRW5kZWRfID0gdHJ1ZTtcbiAgICAgIHRoaXMucnVuRGVhY3RpdmF0aW9uVVhMb2dpY0lmUmVhZHlfKCk7XG4gICAgfTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7P0V2ZW50fSAqL1xuICAgIHRoaXMucHJldmlvdXNBY3RpdmF0aW9uRXZlbnRfID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXZSBjb21wdXRlIHRoaXMgcHJvcGVydHkgc28gdGhhdCB3ZSBhcmUgbm90IHF1ZXJ5aW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjbGllbnRcbiAgICogdW50aWwgdGhlIHBvaW50IGluIHRpbWUgd2hlcmUgdGhlIGZvdW5kYXRpb24gcmVxdWVzdHMgaXQuIFRoaXMgcHJldmVudHMgc2NlbmFyaW9zIHdoZXJlXG4gICAqIGNsaWVudC1zaWRlIGZlYXR1cmUtZGV0ZWN0aW9uIG1heSBoYXBwZW4gdG9vIGVhcmx5LCBzdWNoIGFzIHdoZW4gY29tcG9uZW50cyBhcmUgcmVuZGVyZWQgb24gdGhlIHNlcnZlclxuICAgKiBhbmQgdGhlbiBpbml0aWFsaXplZCBhdCBtb3VudCB0aW1lIG9uIHRoZSBjbGllbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc1N1cHBvcnRlZF8oKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uYnJvd3NlclN1cHBvcnRzQ3NzVmFycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFBY3RpdmF0aW9uU3RhdGVUeXBlfVxuICAgKi9cbiAgZGVmYXVsdEFjdGl2YXRpb25TdGF0ZV8oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzQWN0aXZhdGVkOiBmYWxzZSxcbiAgICAgIGhhc0RlYWN0aXZhdGlvblVYUnVuOiBmYWxzZSxcbiAgICAgIHdhc0FjdGl2YXRlZEJ5UG9pbnRlcjogZmFsc2UsXG4gICAgICB3YXNFbGVtZW50TWFkZUFjdGl2ZTogZmFsc2UsXG4gICAgICBhY3RpdmF0aW9uRXZlbnQ6IG51bGwsXG4gICAgICBpc1Byb2dyYW1tYXRpYzogZmFsc2UsXG4gICAgfTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgaWYgKCF0aGlzLmlzU3VwcG9ydGVkXygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVnaXN0ZXJSb290SGFuZGxlcnNfKCk7XG5cbiAgICBjb25zdCB7Uk9PVCwgVU5CT1VOREVEfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhST09UKTtcbiAgICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzVW5ib3VuZGVkKCkpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhVTkJPVU5ERUQpO1xuICAgICAgICAvLyBVbmJvdW5kZWQgcmlwcGxlcyBuZWVkIGxheW91dCBsb2dpYyBhcHBsaWVkIGltbWVkaWF0ZWx5IHRvIHNldCBjb29yZGluYXRlcyBmb3IgYm90aCBzaGFkZSBhbmQgcmlwcGxlXG4gICAgICAgIHRoaXMubGF5b3V0SW50ZXJuYWxfKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGlmICghdGhpcy5pc1N1cHBvcnRlZF8oKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmFjdGl2YXRpb25UaW1lcl8pIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmFjdGl2YXRpb25UaW1lcl8pO1xuICAgICAgdGhpcy5hY3RpdmF0aW9uVGltZXJfID0gMDtcbiAgICAgIGNvbnN0IHtGR19BQ1RJVkFUSU9OfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoRkdfQUNUSVZBVElPTik7XG4gICAgfVxuXG4gICAgdGhpcy5kZXJlZ2lzdGVyUm9vdEhhbmRsZXJzXygpO1xuICAgIHRoaXMuZGVyZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXygpO1xuXG4gICAgY29uc3Qge1JPT1QsIFVOQk9VTkRFRH0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoUk9PVCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKFVOQk9VTkRFRCk7XG4gICAgICB0aGlzLnJlbW92ZUNzc1ZhcnNfKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcmVnaXN0ZXJSb290SGFuZGxlcnNfKCkge1xuICAgIEFDVElWQVRJT05fRVZFTlRfVFlQRVMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcih0eXBlLCB0aGlzLmFjdGl2YXRlSGFuZGxlcl8pO1xuICAgIH0pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdibHVyJywgdGhpcy5ibHVySGFuZGxlcl8pO1xuXG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNVbmJvdW5kZWQoKSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclJlc2l6ZUhhbmRsZXIodGhpcy5yZXNpemVIYW5kbGVyXyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXyhlKSB7XG4gICAgaWYgKGUudHlwZSA9PT0gJ2tleWRvd24nKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXl1cCcsIHRoaXMuZGVhY3RpdmF0ZUhhbmRsZXJfKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcl8pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGRlcmVnaXN0ZXJSb290SGFuZGxlcnNfKCkge1xuICAgIEFDVElWQVRJT05fRVZFTlRfVFlQRVMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIHRoaXMuYWN0aXZhdGVIYW5kbGVyXyk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdmb2N1cycsIHRoaXMuZm9jdXNIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdibHVyJywgdGhpcy5ibHVySGFuZGxlcl8pO1xuXG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNVbmJvdW5kZWQoKSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgZGVyZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleXVwJywgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcl8pO1xuICAgIFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIHRoaXMuZGVhY3RpdmF0ZUhhbmRsZXJfKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICByZW1vdmVDc3NWYXJzXygpIHtcbiAgICBjb25zdCB7c3RyaW5nc30gPSBNRENSaXBwbGVGb3VuZGF0aW9uO1xuICAgIE9iamVjdC5rZXlzKHN0cmluZ3MpLmZvckVhY2goKGspID0+IHtcbiAgICAgIGlmIChrLmluZGV4T2YoJ1ZBUl8nKSA9PT0gMCkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKHN0cmluZ3Nba10sIG51bGwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7P0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhY3RpdmF0ZV8oZSkge1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzU3VyZmFjZURpc2FibGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBhY3RpdmF0aW9uU3RhdGUgPSB0aGlzLmFjdGl2YXRpb25TdGF0ZV87XG4gICAgaWYgKGFjdGl2YXRpb25TdGF0ZS5pc0FjdGl2YXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEF2b2lkIHJlYWN0aW5nIHRvIGZvbGxvdy1vbiBldmVudHMgZmlyZWQgYnkgdG91Y2ggZGV2aWNlIGFmdGVyIGFuIGFscmVhZHktcHJvY2Vzc2VkIHVzZXIgaW50ZXJhY3Rpb25cbiAgICBjb25zdCBwcmV2aW91c0FjdGl2YXRpb25FdmVudCA9IHRoaXMucHJldmlvdXNBY3RpdmF0aW9uRXZlbnRfO1xuICAgIGNvbnN0IGlzU2FtZUludGVyYWN0aW9uID0gcHJldmlvdXNBY3RpdmF0aW9uRXZlbnQgJiYgZSAmJiBwcmV2aW91c0FjdGl2YXRpb25FdmVudC50eXBlICE9PSBlLnR5cGU7XG4gICAgaWYgKGlzU2FtZUludGVyYWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYWN0aXZhdGlvblN0YXRlLmlzQWN0aXZhdGVkID0gdHJ1ZTtcbiAgICBhY3RpdmF0aW9uU3RhdGUuaXNQcm9ncmFtbWF0aWMgPSBlID09PSBudWxsO1xuICAgIGFjdGl2YXRpb25TdGF0ZS5hY3RpdmF0aW9uRXZlbnQgPSBlO1xuICAgIGFjdGl2YXRpb25TdGF0ZS53YXNBY3RpdmF0ZWRCeVBvaW50ZXIgPSBhY3RpdmF0aW9uU3RhdGUuaXNQcm9ncmFtbWF0aWMgPyBmYWxzZSA6IChcbiAgICAgIGUudHlwZSA9PT0gJ21vdXNlZG93bicgfHwgZS50eXBlID09PSAndG91Y2hzdGFydCcgfHwgZS50eXBlID09PSAncG9pbnRlcmRvd24nXG4gICAgKTtcblxuICAgIGNvbnN0IGhhc0FjdGl2YXRlZENoaWxkID1cbiAgICAgIGUgJiYgYWN0aXZhdGVkVGFyZ2V0cy5sZW5ndGggPiAwICYmIGFjdGl2YXRlZFRhcmdldHMuc29tZSgodGFyZ2V0KSA9PiB0aGlzLmFkYXB0ZXJfLmNvbnRhaW5zRXZlbnRUYXJnZXQodGFyZ2V0KSk7XG4gICAgaWYgKGhhc0FjdGl2YXRlZENoaWxkKSB7XG4gICAgICAvLyBJbW1lZGlhdGVseSByZXNldCBhY3RpdmF0aW9uIHN0YXRlLCB3aGlsZSBwcmVzZXJ2aW5nIGxvZ2ljIHRoYXQgcHJldmVudHMgdG91Y2ggZm9sbG93LW9uIGV2ZW50c1xuICAgICAgdGhpcy5yZXNldEFjdGl2YXRpb25TdGF0ZV8oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZSkge1xuICAgICAgYWN0aXZhdGVkVGFyZ2V0cy5wdXNoKC8qKiBAdHlwZSB7IUV2ZW50VGFyZ2V0fSAqLyAoZS50YXJnZXQpKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVyc18oZSk7XG4gICAgfVxuXG4gICAgYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlID0gdGhpcy5jaGVja0VsZW1lbnRNYWRlQWN0aXZlXyhlKTtcbiAgICBpZiAoYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlKSB7XG4gICAgICB0aGlzLmFuaW1hdGVBY3RpdmF0aW9uXygpO1xuICAgIH1cblxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAvLyBSZXNldCBhcnJheSBvbiBuZXh0IGZyYW1lIGFmdGVyIHRoZSBjdXJyZW50IGV2ZW50IGhhcyBoYWQgYSBjaGFuY2UgdG8gYnViYmxlIHRvIHByZXZlbnQgYW5jZXN0b3IgcmlwcGxlc1xuICAgICAgYWN0aXZhdGVkVGFyZ2V0cyA9IFtdO1xuXG4gICAgICBpZiAoIWFjdGl2YXRpb25TdGF0ZS53YXNFbGVtZW50TWFkZUFjdGl2ZSAmJiAoZS5rZXkgPT09ICcgJyB8fCBlLmtleUNvZGUgPT09IDMyKSkge1xuICAgICAgICAvLyBJZiBzcGFjZSB3YXMgcHJlc3NlZCwgdHJ5IGFnYWluIHdpdGhpbiBhbiByQUYgY2FsbCB0byBkZXRlY3QgOmFjdGl2ZSwgYmVjYXVzZSBkaWZmZXJlbnQgVUFzIHJlcG9ydFxuICAgICAgICAvLyBhY3RpdmUgc3RhdGVzIGluY29uc2lzdGVudGx5IHdoZW4gdGhleSdyZSBjYWxsZWQgd2l0aGluIGV2ZW50IGhhbmRsaW5nIGNvZGU6XG4gICAgICAgIC8vIC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NjM1OTcxXG4gICAgICAgIC8vIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI5Mzc0MVxuICAgICAgICAvLyBXZSB0cnkgZmlyc3Qgb3V0c2lkZSByQUYgdG8gc3VwcG9ydCBFZGdlLCB3aGljaCBkb2VzIG5vdCBleGhpYml0IHRoaXMgcHJvYmxlbSwgYnV0IHdpbGwgY3Jhc2ggaWYgYSBDU1NcbiAgICAgICAgLy8gdmFyaWFibGUgaXMgc2V0IHdpdGhpbiBhIHJBRiBjYWxsYmFjayBmb3IgYSBzdWJtaXQgYnV0dG9uIGludGVyYWN0aW9uICgjMjI0MSkuXG4gICAgICAgIGFjdGl2YXRpb25TdGF0ZS53YXNFbGVtZW50TWFkZUFjdGl2ZSA9IHRoaXMuY2hlY2tFbGVtZW50TWFkZUFjdGl2ZV8oZSk7XG4gICAgICAgIGlmIChhY3RpdmF0aW9uU3RhdGUud2FzRWxlbWVudE1hZGVBY3RpdmUpIHtcbiAgICAgICAgICB0aGlzLmFuaW1hdGVBY3RpdmF0aW9uXygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlKSB7XG4gICAgICAgIC8vIFJlc2V0IGFjdGl2YXRpb24gc3RhdGUgaW1tZWRpYXRlbHkgaWYgZWxlbWVudCB3YXMgbm90IG1hZGUgYWN0aXZlLlxuICAgICAgICB0aGlzLmFjdGl2YXRpb25TdGF0ZV8gPSB0aGlzLmRlZmF1bHRBY3RpdmF0aW9uU3RhdGVfKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHs/RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNoZWNrRWxlbWVudE1hZGVBY3RpdmVfKGUpIHtcbiAgICByZXR1cm4gKGUgJiYgZS50eXBlID09PSAna2V5ZG93bicpID8gdGhpcy5hZGFwdGVyXy5pc1N1cmZhY2VBY3RpdmUoKSA6IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHs/RXZlbnQ9fSBldmVudCBPcHRpb25hbCBldmVudCBjb250YWluaW5nIHBvc2l0aW9uIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgYWN0aXZhdGUoZXZlbnQgPSBudWxsKSB7XG4gICAgdGhpcy5hY3RpdmF0ZV8oZXZlbnQpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGFuaW1hdGVBY3RpdmF0aW9uXygpIHtcbiAgICBjb25zdCB7VkFSX0ZHX1RSQU5TTEFURV9TVEFSVCwgVkFSX0ZHX1RSQU5TTEFURV9FTkR9ID0gTURDUmlwcGxlRm91bmRhdGlvbi5zdHJpbmdzO1xuICAgIGNvbnN0IHtGR19ERUFDVElWQVRJT04sIEZHX0FDVElWQVRJT059ID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIGNvbnN0IHtERUFDVElWQVRJT05fVElNRU9VVF9NU30gPSBNRENSaXBwbGVGb3VuZGF0aW9uLm51bWJlcnM7XG5cbiAgICB0aGlzLmxheW91dEludGVybmFsXygpO1xuXG4gICAgbGV0IHRyYW5zbGF0ZVN0YXJ0ID0gJyc7XG4gICAgbGV0IHRyYW5zbGF0ZUVuZCA9ICcnO1xuXG4gICAgaWYgKCF0aGlzLmFkYXB0ZXJfLmlzVW5ib3VuZGVkKCkpIHtcbiAgICAgIGNvbnN0IHtzdGFydFBvaW50LCBlbmRQb2ludH0gPSB0aGlzLmdldEZnVHJhbnNsYXRpb25Db29yZGluYXRlc18oKTtcbiAgICAgIHRyYW5zbGF0ZVN0YXJ0ID0gYCR7c3RhcnRQb2ludC54fXB4LCAke3N0YXJ0UG9pbnQueX1weGA7XG4gICAgICB0cmFuc2xhdGVFbmQgPSBgJHtlbmRQb2ludC54fXB4LCAke2VuZFBvaW50Lnl9cHhgO1xuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoVkFSX0ZHX1RSQU5TTEFURV9TVEFSVCwgdHJhbnNsYXRlU3RhcnQpO1xuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoVkFSX0ZHX1RSQU5TTEFURV9FTkQsIHRyYW5zbGF0ZUVuZCk7XG4gICAgLy8gQ2FuY2VsIGFueSBvbmdvaW5nIGFjdGl2YXRpb24vZGVhY3RpdmF0aW9uIGFuaW1hdGlvbnNcbiAgICBjbGVhclRpbWVvdXQodGhpcy5hY3RpdmF0aW9uVGltZXJfKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5mZ0RlYWN0aXZhdGlvblJlbW92YWxUaW1lcl8pO1xuICAgIHRoaXMucm1Cb3VuZGVkQWN0aXZhdGlvbkNsYXNzZXNfKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhGR19ERUFDVElWQVRJT04pO1xuXG4gICAgLy8gRm9yY2UgbGF5b3V0IGluIG9yZGVyIHRvIHJlLXRyaWdnZXIgdGhlIGFuaW1hdGlvbi5cbiAgICB0aGlzLmFkYXB0ZXJfLmNvbXB1dGVCb3VuZGluZ1JlY3QoKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKEZHX0FDVElWQVRJT04pO1xuICAgIHRoaXMuYWN0aXZhdGlvblRpbWVyXyA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5hY3RpdmF0aW9uVGltZXJDYWxsYmFja18oKSwgREVBQ1RJVkFUSU9OX1RJTUVPVVRfTVMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge3tzdGFydFBvaW50OiBQb2ludFR5cGUsIGVuZFBvaW50OiBQb2ludFR5cGV9fVxuICAgKi9cbiAgZ2V0RmdUcmFuc2xhdGlvbkNvb3JkaW5hdGVzXygpIHtcbiAgICBjb25zdCB7YWN0aXZhdGlvbkV2ZW50LCB3YXNBY3RpdmF0ZWRCeVBvaW50ZXJ9ID0gdGhpcy5hY3RpdmF0aW9uU3RhdGVfO1xuXG4gICAgbGV0IHN0YXJ0UG9pbnQ7XG4gICAgaWYgKHdhc0FjdGl2YXRlZEJ5UG9pbnRlcikge1xuICAgICAgc3RhcnRQb2ludCA9IGdldE5vcm1hbGl6ZWRFdmVudENvb3JkcyhcbiAgICAgICAgLyoqIEB0eXBlIHshRXZlbnR9ICovIChhY3RpdmF0aW9uRXZlbnQpLFxuICAgICAgICB0aGlzLmFkYXB0ZXJfLmdldFdpbmRvd1BhZ2VPZmZzZXQoKSwgdGhpcy5hZGFwdGVyXy5jb21wdXRlQm91bmRpbmdSZWN0KClcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0UG9pbnQgPSB7XG4gICAgICAgIHg6IHRoaXMuZnJhbWVfLndpZHRoIC8gMixcbiAgICAgICAgeTogdGhpcy5mcmFtZV8uaGVpZ2h0IC8gMixcbiAgICAgIH07XG4gICAgfVxuICAgIC8vIENlbnRlciB0aGUgZWxlbWVudCBhcm91bmQgdGhlIHN0YXJ0IHBvaW50LlxuICAgIHN0YXJ0UG9pbnQgPSB7XG4gICAgICB4OiBzdGFydFBvaW50LnggLSAodGhpcy5pbml0aWFsU2l6ZV8gLyAyKSxcbiAgICAgIHk6IHN0YXJ0UG9pbnQueSAtICh0aGlzLmluaXRpYWxTaXplXyAvIDIpLFxuICAgIH07XG5cbiAgICBjb25zdCBlbmRQb2ludCA9IHtcbiAgICAgIHg6ICh0aGlzLmZyYW1lXy53aWR0aCAvIDIpIC0gKHRoaXMuaW5pdGlhbFNpemVfIC8gMiksXG4gICAgICB5OiAodGhpcy5mcmFtZV8uaGVpZ2h0IC8gMikgLSAodGhpcy5pbml0aWFsU2l6ZV8gLyAyKSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtzdGFydFBvaW50LCBlbmRQb2ludH07XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcnVuRGVhY3RpdmF0aW9uVVhMb2dpY0lmUmVhZHlfKCkge1xuICAgIC8vIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBib3RoIHdoZW4gYSBwb2ludGluZyBkZXZpY2UgaXMgcmVsZWFzZWQsIGFuZCB3aGVuIHRoZSBhY3RpdmF0aW9uIGFuaW1hdGlvbiBlbmRzLlxuICAgIC8vIFRoZSBkZWFjdGl2YXRpb24gYW5pbWF0aW9uIHNob3VsZCBvbmx5IHJ1biBhZnRlciBib3RoIG9mIHRob3NlIG9jY3VyLlxuICAgIGNvbnN0IHtGR19ERUFDVElWQVRJT059ID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIGNvbnN0IHtoYXNEZWFjdGl2YXRpb25VWFJ1biwgaXNBY3RpdmF0ZWR9ID0gdGhpcy5hY3RpdmF0aW9uU3RhdGVfO1xuICAgIGNvbnN0IGFjdGl2YXRpb25IYXNFbmRlZCA9IGhhc0RlYWN0aXZhdGlvblVYUnVuIHx8ICFpc0FjdGl2YXRlZDtcblxuICAgIGlmIChhY3RpdmF0aW9uSGFzRW5kZWQgJiYgdGhpcy5hY3RpdmF0aW9uQW5pbWF0aW9uSGFzRW5kZWRfKSB7XG4gICAgICB0aGlzLnJtQm91bmRlZEFjdGl2YXRpb25DbGFzc2VzXygpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhGR19ERUFDVElWQVRJT04pO1xuICAgICAgdGhpcy5mZ0RlYWN0aXZhdGlvblJlbW92YWxUaW1lcl8gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhGR19ERUFDVElWQVRJT04pO1xuICAgICAgfSwgbnVtYmVycy5GR19ERUFDVElWQVRJT05fTVMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBybUJvdW5kZWRBY3RpdmF0aW9uQ2xhc3Nlc18oKSB7XG4gICAgY29uc3Qge0ZHX0FDVElWQVRJT059ID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoRkdfQUNUSVZBVElPTik7XG4gICAgdGhpcy5hY3RpdmF0aW9uQW5pbWF0aW9uSGFzRW5kZWRfID0gZmFsc2U7XG4gICAgdGhpcy5hZGFwdGVyXy5jb21wdXRlQm91bmRpbmdSZWN0KCk7XG4gIH1cblxuICByZXNldEFjdGl2YXRpb25TdGF0ZV8oKSB7XG4gICAgdGhpcy5wcmV2aW91c0FjdGl2YXRpb25FdmVudF8gPSB0aGlzLmFjdGl2YXRpb25TdGF0ZV8uYWN0aXZhdGlvbkV2ZW50O1xuICAgIHRoaXMuYWN0aXZhdGlvblN0YXRlXyA9IHRoaXMuZGVmYXVsdEFjdGl2YXRpb25TdGF0ZV8oKTtcbiAgICAvLyBUb3VjaCBkZXZpY2VzIG1heSBmaXJlIGFkZGl0aW9uYWwgZXZlbnRzIGZvciB0aGUgc2FtZSBpbnRlcmFjdGlvbiB3aXRoaW4gYSBzaG9ydCB0aW1lLlxuICAgIC8vIFN0b3JlIHRoZSBwcmV2aW91cyBldmVudCB1bnRpbCBpdCdzIHNhZmUgdG8gYXNzdW1lIHRoYXQgc3Vic2VxdWVudCBldmVudHMgYXJlIGZvciBuZXcgaW50ZXJhY3Rpb25zLlxuICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5wcmV2aW91c0FjdGl2YXRpb25FdmVudF8gPSBudWxsLCBNRENSaXBwbGVGb3VuZGF0aW9uLm51bWJlcnMuVEFQX0RFTEFZX01TKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gez9FdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGVhY3RpdmF0ZV8oZSkge1xuICAgIGNvbnN0IGFjdGl2YXRpb25TdGF0ZSA9IHRoaXMuYWN0aXZhdGlvblN0YXRlXztcbiAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaW4gc2NlbmFyaW9zIHN1Y2ggYXMgd2hlbiB5b3UgaGF2ZSBhIGtleXVwIGV2ZW50IHRoYXQgYmx1cnMgdGhlIGVsZW1lbnQuXG4gICAgaWYgKCFhY3RpdmF0aW9uU3RhdGUuaXNBY3RpdmF0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzdGF0ZSA9IC8qKiBAdHlwZSB7IUFjdGl2YXRpb25TdGF0ZVR5cGV9ICovIChPYmplY3QuYXNzaWduKHt9LCBhY3RpdmF0aW9uU3RhdGUpKTtcblxuICAgIGlmIChhY3RpdmF0aW9uU3RhdGUuaXNQcm9ncmFtbWF0aWMpIHtcbiAgICAgIGNvbnN0IGV2dE9iamVjdCA9IG51bGw7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5hbmltYXRlRGVhY3RpdmF0aW9uXyhldnRPYmplY3QsIHN0YXRlKSk7XG4gICAgICB0aGlzLnJlc2V0QWN0aXZhdGlvblN0YXRlXygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlcmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVyc18oKTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuYWN0aXZhdGlvblN0YXRlXy5oYXNEZWFjdGl2YXRpb25VWFJ1biA9IHRydWU7XG4gICAgICAgIHRoaXMuYW5pbWF0ZURlYWN0aXZhdGlvbl8oZSwgc3RhdGUpO1xuICAgICAgICB0aGlzLnJlc2V0QWN0aXZhdGlvblN0YXRlXygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7P0V2ZW50PX0gZXZlbnQgT3B0aW9uYWwgZXZlbnQgY29udGFpbmluZyBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAgICovXG4gIGRlYWN0aXZhdGUoZXZlbnQgPSBudWxsKSB7XG4gICAgdGhpcy5kZWFjdGl2YXRlXyhldmVudCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKiBAcGFyYW0geyFBY3RpdmF0aW9uU3RhdGVUeXBlfSBvcHRpb25zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhbmltYXRlRGVhY3RpdmF0aW9uXyhlLCB7d2FzQWN0aXZhdGVkQnlQb2ludGVyLCB3YXNFbGVtZW50TWFkZUFjdGl2ZX0pIHtcbiAgICBpZiAod2FzQWN0aXZhdGVkQnlQb2ludGVyIHx8IHdhc0VsZW1lbnRNYWRlQWN0aXZlKSB7XG4gICAgICB0aGlzLnJ1bkRlYWN0aXZhdGlvblVYTG9naWNJZlJlYWR5XygpO1xuICAgIH1cbiAgfVxuXG4gIGxheW91dCgpIHtcbiAgICBpZiAodGhpcy5sYXlvdXRGcmFtZV8pIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMubGF5b3V0RnJhbWVfKTtcbiAgICB9XG4gICAgdGhpcy5sYXlvdXRGcmFtZV8gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5sYXlvdXRJbnRlcm5hbF8oKTtcbiAgICAgIHRoaXMubGF5b3V0RnJhbWVfID0gMDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBsYXlvdXRJbnRlcm5hbF8oKSB7XG4gICAgdGhpcy5mcmFtZV8gPSB0aGlzLmFkYXB0ZXJfLmNvbXB1dGVCb3VuZGluZ1JlY3QoKTtcbiAgICBjb25zdCBtYXhEaW0gPSBNYXRoLm1heCh0aGlzLmZyYW1lXy5oZWlnaHQsIHRoaXMuZnJhbWVfLndpZHRoKTtcblxuICAgIC8vIFN1cmZhY2UgZGlhbWV0ZXIgaXMgdHJlYXRlZCBkaWZmZXJlbnRseSBmb3IgdW5ib3VuZGVkIHZzLiBib3VuZGVkIHJpcHBsZXMuXG4gICAgLy8gVW5ib3VuZGVkIHJpcHBsZSBkaWFtZXRlciBpcyBjYWxjdWxhdGVkIHNtYWxsZXIgc2luY2UgdGhlIHN1cmZhY2UgaXMgZXhwZWN0ZWQgdG8gYWxyZWFkeSBiZSBwYWRkZWQgYXBwcm9wcmlhdGVseVxuICAgIC8vIHRvIGV4dGVuZCB0aGUgaGl0Ym94LCBhbmQgdGhlIHJpcHBsZSBpcyBleHBlY3RlZCB0byBtZWV0IHRoZSBlZGdlcyBvZiB0aGUgcGFkZGVkIGhpdGJveCAod2hpY2ggaXMgdHlwaWNhbGx5XG4gICAgLy8gc3F1YXJlKS4gQm91bmRlZCByaXBwbGVzLCBvbiB0aGUgb3RoZXIgaGFuZCwgYXJlIGZ1bGx5IGV4cGVjdGVkIHRvIGV4cGFuZCBiZXlvbmQgdGhlIHN1cmZhY2UncyBsb25nZXN0IGRpYW1ldGVyXG4gICAgLy8gKGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIGRpYWdvbmFsIHBsdXMgYSBjb25zdGFudCBwYWRkaW5nKSwgYW5kIGFyZSBjbGlwcGVkIGF0IHRoZSBzdXJmYWNlJ3MgYm9yZGVyIHZpYVxuICAgIC8vIGBvdmVyZmxvdzogaGlkZGVuYC5cbiAgICBjb25zdCBnZXRCb3VuZGVkUmFkaXVzID0gKCkgPT4ge1xuICAgICAgY29uc3QgaHlwb3RlbnVzZSA9IE1hdGguc3FydChNYXRoLnBvdyh0aGlzLmZyYW1lXy53aWR0aCwgMikgKyBNYXRoLnBvdyh0aGlzLmZyYW1lXy5oZWlnaHQsIDIpKTtcbiAgICAgIHJldHVybiBoeXBvdGVudXNlICsgTURDUmlwcGxlRm91bmRhdGlvbi5udW1iZXJzLlBBRERJTkc7XG4gICAgfTtcblxuICAgIHRoaXMubWF4UmFkaXVzXyA9IHRoaXMuYWRhcHRlcl8uaXNVbmJvdW5kZWQoKSA/IG1heERpbSA6IGdldEJvdW5kZWRSYWRpdXMoKTtcblxuICAgIC8vIFJpcHBsZSBpcyBzaXplZCBhcyBhIGZyYWN0aW9uIG9mIHRoZSBsYXJnZXN0IGRpbWVuc2lvbiBvZiB0aGUgc3VyZmFjZSwgdGhlbiBzY2FsZXMgdXAgdXNpbmcgYSBDU1Mgc2NhbGUgdHJhbnNmb3JtXG4gICAgdGhpcy5pbml0aWFsU2l6ZV8gPSBtYXhEaW0gKiBNRENSaXBwbGVGb3VuZGF0aW9uLm51bWJlcnMuSU5JVElBTF9PUklHSU5fU0NBTEU7XG4gICAgdGhpcy5mZ1NjYWxlXyA9IHRoaXMubWF4UmFkaXVzXyAvIHRoaXMuaW5pdGlhbFNpemVfO1xuXG4gICAgdGhpcy51cGRhdGVMYXlvdXRDc3NWYXJzXygpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHVwZGF0ZUxheW91dENzc1ZhcnNfKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIFZBUl9GR19TSVpFLCBWQVJfTEVGVCwgVkFSX1RPUCwgVkFSX0ZHX1NDQUxFLFxuICAgIH0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLnN0cmluZ3M7XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKFZBUl9GR19TSVpFLCBgJHt0aGlzLmluaXRpYWxTaXplX31weGApO1xuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoVkFSX0ZHX1NDQUxFLCB0aGlzLmZnU2NhbGVfKTtcblxuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzVW5ib3VuZGVkKCkpIHtcbiAgICAgIHRoaXMudW5ib3VuZGVkQ29vcmRzXyA9IHtcbiAgICAgICAgbGVmdDogTWF0aC5yb3VuZCgodGhpcy5mcmFtZV8ud2lkdGggLyAyKSAtICh0aGlzLmluaXRpYWxTaXplXyAvIDIpKSxcbiAgICAgICAgdG9wOiBNYXRoLnJvdW5kKCh0aGlzLmZyYW1lXy5oZWlnaHQgLyAyKSAtICh0aGlzLmluaXRpYWxTaXplXyAvIDIpKSxcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoVkFSX0xFRlQsIGAke3RoaXMudW5ib3VuZGVkQ29vcmRzXy5sZWZ0fXB4YCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKFZBUl9UT1AsIGAke3RoaXMudW5ib3VuZGVkQ29vcmRzXy50b3B9cHhgKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSB1bmJvdW5kZWQgKi9cbiAgc2V0VW5ib3VuZGVkKHVuYm91bmRlZCkge1xuICAgIGNvbnN0IHtVTkJPVU5ERUR9ID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIGlmICh1bmJvdW5kZWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoVU5CT1VOREVEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhVTkJPVU5ERUQpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUZvY3VzKCkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PlxuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQkdfRk9DVVNFRCkpO1xuICB9XG5cbiAgaGFuZGxlQmx1cigpIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT5cbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzLkJHX0ZPQ1VTRUQpKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENSaXBwbGVGb3VuZGF0aW9uO1xuIiwiaW1wb3J0IE1EQ1JpcHBsZUZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3JpcHBsZS9mb3VuZGF0aW9uLmpzJ1xuaW1wb3J0IHtcbiAgc3VwcG9ydHNDc3NWYXJpYWJsZXMsXG4gIGdldE1hdGNoZXNQcm9wZXJ0eSxcbiAgYXBwbHlQYXNzaXZlXG59IGZyb20gJ0BtYXRlcmlhbC9yaXBwbGUvdXRpbCdcblxuZXhwb3J0IGNsYXNzIFJpcHBsZUJhc2UgZXh0ZW5kcyBNRENSaXBwbGVGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBNQVRDSEVTKCkge1xuICAgIC8qIGdsb2JhbCBIVE1MRWxlbWVudCAqL1xuICAgIHJldHVybiAoXG4gICAgICBSaXBwbGVCYXNlLl9tYXRjaGVzIHx8XG4gICAgICAoUmlwcGxlQmFzZS5fbWF0Y2hlcyA9IGdldE1hdGNoZXNQcm9wZXJ0eShIVE1MRWxlbWVudC5wcm90b3R5cGUpKVxuICAgIClcbiAgfVxuXG4gIHN0YXRpYyBpc1N1cmZhY2VBY3RpdmUocmVmKSB7XG4gICAgcmV0dXJuIHJlZltSaXBwbGVCYXNlLk1BVENIRVNdKCc6YWN0aXZlJylcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHZtLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoXG4gICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICB7XG4gICAgICAgICAgYnJvd3NlclN1cHBvcnRzQ3NzVmFyczogKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN1cHBvcnRzQ3NzVmFyaWFibGVzKHdpbmRvdylcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlzVW5ib3VuZGVkOiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlzU3VyZmFjZUFjdGl2ZTogKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHZtLiRlbFtSaXBwbGVCYXNlLk1BVENIRVNdKCc6YWN0aXZlJylcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlzU3VyZmFjZURpc2FibGVkOiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdm0uZGlzYWJsZWRcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFkZENsYXNzKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgdm0uJHNldCh2bS5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHZtLiRkZWxldGUodm0uY2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY29udGFpbnNFdmVudFRhcmdldDogdGFyZ2V0ID0+IHZtLiRlbC5jb250YWlucyh0YXJnZXQpLFxuICAgICAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICB2bS4kZWwuYWRkRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIsIGFwcGx5UGFzc2l2ZSgpKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgdm0uJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyLCBhcHBseVBhc3NpdmUoKSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PlxuICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgIGV2dFR5cGUsXG4gICAgICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgICAgIGFwcGx5UGFzc2l2ZSgpXG4gICAgICAgICAgICApLFxuICAgICAgICAgIGRlcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+XG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgZXZ0VHlwZSxcbiAgICAgICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICAgICAgYXBwbHlQYXNzaXZlKClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlcilcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgICAgIHJldHVybiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlcilcbiAgICAgICAgICB9LFxuICAgICAgICAgIHVwZGF0ZUNzc1ZhcmlhYmxlOiAodmFyTmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIHZtLiRzZXQodm0uc3R5bGVzLCB2YXJOYW1lLCB2YWx1ZSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbXB1dGVCb3VuZGluZ1JlY3Q6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB2bS4kZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldFdpbmRvd1BhZ2VPZmZzZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IHdpbmRvdy5wYWdlWE9mZnNldCwgeTogd2luZG93LnBhZ2VZT2Zmc2V0IH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIClcbiAgICApXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IFJpcHBsZU1peGluID0ge1xuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5yaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzKVxuICAgIHRoaXMucmlwcGxlLmluaXQoKVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMucmlwcGxlLmRlc3Ryb3koKVxuICB9XG59XG4iLCI8dGVtcGxhdGU+XG4gIDxjdXN0b20tZWxlbWVudCBcbiAgICA6dGFnPVwidGFnXCIgXG4gICAgOmNsYXNzZXM9XCJjbGFzc2VzXCJcbiAgICA6c3R5bGVzPVwic3R5bGVzXCIgXG4gICAgY2xhc3M9XCJtZGMtcmlwcGxlXCI+XG4gICAgPHNsb3QgLz5cbiAgPC9jdXN0b20tZWxlbWVudD5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBDdXN0b21FbGVtZW50TWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IHsgUmlwcGxlTWl4aW4gfSBmcm9tICcuL21kYy1yaXBwbGUtYmFzZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXJpcHBsZScsXG4gIG1peGluczogW0N1c3RvbUVsZW1lbnRNaXhpbiwgUmlwcGxlTWl4aW5dLFxuICBwcm9wczoge1xuICAgIHRhZzogU3RyaW5nXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjUmlwcGxlIGZyb20gJy4vbWRjLXJpcHBsZS52dWUnXG5cbmV4cG9ydCAqIGZyb20gJy4vbWRjLXJpcHBsZS1iYXNlLmpzJ1xuXG5leHBvcnQgeyBtZGNSaXBwbGUgfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjUmlwcGxlXG59KVxuIiwiPHRlbXBsYXRlPlxuICA8Y3VzdG9tLWJ1dHRvbiBcbiAgICByZWY9XCJyb290XCJcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgXG4gICAgOnN0eWxlPVwic3R5bGVzXCJcbiAgICA6aHJlZj1cImhyZWZcIiBcbiAgICA6bGluaz1cImxpbmtcIiBcbiAgICA6ZGlzYWJsZWQ9XCJkaXNhYmxlZFwiXG4gICAgdi1vbj1cImxpc3RlbmVyc1wiPlxuICAgIDxzbG90IC8+XG4gIDwvY3VzdG9tLWJ1dHRvbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBEaXNwYXRjaEV2ZW50TWl4aW4sIEN1c3RvbUJ1dHRvbk1peGluIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCB7IFJpcHBsZU1peGluIH0gZnJvbSAnLi4vcmlwcGxlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtYnV0dG9uLWJhc2UnLFxuICBtaXhpbnM6IFtEaXNwYXRjaEV2ZW50TWl4aW4sIEN1c3RvbUJ1dHRvbk1peGluLCBSaXBwbGVNaXhpbl0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8c2NyaXB0PlxuaW1wb3J0IG1kY0J1dHRvbkJhc2UgZnJvbSAnLi9tZGMtYnV0dG9uLWJhc2UudnVlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtYnV0dG9uJyxcbiAgZXh0ZW5kczogbWRjQnV0dG9uQmFzZSxcbiAgcHJvcHM6IHtcbiAgICByYWlzZWQ6IEJvb2xlYW4sXG4gICAgdW5lbGV2YXRlZDogQm9vbGVhbixcbiAgICBvdXRsaW5lZDogQm9vbGVhbixcbiAgICBkZW5zZTogQm9vbGVhblxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgICdtZGMtYnV0dG9uJzogdHJ1ZSxcbiAgICAgICAgJ21kYy1idXR0b24tLXJhaXNlZCc6IHRoaXMucmFpc2VkLFxuICAgICAgICAnbWRjLWJ1dHRvbi0tdW5lbGV2YXRlZCc6IHRoaXMudW5lbGV2YXRlZCxcbiAgICAgICAgJ21kYy1idXR0b24tLW91dGxpbmVkJzogdGhpcy5vdXRsaW5lZCxcbiAgICAgICAgJ21kYy1idXR0b24tLWRlbnNlJzogdGhpcy5kZW5zZVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICByYWlzZWQoKSB7XG4gICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCAnbWRjLWJ1dHRvbi0tcmFpc2VkJywgdGhpcy5yYWlzZWQpXG4gICAgfSxcbiAgICB1bmVsZXZhdGVkKCkge1xuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21kYy1idXR0b24tLXVuZWxldmF0ZWQnLCB0aGlzLnVuZWxldmF0ZWQpXG4gICAgfSxcbiAgICBvdXRsaW5lZCgpIHtcbiAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsICdtZGMtYnV0dG9uLS1vdXRsaW5lZCcsIHRoaXMub3V0bGluZWQpXG4gICAgfSxcbiAgICBkZW5zZSgpIHtcbiAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsICdtZGMtYnV0dG9uLS1kZW5zZScsIHRoaXMuZGVuc2UpXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0J1dHRvbiBmcm9tICcuL21kYy1idXR0b24udnVlJ1xuaW1wb3J0IG1kY0J1dHRvbkJhc2UgZnJvbSAnLi9tZGMtYnV0dG9uLWJhc2UudnVlJ1xuXG5leHBvcnQgeyBtZGNCdXR0b25CYXNlLCBtZGNCdXR0b24gfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjQnV0dG9uXG59KVxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2XG4gICAgOmNsYXNzPVwieydtZGMtY2FyZC0tb3V0bGluZWQnOiBvdXRsaW5lZH1cIlxuICAgIGNsYXNzPVwibWRjLWNhcmRcIj5cbiAgICA8c2xvdC8+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1jYXJkJyxcbiAgcHJvcHM6IHtcbiAgICBvdXRsaW5lZDogQm9vbGVhblxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cclxuICA8Y3VzdG9tLWxpbmsgXHJcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCJcclxuICAgIDpzdHlsZT1cInN0eWxlc1wiIFxuICAgIDpsaW5rPVwibGlua1wiIFxyXG4gICAgY2xhc3M9XCJtZGMtY2FyZC1wcmltYXJ5LWFjdGlvbiBtZGMtY2FyZF9fcHJpbWFyeS1hY3Rpb25cIiBcclxuICAgIHYtb249XCJsaXN0ZW5lcnNcIj5cclxuICAgIDxzbG90IC8+XHJcbiAgPC9jdXN0b20tbGluaz5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmltcG9ydCB7IERpc3BhdGNoRXZlbnRNaXhpbiwgQ3VzdG9tTGlua01peGluIH0gZnJvbSAnLi4vYmFzZSdcclxuaW1wb3J0IHsgUmlwcGxlTWl4aW4gfSBmcm9tICcuLi9yaXBwbGUvaW5kZXgnXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiAnbWRjLWNhcmQtcHJpbWFyeS1hY3Rpb24nLFxyXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbiwgQ3VzdG9tTGlua01peGluLCBSaXBwbGVNaXhpbl0sXHJcbiAgZGF0YSgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNsYXNzZXM6IHt9LFxyXG4gICAgICBzdHlsZXM6IHt9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG4iLCI8dGVtcGxhdGU+XHJcbiAgPHNlY3Rpb24gXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiIFxyXG4gICAgOnN0eWxlPVwic3R5bGVzXCIgXG4gICAgY2xhc3M9XCJtZGMtY2FyZC1tZWRpYSBtZGMtY2FyZF9fbWVkaWFcIj5cclxuICAgIDxkaXYgXG4gICAgICB2LWlmPVwiJHNsb3RzLmRlZmF1bHRcIiBcbiAgICAgIGNsYXNzPVwibWRjLWNhcmRfX21lZGlhLWNvbnRlbnRcIj5cclxuICAgICAgPHNsb3QvPlxyXG4gICAgPC9kaXY+XHJcbiAgPC9zZWN0aW9uPlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6ICdtZGMtY2FyZC1tZWRpYScsXHJcbiAgcHJvcHM6IHtcclxuICAgIHNyYzogU3RyaW5nLFxyXG4gICAgc3F1YXJlOiBCb29sZWFuXHJcbiAgfSxcclxuICBjb21wdXRlZDoge1xyXG4gICAgc3R5bGVzKCkge1xyXG4gICAgICB2YXIgc3R5bGVzID0ge1xyXG4gICAgICAgIGJhY2tncm91bmRJbWFnZTogYHVybCgke3RoaXMuc3JjfSlgXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzdHlsZXNcclxuICAgIH0sXHJcbiAgICBjbGFzc2VzKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zcXVhcmUgPyAnbWRjLWNhcmRfX21lZGlhLS1zcXVhcmUnIDogJ21kYy1jYXJkX19tZWRpYS0tMTYtOSdcclxuICAgIH1cclxuICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbiIsIjx0ZW1wbGF0ZT5cbiAgPHNlY3Rpb24gY2xhc3M9XCJtZGMtY2FyZC1oZWFkZXIgbWRjLWNhcmRfX3ByaW1hcnlcIj5cbiAgICA8c2xvdD5cbiAgICAgIDxoMSBcbiAgICAgICAgdi1pZj1cInRpdGxlXCJcbiAgICAgICAgOmNsYXNzPVwieydtZGMtY2FyZF9fdGl0bGUtLWxhcmdlJzogbGFyZ2VUaXRsZX1cIlxuICAgICAgICBjbGFzcz1cIm1kYy1jYXJkX190aXRsZVwiXG4gICAgICA+XG4gICAgICAgIHt7IHRpdGxlIH19XG4gICAgICA8L2gxPlxuICAgICAgPGgyIFxuICAgICAgICB2LWlmPVwic3VidGl0bGVcIlxuICAgICAgICBjbGFzcz1cIm1kYy1jYXJkX19zdWJ0aXRsZVwiXG4gICAgICA+XG4gICAgICAgIHt7IHN1YnRpdGxlIH19IFxuICAgICAgPC9oMj5cbiAgICA8L3Nsb3Q+XG4gIDwvc2VjdGlvbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtY2FyZC1oZWFkZXInLFxuICBwcm9wczoge1xuICAgIHRpdGxlOiBTdHJpbmcsXG4gICAgc3VidGl0bGU6IFN0cmluZyxcbiAgICAnbGFyZ2UtdGl0bGUnOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IHRydWUgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGgxIFxuICAgIDpjbGFzcz1cInsnbWRjLWNhcmRfX3RpdGxlLS1sYXJnZSc6IGxhcmdlfVwiXG4gICAgY2xhc3M9XCJtZGMtY2FyZC10aXRsZSBtZGMtY2FyZF9fdGl0bGVcIj5cbiAgICA8c2xvdC8+XG4gIDwvaDE+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWNhcmQtdGl0bGUnLFxuICBwcm9wczoge1xuICAgIGxhcmdlOiBCb29sZWFuXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8aDIgY2xhc3M9XCJtZGMtY2FyZC1zdWJ0aXRsZSBtZGMtY2FyZF9fc3VidGl0bGVcIj5cbiAgICA8c2xvdC8+XG4gIDwvaDI+XG48L3RlbXBsYXRlPlxuXG5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1jYXJkLXN1YnRpdGxlJ1xufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxzZWN0aW9uIGNsYXNzPVwibWRjLWNhcmQtdGV4dCBtZGMtY2FyZF9fc3VwcG9ydGluZy10ZXh0XCI+XG4gICAgPHNsb3QvPlxuICA8L3NlY3Rpb24+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWNhcmQtdGV4dCdcbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxyXG4gIDxzZWN0aW9uIFxuICAgIDpjbGFzcz1cImNsYXNzZXNcIiBcclxuICAgIGNsYXNzPVwibWRjLWNhcmQtYWN0aW9ucyBtZGMtY2FyZF9fYWN0aW9uc1wiPlxyXG4gICAgPHNsb3QvPlxyXG4gIDwvc2VjdGlvbj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiAnbWRjLWNhcmQtYWN0aW9ucycsXHJcbiAgcHJvcHM6IHtcclxuICAgIGZ1bGxCbGVlZDogQm9vbGVhblxyXG4gIH0sXHJcbiAgY29tcHV0ZWQ6IHtcclxuICAgIGNsYXNzZXMoKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgJ21kYy1jYXJkX19hY3Rpb25zLS1mdWxsLWJsZWVkJzogdGhpcy5mdWxsQmxlZWRcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG48L3NjcmlwdD5cclxuIiwiPHRlbXBsYXRlPlxyXG4gIDxkaXYgY2xhc3M9XCJtZGMtY2FyZC1hY3Rpb24tYnV0dG9ucyBtZGMtY2FyZF9fYWN0aW9uLWJ1dHRvbnNcIj5cclxuICAgIDxzbG90Lz5cclxuICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiAnbWRjLWNhcmQtYWN0aW9uLWJ1dHRvbnMnXHJcbn1cclxuPC9zY3JpcHQ+XHJcbiIsIjxzY3JpcHQ+XHJcbmltcG9ydCB7IG1kY0J1dHRvbkJhc2UgfSBmcm9tICcuLi9idXR0b24nXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgbmFtZTogJ21kYy1jYXJkLWFjdGlvbi1idXR0b24nLFxyXG4gIGV4dGVuZHM6IG1kY0J1dHRvbkJhc2UsXHJcbiAgZGF0YSgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNsYXNzZXM6IHtcclxuICAgICAgICAnbWRjLWJ1dHRvbic6IHRydWUsXHJcbiAgICAgICAgJ21kYy1jYXJkX19hY3Rpb24nOiB0cnVlLFxyXG4gICAgICAgICdtZGMtY2FyZC1hY3Rpb24tYnV0dG9uJzogdHJ1ZVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG4iLCI8dGVtcGxhdGU+XHJcbiAgPGRpdiBjbGFzcz1cIm1kYy1jYXJkLWFjdGlvbi1pY29ucyBtZGMtY2FyZF9fYWN0aW9uLWljb25zXCI+XHJcbiAgICA8c2xvdC8+XHJcbiAgPC9kaXY+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgbmFtZTogJ21kYy1jYXJkLWFjdGlvbi1pY29ucydcclxufVxyXG48L3NjcmlwdD5cclxuIiwiPHRlbXBsYXRlPlxyXG4gIDxzcGFuIFxuICAgIDpjbGFzcz1cImNsYXNzZXNcIiBcbiAgICA6c3R5bGU9XCJzdHlsZXNcIiBcclxuICAgIHYtb249XCJsaXN0ZW5lcnNcIj5cclxuICAgIDxzbG90Pnt7IGljb24gfX08L3Nsb3Q+XHJcbiAgPC9zcGFuPlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuaW1wb3J0IHsgRGlzcGF0Y2hFdmVudE1peGluIH0gZnJvbSAnLi4vYmFzZSdcclxuaW1wb3J0IHsgUmlwcGxlQmFzZSB9IGZyb20gJy4uL3JpcHBsZSdcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiAnbWRjLWNhcmQtYWN0aW9uLWljb24nLFxyXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbl0sXHJcbiAgcHJvcHM6IHtcclxuICAgIGljb246IFN0cmluZ1xyXG4gIH0sXHJcbiAgZGF0YSgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNsYXNzZXM6IHtcclxuICAgICAgICAnbWRjLWNhcmQtYWN0aW9uLWljb24nOiB0cnVlLFxyXG4gICAgICAgICdtYXRlcmlhbC1pY29ucyc6ICEhdGhpcy5pY29uLFxyXG4gICAgICAgICdtZGMtY2FyZF9fYWN0aW9uJzogdHJ1ZSxcclxuICAgICAgICAnbWRjLWNhcmRfX2FjdGlvbi0taWNvbic6IHRydWUsXHJcbiAgICAgICAgJ21kYy1pY29uLXRvZ2dsZSc6IHRydWVcclxuICAgICAgfSxcclxuICAgICAgc3R5bGVzOiB7fVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgd2F0Y2g6IHtcclxuICAgIGljb24oKSB7XHJcbiAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsICdtYXRlcmlhbC1pY29ucycsICEhdGhpcy5pY29uKVxyXG4gICAgfVxyXG4gIH0sXHJcbiAgbW91bnRlZCgpIHtcclxuICAgIHRoaXMucmlwcGxlID0gbmV3IFJpcHBsZUJhc2UodGhpcywge1xyXG4gICAgICBpc1VuYm91bmRlZDogKCkgPT4gdHJ1ZVxyXG4gICAgfSlcclxuICAgIHRoaXMucmlwcGxlLmluaXQoKVxyXG4gIH0sXHJcbiAgYmVmb3JlRGVzdHJveSgpIHtcclxuICAgIHRoaXMucmlwcGxlLmRlc3Ryb3koKVxyXG4gIH1cclxufVxyXG48L3NjcmlwdD5cclxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXHJcbmltcG9ydCBtZGNDYXJkIGZyb20gJy4vbWRjLWNhcmQudnVlJ1xyXG5pbXBvcnQgbWRjQ2FyZFByaW1hcnlBY3Rpb24gZnJvbSAnLi9tZGMtY2FyZC1wcmltYXJ5LWFjdGlvbi52dWUnXHJcbmltcG9ydCBtZGNDYXJkTWVkaWEgZnJvbSAnLi9tZGMtY2FyZC1tZWRpYS52dWUnXHJcbmltcG9ydCBtZGNDYXJkSGVhZGVyIGZyb20gJy4vbWRjLWNhcmQtaGVhZGVyLnZ1ZSdcclxuaW1wb3J0IG1kY0NhcmRUaXRsZSBmcm9tICcuL21kYy1jYXJkLXRpdGxlLnZ1ZSdcclxuaW1wb3J0IG1kY0NhcmRTdWJ0aXRsZSBmcm9tICcuL21kYy1jYXJkLXN1YnRpdGxlLnZ1ZSdcclxuaW1wb3J0IG1kY0NhcmRUZXh0IGZyb20gJy4vbWRjLWNhcmQtdGV4dC52dWUnXHJcbmltcG9ydCBtZGNDYXJkQWN0aW9ucyBmcm9tICcuL21kYy1jYXJkLWFjdGlvbnMudnVlJ1xyXG5pbXBvcnQgbWRjQ2FyZEFjdGlvbkJ1dHRvbnMgZnJvbSAnLi9tZGMtY2FyZC1hY3Rpb24tYnV0dG9ucy52dWUnXHJcbmltcG9ydCBtZGNDYXJkQWN0aW9uQnV0dG9uIGZyb20gJy4vbWRjLWNhcmQtYWN0aW9uLWJ1dHRvbi52dWUnXHJcbmltcG9ydCBtZGNDYXJkQWN0aW9uSWNvbnMgZnJvbSAnLi9tZGMtY2FyZC1hY3Rpb24taWNvbnMudnVlJ1xyXG5pbXBvcnQgbWRjQ2FyZEFjdGlvbkljb24gZnJvbSAnLi9tZGMtY2FyZC1hY3Rpb24taWNvbi52dWUnXHJcblxyXG5leHBvcnQge1xyXG4gIG1kY0NhcmQsXHJcbiAgbWRjQ2FyZFByaW1hcnlBY3Rpb24sXHJcbiAgbWRjQ2FyZE1lZGlhLFxyXG4gIG1kY0NhcmRIZWFkZXIsXHJcbiAgbWRjQ2FyZFRpdGxlLFxyXG4gIG1kY0NhcmRTdWJ0aXRsZSxcclxuICBtZGNDYXJkVGV4dCxcclxuICBtZGNDYXJkQWN0aW9ucyxcclxuICBtZGNDYXJkQWN0aW9uQnV0dG9ucyxcclxuICBtZGNDYXJkQWN0aW9uQnV0dG9uLFxyXG4gIG1kY0NhcmRBY3Rpb25JY29ucyxcclxuICBtZGNDYXJkQWN0aW9uSWNvblxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcclxuICBtZGNDYXJkLFxyXG4gIG1kY0NhcmRQcmltYXJ5QWN0aW9uLFxyXG4gIG1kY0NhcmRNZWRpYSxcclxuICBtZGNDYXJkSGVhZGVyLFxyXG4gIG1kY0NhcmRUaXRsZSxcclxuICBtZGNDYXJkU3VidGl0bGUsXHJcbiAgbWRjQ2FyZFRleHQsXHJcbiAgbWRjQ2FyZEFjdGlvbnMsXHJcbiAgbWRjQ2FyZEFjdGlvbkJ1dHRvbnMsXHJcbiAgbWRjQ2FyZEFjdGlvbkJ1dHRvbixcclxuICBtZGNDYXJkQWN0aW9uSWNvbnMsXHJcbiAgbWRjQ2FyZEFjdGlvbkljb25cclxufSlcclxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJy4vZm91bmRhdGlvbic7XG5cbi8qKlxuICogQHRlbXBsYXRlIEZcbiAqL1xuY2xhc3MgTURDQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHJldHVybiB7IU1EQ0NvbXBvbmVudH1cbiAgICovXG4gIHN0YXRpYyBhdHRhY2hUbyhyb290KSB7XG4gICAgLy8gU3ViY2xhc3NlcyB3aGljaCBleHRlbmQgTURDQmFzZSBzaG91bGQgcHJvdmlkZSBhbiBhdHRhY2hUbygpIG1ldGhvZCB0aGF0IHRha2VzIGEgcm9vdCBlbGVtZW50IGFuZFxuICAgIC8vIHJldHVybnMgYW4gaW5zdGFudGlhdGVkIGNvbXBvbmVudCB3aXRoIGl0cyByb290IHNldCB0byB0aGF0IGVsZW1lbnQuIEFsc28gbm90ZSB0aGF0IGluIHRoZSBjYXNlcyBvZlxuICAgIC8vIHN1YmNsYXNzZXMsIGFuIGV4cGxpY2l0IGZvdW5kYXRpb24gY2xhc3Mgd2lsbCBub3QgaGF2ZSB0byBiZSBwYXNzZWQgaW47IGl0IHdpbGwgc2ltcGx5IGJlIGluaXRpYWxpemVkXG4gICAgLy8gZnJvbSBnZXREZWZhdWx0Rm91bmRhdGlvbigpLlxuICAgIHJldHVybiBuZXcgTURDQ29tcG9uZW50KHJvb3QsIG5ldyBNRENGb3VuZGF0aW9uKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHBhcmFtIHtGPX0gZm91bmRhdGlvblxuICAgKiBAcGFyYW0gey4uLj99IGFyZ3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJvb3QsIGZvdW5kYXRpb24gPSB1bmRlZmluZWQsIC4uLmFyZ3MpIHtcbiAgICAvKiogQHByb3RlY3RlZCB7IUVsZW1lbnR9ICovXG4gICAgdGhpcy5yb290XyA9IHJvb3Q7XG4gICAgdGhpcy5pbml0aWFsaXplKC4uLmFyZ3MpO1xuICAgIC8vIE5vdGUgdGhhdCB3ZSBpbml0aWFsaXplIGZvdW5kYXRpb24gaGVyZSBhbmQgbm90IHdpdGhpbiB0aGUgY29uc3RydWN0b3IncyBkZWZhdWx0IHBhcmFtIHNvIHRoYXRcbiAgICAvLyB0aGlzLnJvb3RfIGlzIGRlZmluZWQgYW5kIGNhbiBiZSB1c2VkIHdpdGhpbiB0aGUgZm91bmRhdGlvbiBjbGFzcy5cbiAgICAvKiogQHByb3RlY3RlZCB7IUZ9ICovXG4gICAgdGhpcy5mb3VuZGF0aW9uXyA9IGZvdW5kYXRpb24gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0RGVmYXVsdEZvdW5kYXRpb24oKSA6IGZvdW5kYXRpb247XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5pbml0KCk7XG4gICAgdGhpcy5pbml0aWFsU3luY1dpdGhET00oKTtcbiAgfVxuXG4gIGluaXRpYWxpemUoLyogLi4uYXJncyAqLykge1xuICAgIC8vIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgdG8gZG8gYW55IGFkZGl0aW9uYWwgc2V0dXAgd29yayB0aGF0IHdvdWxkIGJlIGNvbnNpZGVyZWQgcGFydCBvZiBhXG4gICAgLy8gXCJjb25zdHJ1Y3RvclwiLiBFc3NlbnRpYWxseSwgaXQgaXMgYSBob29rIGludG8gdGhlIHBhcmVudCBjb25zdHJ1Y3RvciBiZWZvcmUgdGhlIGZvdW5kYXRpb24gaXNcbiAgICAvLyBpbml0aWFsaXplZC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGJlc2lkZXMgcm9vdCBhbmQgZm91bmRhdGlvbiB3aWxsIGJlIHBhc3NlZCBpbiBoZXJlLlxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFGfSBmb3VuZGF0aW9uXG4gICAqL1xuICBnZXREZWZhdWx0Rm91bmRhdGlvbigpIHtcbiAgICAvLyBTdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGEgcHJvcGVybHkgY29uZmlndXJlZCBmb3VuZGF0aW9uIGNsYXNzIGZvciB0aGVcbiAgICAvLyBjb21wb25lbnQuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdTdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgZ2V0RGVmYXVsdEZvdW5kYXRpb24gdG8gcmV0dXJuIGEgcHJvcGVybHkgY29uZmlndXJlZCAnICtcbiAgICAgICdmb3VuZGF0aW9uIGNsYXNzJyk7XG4gIH1cblxuICBpbml0aWFsU3luY1dpdGhET00oKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgdGhleSBuZWVkIHRvIHBlcmZvcm0gd29yayB0byBzeW5jaHJvbml6ZSB3aXRoIGEgaG9zdCBET01cbiAgICAvLyBvYmplY3QuIEFuIGV4YW1wbGUgb2YgdGhpcyB3b3VsZCBiZSBhIGZvcm0gY29udHJvbCB3cmFwcGVyIHRoYXQgbmVlZHMgdG8gc3luY2hyb25pemUgaXRzIGludGVybmFsIHN0YXRlXG4gICAgLy8gdG8gc29tZSBwcm9wZXJ0eSBvciBhdHRyaWJ1dGUgb2YgdGhlIGhvc3QgRE9NLiBQbGVhc2Ugbm90ZTogdGhpcyBpcyAqbm90KiB0aGUgcGxhY2UgdG8gcGVyZm9ybSBET01cbiAgICAvLyByZWFkcy93cml0ZXMgdGhhdCB3b3VsZCBjYXVzZSBsYXlvdXQgLyBwYWludCwgYXMgdGhpcyBpcyBjYWxsZWQgc3luY2hyb25vdXNseSBmcm9tIHdpdGhpbiB0aGUgY29uc3RydWN0b3IuXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIC8vIFN1YmNsYXNzZXMgbWF5IGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZWxlYXNlIGFueSByZXNvdXJjZXMgLyBkZXJlZ2lzdGVyIGFueSBsaXN0ZW5lcnMgdGhleSBoYXZlXG4gICAgLy8gYXR0YWNoZWQuIEFuIGV4YW1wbGUgb2YgdGhpcyBtaWdodCBiZSBkZXJlZ2lzdGVyaW5nIGEgcmVzaXplIGV2ZW50IGZyb20gdGhlIHdpbmRvdyBvYmplY3QuXG4gICAgdGhpcy5mb3VuZGF0aW9uXy5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHBlciBtZXRob2QgdG8gYWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBjb21wb25lbnQncyByb290IGVsZW1lbnQuIFRoaXMgaXMgbW9zdCB1c2VmdWwgd2hlblxuICAgKiBsaXN0ZW5pbmcgZm9yIGN1c3RvbSBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBsaXN0ZW4oZXZ0VHlwZSwgaGFuZGxlcikge1xuICAgIHRoaXMucm9vdF8uYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcGVyIG1ldGhvZCB0byByZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGNvbXBvbmVudCdzIHJvb3QgZWxlbWVudC4gVGhpcyBpcyBtb3N0IHVzZWZ1bCB3aGVuXG4gICAqIHVubGlzdGVuaW5nIGZvciBjdXN0b20gZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgdW5saXN0ZW4oZXZ0VHlwZSwgaGFuZGxlcikge1xuICAgIHRoaXMucm9vdF8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyBhIGNyb3NzLWJyb3dzZXItY29tcGF0aWJsZSBjdXN0b20gZXZlbnQgZnJvbSB0aGUgY29tcG9uZW50IHJvb3Qgb2YgdGhlIGdpdmVuIHR5cGUsXG4gICAqIHdpdGggdGhlIGdpdmVuIGRhdGEuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gZXZ0RGF0YVxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzaG91bGRCdWJibGVcbiAgICovXG4gIGVtaXQoZXZ0VHlwZSwgZXZ0RGF0YSwgc2hvdWxkQnViYmxlID0gZmFsc2UpIHtcbiAgICBsZXQgZXZ0O1xuICAgIGlmICh0eXBlb2YgQ3VzdG9tRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGV2dCA9IG5ldyBDdXN0b21FdmVudChldnRUeXBlLCB7XG4gICAgICAgIGRldGFpbDogZXZ0RGF0YSxcbiAgICAgICAgYnViYmxlczogc2hvdWxkQnViYmxlLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldnRUeXBlLCBzaG91bGRCdWJibGUsIGZhbHNlLCBldnREYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLnJvb3RfLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENDb21wb25lbnQ7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0NvbXBvbmVudCBmcm9tICdAbWF0ZXJpYWwvYmFzZS9jb21wb25lbnQnO1xuaW1wb3J0IE1EQ1JpcHBsZUFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCBNRENSaXBwbGVGb3VuZGF0aW9uIGZyb20gJy4vZm91bmRhdGlvbic7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogQGV4dGVuZHMgTURDQ29tcG9uZW50PCFNRENSaXBwbGVGb3VuZGF0aW9uPlxuICovXG5jbGFzcyBNRENSaXBwbGUgZXh0ZW5kcyBNRENDb21wb25lbnQge1xuICAvKiogQHBhcmFtIHsuLi4/fSBhcmdzICovXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcblxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy51bmJvdW5kZWRfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHBhcmFtIHt7aXNVbmJvdW5kZWQ6IChib29sZWFufHVuZGVmaW5lZCl9PX0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHshTURDUmlwcGxlfVxuICAgKi9cbiAgc3RhdGljIGF0dGFjaFRvKHJvb3QsIHtpc1VuYm91bmRlZCA9IHVuZGVmaW5lZH0gPSB7fSkge1xuICAgIGNvbnN0IHJpcHBsZSA9IG5ldyBNRENSaXBwbGUocm9vdCk7XG4gICAgLy8gT25seSBvdmVycmlkZSB1bmJvdW5kZWQgYmVoYXZpb3IgaWYgb3B0aW9uIGlzIGV4cGxpY2l0bHkgc3BlY2lmaWVkXG4gICAgaWYgKGlzVW5ib3VuZGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJpcHBsZS51bmJvdW5kZWQgPSAvKiogQHR5cGUge2Jvb2xlYW59ICovIChpc1VuYm91bmRlZCk7XG4gICAgfVxuICAgIHJldHVybiByaXBwbGU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshUmlwcGxlQ2FwYWJsZVN1cmZhY2V9IGluc3RhbmNlXG4gICAqIEByZXR1cm4geyFNRENSaXBwbGVBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUFkYXB0ZXIoaW5zdGFuY2UpIHtcbiAgICBjb25zdCBNQVRDSEVTID0gdXRpbC5nZXRNYXRjaGVzUHJvcGVydHkoSFRNTEVsZW1lbnQucHJvdG90eXBlKTtcblxuICAgIHJldHVybiB7XG4gICAgICBicm93c2VyU3VwcG9ydHNDc3NWYXJzOiAoKSA9PiB1dGlsLnN1cHBvcnRzQ3NzVmFyaWFibGVzKHdpbmRvdyksXG4gICAgICBpc1VuYm91bmRlZDogKCkgPT4gaW5zdGFuY2UudW5ib3VuZGVkLFxuICAgICAgaXNTdXJmYWNlQWN0aXZlOiAoKSA9PiBpbnN0YW5jZS5yb290X1tNQVRDSEVTXSgnOmFjdGl2ZScpLFxuICAgICAgaXNTdXJmYWNlRGlzYWJsZWQ6ICgpID0+IGluc3RhbmNlLmRpc2FibGVkLFxuICAgICAgYWRkQ2xhc3M6IChjbGFzc05hbWUpID0+IGluc3RhbmNlLnJvb3RfLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoY2xhc3NOYW1lKSA9PiBpbnN0YW5jZS5yb290Xy5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSksXG4gICAgICBjb250YWluc0V2ZW50VGFyZ2V0OiAodGFyZ2V0KSA9PiBpbnN0YW5jZS5yb290Xy5jb250YWlucyh0YXJnZXQpLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PlxuICAgICAgICBpbnN0YW5jZS5yb290Xy5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIsIHV0aWwuYXBwbHlQYXNzaXZlKCkpLFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+XG4gICAgICAgIGluc3RhbmNlLnJvb3RfLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlciwgdXRpbC5hcHBseVBhc3NpdmUoKSksXG4gICAgICByZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT5cbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlciwgdXRpbC5hcHBseVBhc3NpdmUoKSksXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PlxuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyLCB1dGlsLmFwcGx5UGFzc2l2ZSgpKSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKGhhbmRsZXIpID0+IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoaGFuZGxlcikgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpLFxuICAgICAgdXBkYXRlQ3NzVmFyaWFibGU6ICh2YXJOYW1lLCB2YWx1ZSkgPT4gaW5zdGFuY2Uucm9vdF8uc3R5bGUuc2V0UHJvcGVydHkodmFyTmFtZSwgdmFsdWUpLFxuICAgICAgY29tcHV0ZUJvdW5kaW5nUmVjdDogKCkgPT4gaW5zdGFuY2Uucm9vdF8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBnZXRXaW5kb3dQYWdlT2Zmc2V0OiAoKSA9PiAoe3g6IHdpbmRvdy5wYWdlWE9mZnNldCwgeTogd2luZG93LnBhZ2VZT2Zmc2V0fSksXG4gICAgfTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBnZXQgdW5ib3VuZGVkKCkge1xuICAgIHJldHVybiB0aGlzLnVuYm91bmRlZF87XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSB1bmJvdW5kZWQgKi9cbiAgc2V0IHVuYm91bmRlZCh1bmJvdW5kZWQpIHtcbiAgICB0aGlzLnVuYm91bmRlZF8gPSBCb29sZWFuKHVuYm91bmRlZCk7XG4gICAgdGhpcy5zZXRVbmJvdW5kZWRfKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc3VyZSBDb21waWxlciB0aHJvd3MgYW4gYWNjZXNzIGNvbnRyb2wgZXJyb3Igd2hlbiBkaXJlY3RseSBhY2Nlc3NpbmcgYVxuICAgKiBwcm90ZWN0ZWQgb3IgcHJpdmF0ZSBwcm9wZXJ0eSBpbnNpZGUgYSBnZXR0ZXIvc2V0dGVyLCBsaWtlIHVuYm91bmRlZCBhYm92ZS5cbiAgICogQnkgYWNjZXNzaW5nIHRoZSBwcm90ZWN0ZWQgcHJvcGVydHkgaW5zaWRlIGEgbWV0aG9kLCB3ZSBzb2x2ZSB0aGF0IHByb2JsZW0uXG4gICAqIFRoYXQncyB3aHkgdGhpcyBmdW5jdGlvbiBleGlzdHMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXRVbmJvdW5kZWRfKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8uc2V0VW5ib3VuZGVkKHRoaXMudW5ib3VuZGVkXyk7XG4gIH1cblxuICBhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb25fLmFjdGl2YXRlKCk7XG4gIH1cblxuICBkZWFjdGl2YXRlKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8uZGVhY3RpdmF0ZSgpO1xuICB9XG5cbiAgbGF5b3V0KCkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8ubGF5b3V0KCk7XG4gIH1cblxuICAvKiogQHJldHVybiB7IU1EQ1JpcHBsZUZvdW5kYXRpb259ICovXG4gIGdldERlZmF1bHRGb3VuZGF0aW9uKCkge1xuICAgIHJldHVybiBuZXcgTURDUmlwcGxlRm91bmRhdGlvbihNRENSaXBwbGUuY3JlYXRlQWRhcHRlcih0aGlzKSk7XG4gIH1cblxuICBpbml0aWFsU3luY1dpdGhET00oKSB7XG4gICAgdGhpcy51bmJvdW5kZWQgPSAnbWRjUmlwcGxlSXNVbmJvdW5kZWQnIGluIHRoaXMucm9vdF8uZGF0YXNldDtcbiAgfVxufVxuXG4vKipcbiAqIFNlZSBNYXRlcmlhbCBEZXNpZ24gc3BlYyBmb3IgbW9yZSBkZXRhaWxzIG9uIHdoZW4gdG8gdXNlIHJpcHBsZXMuXG4gKiBodHRwczovL21hdGVyaWFsLmlvL2d1aWRlbGluZXMvbW90aW9uL2Nob3Jlb2dyYXBoeS5odG1sI2Nob3Jlb2dyYXBoeS1jcmVhdGlvblxuICogQHJlY29yZFxuICovXG5jbGFzcyBSaXBwbGVDYXBhYmxlU3VyZmFjZSB7fVxuXG4vKiogQHByb3RlY3RlZCB7IUVsZW1lbnR9ICovXG5SaXBwbGVDYXBhYmxlU3VyZmFjZS5wcm90b3R5cGUucm9vdF87XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIHJpcHBsZSBibGVlZHMgb3V0IG9mIHRoZSBib3VuZHMgb2YgdGhlIGVsZW1lbnQuXG4gKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gKi9cblJpcHBsZUNhcGFibGVTdXJmYWNlLnByb3RvdHlwZS51bmJvdW5kZWQ7XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIHJpcHBsZSBpcyBhdHRhY2hlZCB0byBhIGRpc2FibGVkIGNvbXBvbmVudC5cbiAqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH1cbiAqL1xuUmlwcGxlQ2FwYWJsZVN1cmZhY2UucHJvdG90eXBlLmRpc2FibGVkO1xuXG5leHBvcnQge01EQ1JpcHBsZSwgTURDUmlwcGxlRm91bmRhdGlvbiwgUmlwcGxlQ2FwYWJsZVN1cmZhY2UsIHV0aWx9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1JpcHBsZX0gZnJvbSAnQG1hdGVyaWFsL3JpcHBsZS9pbmRleCc7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgY2hlY2tlZDogYm9vbGVhbixcbiAqICAgaW5kZXRlcm1pbmF0ZTogYm9vbGVhbixcbiAqICAgZGlzYWJsZWQ6IGJvb2xlYW4sXG4gKiAgIHZhbHVlOiA/c3RyaW5nXG4gKiB9fVxuICovXG5sZXQgTURDU2VsZWN0aW9uQ29udHJvbFN0YXRlO1xuXG4vKipcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDU2VsZWN0aW9uQ29udHJvbCB7XG4gIC8qKiBAcmV0dXJuIHs/TURDUmlwcGxlfSAqL1xuICBnZXQgcmlwcGxlKCkge31cbn1cblxuZXhwb3J0IHtNRENTZWxlY3Rpb25Db250cm9sU3RhdGUsIE1EQ1NlbGVjdGlvbkNvbnRyb2x9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZX0gZnJvbSAnQG1hdGVyaWFsL3NlbGVjdGlvbi1jb250cm9sL2luZGV4JztcblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIENoZWNrYm94LiBQcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIG1hbmFnaW5nXG4gKiAtIGNsYXNzZXNcbiAqIC0gZG9tXG4gKiAtIGV2ZW50IGhhbmRsZXJzXG4gKlxuICogQWRkaXRpb25hbGx5LCBwcm92aWRlcyB0eXBlIGluZm9ybWF0aW9uIGZvciB0aGUgYWRhcHRlciB0byB0aGUgQ2xvc3VyZVxuICogY29tcGlsZXIuXG4gKlxuICogSW1wbGVtZW50IHRoaXMgYWRhcHRlciBmb3IgeW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlIHRvIGRlbGVnYXRlIHVwZGF0ZXMgdG9cbiAqIHRoZSBjb21wb25lbnQgaW4geW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlLiBTZWUgYXJjaGl0ZWN0dXJlIGRvY3VtZW50YXRpb25cbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2NvZGUvYXJjaGl0ZWN0dXJlLm1kXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENDaGVja2JveEFkYXB0ZXIge1xuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIGFuIGF0dHJpYnV0ZSB3aXRoIGEgZ2l2ZW4gdmFsdWUgb24gdGhlIGlucHV0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0TmF0aXZlQ29udHJvbEF0dHIoYXR0ciwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gYXR0cmlidXRlIGZyb20gdGhlIGlucHV0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG4gICAqL1xuICByZW1vdmVOYXRpdmVDb250cm9sQXR0cihhdHRyKSB7fVxuXG4gIC8qKiBAcGFyYW0geyFFdmVudExpc3RlbmVyfSBoYW5kbGVyICovXG4gIHJlZ2lzdGVyQW5pbWF0aW9uRW5kSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKiBAcGFyYW0geyFFdmVudExpc3RlbmVyfSBoYW5kbGVyICovXG4gIGRlcmVnaXN0ZXJBbmltYXRpb25FbmRIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqIEBwYXJhbSB7IUV2ZW50TGlzdGVuZXJ9IGhhbmRsZXIgKi9cbiAgcmVnaXN0ZXJDaGFuZ2VIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqIEBwYXJhbSB7IUV2ZW50TGlzdGVuZXJ9IGhhbmRsZXIgKi9cbiAgZGVyZWdpc3RlckNoYW5nZUhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKiogQHJldHVybiB7IU1EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZX0gKi9cbiAgZ2V0TmF0aXZlQ29udHJvbCgpIHt9XG5cbiAgZm9yY2VMYXlvdXQoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc0F0dGFjaGVkVG9ET00oKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENDaGVja2JveEFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBjb25zdCB7c3RyaW5nfSAqL1xuY29uc3QgUk9PVCA9ICdtZGMtY2hlY2tib3gnO1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIFVQR1JBREVEOiAnbWRjLWNoZWNrYm94LS11cGdyYWRlZCcsXG4gIENIRUNLRUQ6ICdtZGMtY2hlY2tib3gtLWNoZWNrZWQnLFxuICBJTkRFVEVSTUlOQVRFOiAnbWRjLWNoZWNrYm94LS1pbmRldGVybWluYXRlJyxcbiAgRElTQUJMRUQ6ICdtZGMtY2hlY2tib3gtLWRpc2FibGVkJyxcbiAgQU5JTV9VTkNIRUNLRURfQ0hFQ0tFRDogJ21kYy1jaGVja2JveC0tYW5pbS11bmNoZWNrZWQtY2hlY2tlZCcsXG4gIEFOSU1fVU5DSEVDS0VEX0lOREVURVJNSU5BVEU6ICdtZGMtY2hlY2tib3gtLWFuaW0tdW5jaGVja2VkLWluZGV0ZXJtaW5hdGUnLFxuICBBTklNX0NIRUNLRURfVU5DSEVDS0VEOiAnbWRjLWNoZWNrYm94LS1hbmltLWNoZWNrZWQtdW5jaGVja2VkJyxcbiAgQU5JTV9DSEVDS0VEX0lOREVURVJNSU5BVEU6ICdtZGMtY2hlY2tib3gtLWFuaW0tY2hlY2tlZC1pbmRldGVybWluYXRlJyxcbiAgQU5JTV9JTkRFVEVSTUlOQVRFX0NIRUNLRUQ6ICdtZGMtY2hlY2tib3gtLWFuaW0taW5kZXRlcm1pbmF0ZS1jaGVja2VkJyxcbiAgQU5JTV9JTkRFVEVSTUlOQVRFX1VOQ0hFQ0tFRDogJ21kYy1jaGVja2JveC0tYW5pbS1pbmRldGVybWluYXRlLXVuY2hlY2tlZCcsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIE5BVElWRV9DT05UUk9MX1NFTEVDVE9SOiBgLiR7Uk9PVH1fX25hdGl2ZS1jb250cm9sYCxcbiAgVFJBTlNJVElPTl9TVEFURV9JTklUOiAnaW5pdCcsXG4gIFRSQU5TSVRJT05fU1RBVEVfQ0hFQ0tFRDogJ2NoZWNrZWQnLFxuICBUUkFOU0lUSU9OX1NUQVRFX1VOQ0hFQ0tFRDogJ3VuY2hlY2tlZCcsXG4gIFRSQU5TSVRJT05fU1RBVEVfSU5ERVRFUk1JTkFURTogJ2luZGV0ZXJtaW5hdGUnLFxuICBBUklBX0NIRUNLRURfQVRUUjogJ2FyaWEtY2hlY2tlZCcsXG4gIEFSSUFfQ0hFQ0tFRF9JTkRFVEVSTUlOQVRFX1ZBTFVFOiAnbWl4ZWQnLFxufTtcblxuLyoqIEBlbnVtIHtudW1iZXJ9ICovXG5jb25zdCBudW1iZXJzID0ge1xuICBBTklNX0VORF9MQVRDSF9NUzogMjUwLFxufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZX0gZnJvbSAnQG1hdGVyaWFsL3NlbGVjdGlvbi1jb250cm9sL2luZGV4JztcbmltcG9ydCBNRENDaGVja2JveEFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKiogQGNvbnN0IHshQXJyYXk8c3RyaW5nPn0gKi9cbmNvbnN0IENCX1BST1RPX1BST1BTID0gWydjaGVja2VkJywgJ2luZGV0ZXJtaW5hdGUnXTtcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDQ2hlY2tib3hBZGFwdGVyPn1cbiAqL1xuY2xhc3MgTURDQ2hlY2tib3hGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge2Nzc0NsYXNzZXN9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ3N9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge251bWJlcnN9ICovXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICByZXR1cm4gbnVtYmVycztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshTURDQ2hlY2tib3hBZGFwdGVyfSAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENDaGVja2JveEFkYXB0ZXJ9ICovICh7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgc2V0TmF0aXZlQ29udHJvbEF0dHI6ICgvKiBhdHRyOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlTmF0aXZlQ29udHJvbEF0dHI6ICgvKiBhdHRyOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJBbmltYXRpb25FbmRIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyQW5pbWF0aW9uRW5kSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJDaGFuZ2VIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyQ2hhbmdlSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZ2V0TmF0aXZlQ29udHJvbDogKCkgPT4gLyogIU1EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZSAqLyB7fSxcbiAgICAgIGZvcmNlTGF5b3V0OiAoKSA9PiB7fSxcbiAgICAgIGlzQXR0YWNoZWRUb0RPTTogKCkgPT4gLyogYm9vbGVhbiAqLyB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0NoZWNrYm94Rm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtzdHJpbmd9ICovXG4gICAgdGhpcy5jdXJyZW50Q2hlY2tTdGF0ZV8gPSBzdHJpbmdzLlRSQU5TSVRJT05fU1RBVEVfSU5JVDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7c3RyaW5nfSAqL1xuICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbkNsYXNzXyA9ICcnO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5hbmltRW5kTGF0Y2hUaW1lcl8gPSAwO1xuXG4gICAgdGhpcy5hbmltRW5kSGFuZGxlcl8gPSAvKiogQHByaXZhdGUgeyFFdmVudExpc3RlbmVyfSAqLyAoXG4gICAgICAoKSA9PiB0aGlzLmhhbmRsZUFuaW1hdGlvbkVuZCgpKTtcblxuICAgIHRoaXMuY2hhbmdlSGFuZGxlcl8gPSAvKiogQHByaXZhdGUgeyFFdmVudExpc3RlbmVyfSAqLyAoXG4gICAgICAoKSA9PiB0aGlzLmhhbmRsZUNoYW5nZSgpKTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5jdXJyZW50Q2hlY2tTdGF0ZV8gPSB0aGlzLmRldGVybWluZUNoZWNrU3RhdGVfKHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKSk7XG4gICAgdGhpcy51cGRhdGVBcmlhQ2hlY2tlZF8oKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuVVBHUkFERUQpO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJDaGFuZ2VIYW5kbGVyKHRoaXMuY2hhbmdlSGFuZGxlcl8pO1xuICAgIHRoaXMuaW5zdGFsbFByb3BlcnR5Q2hhbmdlSG9va3NfKCk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckNoYW5nZUhhbmRsZXIodGhpcy5jaGFuZ2VIYW5kbGVyXyk7XG4gICAgdGhpcy51bmluc3RhbGxQcm9wZXJ0eUNoYW5nZUhvb2tzXygpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzQ2hlY2tlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVDb250cm9sXygpLmNoZWNrZWQ7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBjaGVja2VkICovXG4gIHNldENoZWNrZWQoY2hlY2tlZCkge1xuICAgIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS5jaGVja2VkID0gY2hlY2tlZDtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc0luZGV0ZXJtaW5hdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS5pbmRldGVybWluYXRlO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gaW5kZXRlcm1pbmF0ZSAqL1xuICBzZXRJbmRldGVybWluYXRlKGluZGV0ZXJtaW5hdGUpIHtcbiAgICB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkuaW5kZXRlcm1pbmF0ZSA9IGluZGV0ZXJtaW5hdGU7XG4gIH1cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNEaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVDb250cm9sXygpLmRpc2FibGVkO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWQgKi9cbiAgc2V0RGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5ESVNBQkxFRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5ESVNBQkxFRCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEByZXR1cm4gez9zdHJpbmd9ICovXG4gIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkudmFsdWU7XG4gIH1cblxuICAvKiogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZSAqL1xuICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS52YWx1ZSA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGFuaW1hdGlvbmVuZCBldmVudCBmb3IgdGhlIGNoZWNrYm94XG4gICAqL1xuICBoYW5kbGVBbmltYXRpb25FbmQoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuYW5pbUVuZExhdGNoVGltZXJfKTtcbiAgICB0aGlzLmFuaW1FbmRMYXRjaFRpbWVyXyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyh0aGlzLmN1cnJlbnRBbmltYXRpb25DbGFzc18pO1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyQW5pbWF0aW9uRW5kSGFuZGxlcih0aGlzLmFuaW1FbmRIYW5kbGVyXyk7XG4gICAgfSwgbnVtYmVycy5BTklNX0VORF9MQVRDSF9NUyk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgY2hhbmdlIGV2ZW50IGZvciB0aGUgY2hlY2tib3hcbiAgICovXG4gIGhhbmRsZUNoYW5nZSgpIHtcbiAgICB0aGlzLnRyYW5zaXRpb25DaGVja1N0YXRlXygpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGluc3RhbGxQcm9wZXJ0eUNoYW5nZUhvb2tzXygpIHtcbiAgICBjb25zdCBuYXRpdmVDYiA9IHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKTtcbiAgICBjb25zdCBjYlByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5hdGl2ZUNiKTtcblxuICAgIENCX1BST1RPX1BST1BTLmZvckVhY2goKGNvbnRyb2xTdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY2JQcm90bywgY29udHJvbFN0YXRlKTtcbiAgICAgIC8vIFdlIGhhdmUgdG8gY2hlY2sgZm9yIHRoaXMgZGVzY3JpcHRvciwgc2luY2Ugc29tZSBicm93c2VycyAoU2FmYXJpKSBkb24ndCBzdXBwb3J0IGl0cyByZXR1cm4uXG4gICAgICAvLyBTZWU6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD00OTczOVxuICAgICAgaWYgKHZhbGlkRGVzY3JpcHRvcihkZXNjKSkge1xuICAgICAgICBjb25zdCBuYXRpdmVDYkRlc2MgPSAvKiogQHR5cGUgeyFPYmplY3RQcm9wZXJ0eURlc2NyaXB0b3J9ICovICh7XG4gICAgICAgICAgZ2V0OiBkZXNjLmdldCxcbiAgICAgICAgICBzZXQ6IChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgZGVzYy5zZXQuY2FsbChuYXRpdmVDYiwgc3RhdGUpO1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uQ2hlY2tTdGF0ZV8oKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZGVzYy5jb25maWd1cmFibGUsXG4gICAgICAgICAgZW51bWVyYWJsZTogZGVzYy5lbnVtZXJhYmxlLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hdGl2ZUNiLCBjb250cm9sU3RhdGUsIG5hdGl2ZUNiRGVzYyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgdW5pbnN0YWxsUHJvcGVydHlDaGFuZ2VIb29rc18oKSB7XG4gICAgY29uc3QgbmF0aXZlQ2IgPSB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCk7XG4gICAgY29uc3QgY2JQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihuYXRpdmVDYik7XG5cbiAgICBDQl9QUk9UT19QUk9QUy5mb3JFYWNoKChjb250cm9sU3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IGRlc2MgPSAvKiogQHR5cGUgeyFPYmplY3RQcm9wZXJ0eURlc2NyaXB0b3J9ICovIChcbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjYlByb3RvLCBjb250cm9sU3RhdGUpKTtcbiAgICAgIGlmICh2YWxpZERlc2NyaXB0b3IoZGVzYykpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hdGl2ZUNiLCBjb250cm9sU3RhdGUsIGRlc2MpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHRyYW5zaXRpb25DaGVja1N0YXRlXygpIHtcbiAgICBjb25zdCBuYXRpdmVDYiA9IHRoaXMuYWRhcHRlcl8uZ2V0TmF0aXZlQ29udHJvbCgpO1xuICAgIGlmICghbmF0aXZlQ2IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb2xkU3RhdGUgPSB0aGlzLmN1cnJlbnRDaGVja1N0YXRlXztcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRoaXMuZGV0ZXJtaW5lQ2hlY2tTdGF0ZV8obmF0aXZlQ2IpO1xuICAgIGlmIChvbGRTdGF0ZSA9PT0gbmV3U3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZUFyaWFDaGVja2VkXygpO1xuXG4gICAgLy8gQ2hlY2sgdG8gZW5zdXJlIHRoYXQgdGhlcmUgaXNuJ3QgYSBwcmV2aW91c2x5IGV4aXN0aW5nIGFuaW1hdGlvbiBjbGFzcywgaW4gY2FzZSBmb3IgZXhhbXBsZVxuICAgIC8vIHRoZSB1c2VyIGludGVyYWN0ZWQgd2l0aCB0aGUgY2hlY2tib3ggYmVmb3JlIHRoZSBhbmltYXRpb24gd2FzIGZpbmlzaGVkLlxuICAgIGlmICh0aGlzLmN1cnJlbnRBbmltYXRpb25DbGFzc18ubGVuZ3RoID4gMCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYW5pbUVuZExhdGNoVGltZXJfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZm9yY2VMYXlvdXQoKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3ModGhpcy5jdXJyZW50QW5pbWF0aW9uQ2xhc3NfKTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRBbmltYXRpb25DbGFzc18gPSB0aGlzLmdldFRyYW5zaXRpb25BbmltYXRpb25DbGFzc18ob2xkU3RhdGUsIG5ld1N0YXRlKTtcbiAgICB0aGlzLmN1cnJlbnRDaGVja1N0YXRlXyA9IG5ld1N0YXRlO1xuXG4gICAgLy8gQ2hlY2sgZm9yIHBhcmVudE5vZGUgc28gdGhhdCBhbmltYXRpb25zIGFyZSBvbmx5IHJ1biB3aGVuIHRoZSBlbGVtZW50IGlzIGF0dGFjaGVkXG4gICAgLy8gdG8gdGhlIERPTS5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc0F0dGFjaGVkVG9ET00oKSAmJiB0aGlzLmN1cnJlbnRBbmltYXRpb25DbGFzc18ubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyh0aGlzLmN1cnJlbnRBbmltYXRpb25DbGFzc18pO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckFuaW1hdGlvbkVuZEhhbmRsZXIodGhpcy5hbmltRW5kSGFuZGxlcl8pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENTZWxlY3Rpb25Db250cm9sU3RhdGV9IG5hdGl2ZUNiXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRldGVybWluZUNoZWNrU3RhdGVfKG5hdGl2ZUNiKSB7XG4gICAgY29uc3Qge1xuICAgICAgVFJBTlNJVElPTl9TVEFURV9JTkRFVEVSTUlOQVRFLFxuICAgICAgVFJBTlNJVElPTl9TVEFURV9DSEVDS0VELFxuICAgICAgVFJBTlNJVElPTl9TVEFURV9VTkNIRUNLRUQsXG4gICAgfSA9IHN0cmluZ3M7XG5cbiAgICBpZiAobmF0aXZlQ2IuaW5kZXRlcm1pbmF0ZSkge1xuICAgICAgcmV0dXJuIFRSQU5TSVRJT05fU1RBVEVfSU5ERVRFUk1JTkFURTtcbiAgICB9XG4gICAgcmV0dXJuIG5hdGl2ZUNiLmNoZWNrZWQgPyBUUkFOU0lUSU9OX1NUQVRFX0NIRUNLRUQgOiBUUkFOU0lUSU9OX1NUQVRFX1VOQ0hFQ0tFRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2xkU3RhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ld1N0YXRlXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldFRyYW5zaXRpb25BbmltYXRpb25DbGFzc18ob2xkU3RhdGUsIG5ld1N0YXRlKSB7XG4gICAgY29uc3Qge1xuICAgICAgVFJBTlNJVElPTl9TVEFURV9JTklULFxuICAgICAgVFJBTlNJVElPTl9TVEFURV9DSEVDS0VELFxuICAgICAgVFJBTlNJVElPTl9TVEFURV9VTkNIRUNLRUQsXG4gICAgfSA9IHN0cmluZ3M7XG5cbiAgICBjb25zdCB7XG4gICAgICBBTklNX1VOQ0hFQ0tFRF9DSEVDS0VELFxuICAgICAgQU5JTV9VTkNIRUNLRURfSU5ERVRFUk1JTkFURSxcbiAgICAgIEFOSU1fQ0hFQ0tFRF9VTkNIRUNLRUQsXG4gICAgICBBTklNX0NIRUNLRURfSU5ERVRFUk1JTkFURSxcbiAgICAgIEFOSU1fSU5ERVRFUk1JTkFURV9DSEVDS0VELFxuICAgICAgQU5JTV9JTkRFVEVSTUlOQVRFX1VOQ0hFQ0tFRCxcbiAgICB9ID0gTURDQ2hlY2tib3hGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG5cbiAgICBzd2l0Y2ggKG9sZFN0YXRlKSB7XG4gICAgY2FzZSBUUkFOU0lUSU9OX1NUQVRFX0lOSVQ6XG4gICAgICBpZiAobmV3U3RhdGUgPT09IFRSQU5TSVRJT05fU1RBVEVfVU5DSEVDS0VEKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAvLyBmYWxsdGhyb3VnaFxuICAgIGNhc2UgVFJBTlNJVElPTl9TVEFURV9VTkNIRUNLRUQ6XG4gICAgICByZXR1cm4gbmV3U3RhdGUgPT09IFRSQU5TSVRJT05fU1RBVEVfQ0hFQ0tFRCA/IEFOSU1fVU5DSEVDS0VEX0NIRUNLRUQgOiBBTklNX1VOQ0hFQ0tFRF9JTkRFVEVSTUlOQVRFO1xuICAgIGNhc2UgVFJBTlNJVElPTl9TVEFURV9DSEVDS0VEOlxuICAgICAgcmV0dXJuIG5ld1N0YXRlID09PSBUUkFOU0lUSU9OX1NUQVRFX1VOQ0hFQ0tFRCA/IEFOSU1fQ0hFQ0tFRF9VTkNIRUNLRUQgOiBBTklNX0NIRUNLRURfSU5ERVRFUk1JTkFURTtcbiAgICAvLyBUUkFOU0lUSU9OX1NUQVRFX0lOREVURVJNSU5BVEVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG5ld1N0YXRlID09PSBUUkFOU0lUSU9OX1NUQVRFX0NIRUNLRUQgP1xuICAgICAgICBBTklNX0lOREVURVJNSU5BVEVfQ0hFQ0tFRCA6IEFOSU1fSU5ERVRFUk1JTkFURV9VTkNIRUNLRUQ7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlQXJpYUNoZWNrZWRfKCkge1xuICAgIC8vIEVuc3VyZSBhcmlhLWNoZWNrZWQgaXMgc2V0IHRvIG1peGVkIGlmIGNoZWNrYm94IGlzIGluIGluZGV0ZXJtaW5hdGUgc3RhdGUuXG4gICAgaWYgKHRoaXMuaXNJbmRldGVybWluYXRlKCkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0TmF0aXZlQ29udHJvbEF0dHIoXG4gICAgICAgIHN0cmluZ3MuQVJJQV9DSEVDS0VEX0FUVFIsIHN0cmluZ3MuQVJJQV9DSEVDS0VEX0lOREVURVJNSU5BVEVfVkFMVUUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZU5hdGl2ZUNvbnRyb2xBdHRyKHN0cmluZ3MuQVJJQV9DSEVDS0VEX0FUVFIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshTURDU2VsZWN0aW9uQ29udHJvbFN0YXRlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TmF0aXZlQ29udHJvbF8oKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uZ2V0TmF0aXZlQ29udHJvbCgpIHx8IHtcbiAgICAgIGNoZWNrZWQ6IGZhbHNlLFxuICAgICAgaW5kZXRlcm1pbmF0ZTogZmFsc2UsXG4gICAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICB9O1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3RQcm9wZXJ0eURlc2NyaXB0b3J8dW5kZWZpbmVkfSBpbnB1dFByb3BEZXNjXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiB2YWxpZERlc2NyaXB0b3IoaW5wdXRQcm9wRGVzYykge1xuICByZXR1cm4gISFpbnB1dFByb3BEZXNjICYmIHR5cGVvZiBpbnB1dFByb3BEZXNjLnNldCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDQ2hlY2tib3hGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBGb3JtIEZpZWxkLiBQcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIG1hbmFnaW5nXG4gKiAtIGV2ZW50IGhhbmRsZXJzXG4gKiAtIHJpcHBsZSBhY3RpdmF0aW9uXG4gKlxuICogQWRkaXRpb25hbGx5LCBwcm92aWRlcyB0eXBlIGluZm9ybWF0aW9uIGZvciB0aGUgYWRhcHRlciB0byB0aGUgQ2xvc3VyZVxuICogY29tcGlsZXIuXG4gKlxuICogSW1wbGVtZW50IHRoaXMgYWRhcHRlciBmb3IgeW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlIHRvIGRlbGVnYXRlIHVwZGF0ZXMgdG9cbiAqIHRoZSBjb21wb25lbnQgaW4geW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlLiBTZWUgYXJjaGl0ZWN0dXJlIGRvY3VtZW50YXRpb25cbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2NvZGUvYXJjaGl0ZWN0dXJlLm1kXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENGb3JtRmllbGRBZGFwdGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7IUV2ZW50TGlzdGVuZXJ9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7IUV2ZW50TGlzdGVuZXJ9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICBhY3RpdmF0ZUlucHV0UmlwcGxlKCkge31cblxuICBkZWFjdGl2YXRlSW5wdXRSaXBwbGUoKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENGb3JtRmllbGRBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgUk9PVDogJ21kYy1mb3JtLWZpZWxkJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgTEFCRUxfU0VMRUNUT1I6ICcubWRjLWZvcm0tZmllbGQgPiBsYWJlbCcsXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ0Zvcm1GaWVsZEFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENGb3JtRmllbGRBZGFwdGVyPn1cbiAqL1xuY2xhc3MgTURDRm9ybUZpZWxkRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtjc3NDbGFzc2VzfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmdzfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKiogQHJldHVybiB7IU1EQ0Zvcm1GaWVsZEFkYXB0ZXJ9ICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgYWN0aXZhdGVJbnB1dFJpcHBsZTogKCkgPT4ge30sXG4gICAgICBkZWFjdGl2YXRlSW5wdXRSaXBwbGU6ICgpID0+IHt9LFxuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENGb3JtRmllbGRGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUgeyFFdmVudExpc3RlbmVyfSAqL1xuICAgIHRoaXMuY2xpY2tIYW5kbGVyXyA9IC8qKiBAdHlwZSB7IUV2ZW50TGlzdGVuZXJ9ICovIChcbiAgICAgICgpID0+IHRoaXMuaGFuZGxlQ2xpY2tfKCkpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmNsaWNrSGFuZGxlcl8pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGhhbmRsZUNsaWNrXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmFjdGl2YXRlSW5wdXRSaXBwbGUoKTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5hZGFwdGVyXy5kZWFjdGl2YXRlSW5wdXRSaXBwbGUoKSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDRm9ybUZpZWxkRm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIG5vUHJlZml4OiBzdHJpbmcsXG4gKiAgIHdlYmtpdFByZWZpeDogc3RyaW5nLFxuICogICBzdHlsZVByb3BlcnR5OiBzdHJpbmdcbiAqIH19XG4gKi9cbmxldCBWZW5kb3JQcm9wZXJ0eU1hcFR5cGU7XG5cbi8qKiBAY29uc3Qge09iamVjdDxzdHJpbmcsICFWZW5kb3JQcm9wZXJ0eU1hcFR5cGU+fSAqL1xuY29uc3QgZXZlbnRUeXBlTWFwID0ge1xuICAnYW5pbWF0aW9uc3RhcnQnOiB7XG4gICAgbm9QcmVmaXg6ICdhbmltYXRpb25zdGFydCcsXG4gICAgd2Via2l0UHJlZml4OiAnd2Via2l0QW5pbWF0aW9uU3RhcnQnLFxuICAgIHN0eWxlUHJvcGVydHk6ICdhbmltYXRpb24nLFxuICB9LFxuICAnYW5pbWF0aW9uZW5kJzoge1xuICAgIG5vUHJlZml4OiAnYW5pbWF0aW9uZW5kJyxcbiAgICB3ZWJraXRQcmVmaXg6ICd3ZWJraXRBbmltYXRpb25FbmQnLFxuICAgIHN0eWxlUHJvcGVydHk6ICdhbmltYXRpb24nLFxuICB9LFxuICAnYW5pbWF0aW9uaXRlcmF0aW9uJzoge1xuICAgIG5vUHJlZml4OiAnYW5pbWF0aW9uaXRlcmF0aW9uJyxcbiAgICB3ZWJraXRQcmVmaXg6ICd3ZWJraXRBbmltYXRpb25JdGVyYXRpb24nLFxuICAgIHN0eWxlUHJvcGVydHk6ICdhbmltYXRpb24nLFxuICB9LFxuICAndHJhbnNpdGlvbmVuZCc6IHtcbiAgICBub1ByZWZpeDogJ3RyYW5zaXRpb25lbmQnLFxuICAgIHdlYmtpdFByZWZpeDogJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxuICAgIHN0eWxlUHJvcGVydHk6ICd0cmFuc2l0aW9uJyxcbiAgfSxcbn07XG5cbi8qKiBAY29uc3Qge09iamVjdDxzdHJpbmcsICFWZW5kb3JQcm9wZXJ0eU1hcFR5cGU+fSAqL1xuY29uc3QgY3NzUHJvcGVydHlNYXAgPSB7XG4gICdhbmltYXRpb24nOiB7XG4gICAgbm9QcmVmaXg6ICdhbmltYXRpb24nLFxuICAgIHdlYmtpdFByZWZpeDogJy13ZWJraXQtYW5pbWF0aW9uJyxcbiAgfSxcbiAgJ3RyYW5zZm9ybSc6IHtcbiAgICBub1ByZWZpeDogJ3RyYW5zZm9ybScsXG4gICAgd2Via2l0UHJlZml4OiAnLXdlYmtpdC10cmFuc2Zvcm0nLFxuICB9LFxuICAndHJhbnNpdGlvbic6IHtcbiAgICBub1ByZWZpeDogJ3RyYW5zaXRpb24nLFxuICAgIHdlYmtpdFByZWZpeDogJy13ZWJraXQtdHJhbnNpdGlvbicsXG4gIH0sXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7IU9iamVjdH0gd2luZG93T2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBoYXNQcm9wZXJTaGFwZSh3aW5kb3dPYmopIHtcbiAgcmV0dXJuICh3aW5kb3dPYmpbJ2RvY3VtZW50J10gIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygd2luZG93T2JqWydkb2N1bWVudCddWydjcmVhdGVFbGVtZW50J10gPT09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGV2ZW50Rm91bmRJbk1hcHMoZXZlbnRUeXBlKSB7XG4gIHJldHVybiAoZXZlbnRUeXBlIGluIGV2ZW50VHlwZU1hcCB8fCBldmVudFR5cGUgaW4gY3NzUHJvcGVydHlNYXApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGVcbiAqIEBwYXJhbSB7IU9iamVjdDxzdHJpbmcsICFWZW5kb3JQcm9wZXJ0eU1hcFR5cGU+fSBtYXBcbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldEphdmFTY3JpcHRFdmVudE5hbWUoZXZlbnRUeXBlLCBtYXAsIGVsKSB7XG4gIHJldHVybiBtYXBbZXZlbnRUeXBlXS5zdHlsZVByb3BlcnR5IGluIGVsLnN0eWxlID8gbWFwW2V2ZW50VHlwZV0ubm9QcmVmaXggOiBtYXBbZXZlbnRUeXBlXS53ZWJraXRQcmVmaXg7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSBicm93c2VyIHByZWZpeCBmb3IgQ1NTMyBhbmltYXRpb24gZXZlbnRzXG4gKiBhbmQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcGFyYW0geyFPYmplY3R9IHdpbmRvd09ialxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRBbmltYXRpb25OYW1lKHdpbmRvd09iaiwgZXZlbnRUeXBlKSB7XG4gIGlmICghaGFzUHJvcGVyU2hhcGUod2luZG93T2JqKSB8fCAhZXZlbnRGb3VuZEluTWFwcyhldmVudFR5cGUpKSB7XG4gICAgcmV0dXJuIGV2ZW50VHlwZTtcbiAgfVxuXG4gIGNvbnN0IG1hcCA9IC8qKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsICFWZW5kb3JQcm9wZXJ0eU1hcFR5cGU+fSAqLyAoXG4gICAgZXZlbnRUeXBlIGluIGV2ZW50VHlwZU1hcCA/IGV2ZW50VHlwZU1hcCA6IGNzc1Byb3BlcnR5TWFwXG4gICk7XG4gIGNvbnN0IGVsID0gd2luZG93T2JqWydkb2N1bWVudCddWydjcmVhdGVFbGVtZW50J10oJ2RpdicpO1xuICBsZXQgZXZlbnROYW1lID0gJyc7XG5cbiAgaWYgKG1hcCA9PT0gZXZlbnRUeXBlTWFwKSB7XG4gICAgZXZlbnROYW1lID0gZ2V0SmF2YVNjcmlwdEV2ZW50TmFtZShldmVudFR5cGUsIG1hcCwgZWwpO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50TmFtZSA9IG1hcFtldmVudFR5cGVdLm5vUHJlZml4IGluIGVsLnN0eWxlID8gbWFwW2V2ZW50VHlwZV0ubm9QcmVmaXggOiBtYXBbZXZlbnRUeXBlXS53ZWJraXRQcmVmaXg7XG4gIH1cblxuICByZXR1cm4gZXZlbnROYW1lO1xufVxuXG4vLyBQdWJsaWMgZnVuY3Rpb25zIHRvIGFjY2VzcyBnZXRBbmltYXRpb25OYW1lKCkgZm9yIEphdmFTY3JpcHQgZXZlbnRzIG9yIENTU1xuLy8gcHJvcGVydHkgbmFtZXMuXG5cbmNvbnN0IHRyYW5zZm9ybVN0eWxlUHJvcGVydGllcyA9IFsndHJhbnNmb3JtJywgJ1dlYmtpdFRyYW5zZm9ybScsICdNb3pUcmFuc2Zvcm0nLCAnT1RyYW5zZm9ybScsICdNU1RyYW5zZm9ybSddO1xuXG4vKipcbiAqIEBwYXJhbSB7IU9iamVjdH0gd2luZG93T2JqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvcnJlY3RFdmVudE5hbWUod2luZG93T2JqLCBldmVudFR5cGUpIHtcbiAgcmV0dXJuIGdldEFuaW1hdGlvbk5hbWUod2luZG93T2JqLCBldmVudFR5cGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IU9iamVjdH0gd2luZG93T2JqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvcnJlY3RQcm9wZXJ0eU5hbWUod2luZG93T2JqLCBldmVudFR5cGUpIHtcbiAgcmV0dXJuIGdldEFuaW1hdGlvbk5hbWUod2luZG93T2JqLCBldmVudFR5cGUpO1xufVxuXG5leHBvcnQge3RyYW5zZm9ybVN0eWxlUHJvcGVydGllcywgZ2V0Q29ycmVjdEV2ZW50TmFtZSwgZ2V0Q29ycmVjdFByb3BlcnR5TmFtZX07XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXZcbiAgICA6Y2xhc3M9XCJmb3JtRmllbGRDbGFzc2VzXCJcbiAgICBjbGFzcz1cIm1kYy1jaGVja2JveC13cmFwcGVyXCI+XG4gICAgPGRpdlxuICAgICAgcmVmPVwicm9vdFwiXG4gICAgICA6Y2xhc3M9XCJjbGFzc2VzXCJcbiAgICAgIDpzdHlsZT1cInN0eWxlc1wiXG4gICAgICBjbGFzcz1cIm1kYy1jaGVja2JveFwiPlxuICAgICAgPGlucHV0XG4gICAgICAgIHJlZj1cImNvbnRyb2xcIlxuICAgICAgICA6aWQ9XCJ2bWFfdWlkX1wiXG4gICAgICAgIDpuYW1lPVwibmFtZVwiXG4gICAgICAgIDp2YWx1ZT1cInZhbHVlXCJcbiAgICAgICAgdHlwZT1cImNoZWNrYm94XCJcbiAgICAgICAgY2xhc3M9XCJtZGMtY2hlY2tib3hfX25hdGl2ZS1jb250cm9sXCJcbiAgICAgICAgQGNoYW5nZT1cIm9uQ2hhbmdlXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwibWRjLWNoZWNrYm94X19iYWNrZ3JvdW5kXCI+XG4gICAgICAgIDxzdmdcbiAgICAgICAgICBjbGFzcz1cIm1kYy1jaGVja2JveF9fY2hlY2ttYXJrXCJcbiAgICAgICAgICB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XG4gICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgIGNsYXNzPVwibWRjLWNoZWNrYm94X19jaGVja21hcmstcGF0aFwiXG4gICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICBzdHJva2U9XCJ3aGl0ZVwiXG4gICAgICAgICAgICBkPVwiTTEuNzMsMTIuOTEgOC4xLDE5LjI4IDIyLjc5LDQuNTlcIi8+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgICA8ZGl2IGNsYXNzPVwibWRjLWNoZWNrYm94X19taXhlZG1hcmtcIi8+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8bGFiZWxcbiAgICAgIHJlZj1cImxhYmVsXCJcbiAgICAgIDpmb3I9XCJ2bWFfdWlkX1wiXG4gICAgPjxzbG90Pnt7IGxhYmVsIH19PC9zbG90PjwvbGFiZWw+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbi8qIGdsb2JhbCBIVE1MRWxlbWVudCAqL1xuaW1wb3J0IE1EQ0NoZWNrYm94Rm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvY2hlY2tib3gvZm91bmRhdGlvbidcbmltcG9ydCBNRENGb3JtRmllbGRGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9mb3JtLWZpZWxkL2ZvdW5kYXRpb24nXG5pbXBvcnQgeyBnZXRDb3JyZWN0RXZlbnROYW1lIH0gZnJvbSAnQG1hdGVyaWFsL2FuaW1hdGlvbidcbmltcG9ydCB7IERpc3BhdGNoRm9jdXNNaXhpbiwgVk1BVW5pcXVlSWRNaXhpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgeyBSaXBwbGVCYXNlIH0gZnJvbSAnLi4vcmlwcGxlJ1xuaW1wb3J0IHsgYXBwbHlQYXNzaXZlIH0gZnJvbSAnLi4vYmFzZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWNoZWNrYm94JyxcbiAgbWl4aW5zOiBbRGlzcGF0Y2hGb2N1c01peGluLCBWTUFVbmlxdWVJZE1peGluXSxcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAnY2hlY2tlZCcsXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgY2hlY2tlZDogW0Jvb2xlYW4sIEFycmF5XSxcbiAgICBpbmRldGVybWluYXRlOiBCb29sZWFuLFxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgIGxhYmVsOiBTdHJpbmcsXG4gICAgJ2FsaWduLWVuZCc6IEJvb2xlYW4sXG4gICAgdmFsdWU6IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgICBkZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gJ29uJ1xuICAgICAgfVxuICAgIH0sXG4gICAgbmFtZTogU3RyaW5nXG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0eWxlczoge30sXG4gICAgICBjbGFzc2VzOiB7fVxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBoYXNMYWJlbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxhYmVsIHx8IHRoaXMuJHNsb3RzLmRlZmF1bHRcbiAgICB9LFxuICAgIGZvcm1GaWVsZENsYXNzZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWRjLWZvcm0tZmllbGQnOiB0aGlzLmhhc0xhYmVsLFxuICAgICAgICAnbWRjLWZvcm0tZmllbGQtLWFsaWduLWVuZCc6IHRoaXMuaGFzTGFiZWwgJiYgdGhpcy5hbGlnbkVuZFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBjaGVja2VkOiAnc2V0Q2hlY2tlZCcsXG4gICAgZGlzYWJsZWQodmFsdWUpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXREaXNhYmxlZCh2YWx1ZSlcbiAgICB9LFxuICAgIGluZGV0ZXJtaW5hdGUodmFsdWUpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRJbmRldGVybWluYXRlKHZhbHVlKVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDQ2hlY2tib3hGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKSxcbiAgICAgIHNldE5hdGl2ZUNvbnRyb2xBdHRyOiAoYXR0ciwgdmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5jb250cm9sLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSlcbiAgICAgIH0sXG4gICAgICByZW1vdmVOYXRpdmVDb250cm9sQXR0cjogYXR0ciA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuY29udHJvbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cilcbiAgICAgIH0sXG4gICAgICByZWdpc3RlckFuaW1hdGlvbkVuZEhhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5yb290LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgZ2V0Q29ycmVjdEV2ZW50TmFtZSh3aW5kb3csICdhbmltYXRpb25lbmQnKSxcbiAgICAgICAgICBoYW5kbGVyXG4gICAgICAgICksXG4gICAgICBkZXJlZ2lzdGVyQW5pbWF0aW9uRW5kSGFuZGxlcjogaGFuZGxlciA9PlxuICAgICAgICB0aGlzLiRyZWZzLnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICBnZXRDb3JyZWN0RXZlbnROYW1lKHdpbmRvdywgJ2FuaW1hdGlvbmVuZCcpLFxuICAgICAgICAgIGhhbmRsZXJcbiAgICAgICAgKSxcbiAgICAgIHJlZ2lzdGVyQ2hhbmdlSGFuZGxlcjogaGFuZGxlciA9PlxuICAgICAgICB0aGlzLiRyZWZzLmNvbnRyb2wuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVyQ2hhbmdlSGFuZGxlcjogaGFuZGxlciA9PlxuICAgICAgICB0aGlzLiRyZWZzLmNvbnRyb2wucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgaGFuZGxlciksXG4gICAgICBnZXROYXRpdmVDb250cm9sOiAoKSA9PiB0aGlzLiRyZWZzLmNvbnRyb2wsXG4gICAgICBmb3JjZUxheW91dDogKCkgPT4gdGhpcy4kcmVmcy5yb290Lm9mZnNldFdpZHRoLFxuICAgICAgaXNBdHRhY2hlZFRvRE9NOiAoKSA9PiBCb29sZWFuKHRoaXMuJGVsLnBhcmVudE5vZGUpXG4gICAgfSlcblxuICAgIHRoaXMucmlwcGxlID0gbmV3IFJpcHBsZUJhc2UodGhpcywge1xuICAgICAgaXNVbmJvdW5kZWQ6ICgpID0+IHRydWUsXG4gICAgICBpc1N1cmZhY2VBY3RpdmU6ICgpID0+IFJpcHBsZUJhc2UuaXNTdXJmYWNlQWN0aXZlKHRoaXMuJHJlZnMuY29udHJvbCksXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmNvbnRyb2wuYWRkRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIsIGFwcGx5UGFzc2l2ZSgpKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5jb250cm9sLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyLCBhcHBseVBhc3NpdmUoKSlcbiAgICAgIH0sXG4gICAgICBjb21wdXRlQm91bmRpbmdSZWN0OiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiRyZWZzLnJvb3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5mb3JtRmllbGQgPSBuZXcgTURDRm9ybUZpZWxkRm91bmRhdGlvbih7XG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5sYWJlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5sYWJlbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgYWN0aXZhdGVJbnB1dFJpcHBsZTogKCkgPT4ge1xuICAgICAgICB0aGlzLnJpcHBsZSAmJiB0aGlzLnJpcHBsZS5hY3RpdmF0ZSgpXG4gICAgICB9LFxuICAgICAgZGVhY3RpdmF0ZUlucHV0UmlwcGxlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMucmlwcGxlICYmIHRoaXMucmlwcGxlLmRlYWN0aXZhdGUoKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gICAgdGhpcy5yaXBwbGUuaW5pdCgpXG4gICAgdGhpcy5mb3JtRmllbGQuaW5pdCgpXG4gICAgdGhpcy5zZXRDaGVja2VkKHRoaXMuY2hlY2tlZClcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0RGlzYWJsZWQodGhpcy5kaXNhYmxlZClcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0SW5kZXRlcm1pbmF0ZSh0aGlzLmluZGV0ZXJtaW5hdGUpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5mb3JtRmllbGQuZGVzdHJveSgpXG4gICAgdGhpcy5yaXBwbGUuZGVzdHJveSgpXG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgc2V0Q2hlY2tlZChjaGVja2VkKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0Q2hlY2tlZChcbiAgICAgICAgQXJyYXkuaXNBcnJheShjaGVja2VkKSA/IGNoZWNrZWQuaW5kZXhPZih0aGlzLnZhbHVlKSA+IC0xIDogY2hlY2tlZFxuICAgICAgKVxuICAgIH0sXG5cbiAgICBvbkNoYW5nZSgpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ3VwZGF0ZTppbmRldGVybWluYXRlJywgdGhpcy5mb3VuZGF0aW9uLmlzSW5kZXRlcm1pbmF0ZSgpKVxuICAgICAgY29uc3QgaXNDaGVja2VkID0gdGhpcy5mb3VuZGF0aW9uLmlzQ2hlY2tlZCgpXG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuY2hlY2tlZCkpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5jaGVja2VkLmluZGV4T2YodGhpcy52YWx1ZSlcbiAgICAgICAgaWYgKGlzQ2hlY2tlZCkge1xuICAgICAgICAgIGlkeCA8IDAgJiYgdGhpcy4kZW1pdCgnY2hhbmdlJywgdGhpcy5jaGVja2VkLmNvbmNhdCh0aGlzLnZhbHVlKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZHggPiAtMSAmJlxuICAgICAgICAgICAgdGhpcy4kZW1pdChcbiAgICAgICAgICAgICAgJ2NoYW5nZScsXG4gICAgICAgICAgICAgIHRoaXMuY2hlY2tlZC5zbGljZSgwLCBpZHgpLmNvbmNhdCh0aGlzLmNoZWNrZWQuc2xpY2UoaWR4ICsgMSkpXG4gICAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGlzQ2hlY2tlZClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjQ2hlY2tib3ggZnJvbSAnLi9tZGMtY2hlY2tib3gudnVlJ1xuXG5leHBvcnQgeyBtZGNDaGVja2JveCB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNDaGVja2JveFxufSlcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgQ2hpcC5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBDaGlwIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENDaGlwQWRhcHRlciB7XG4gIC8qKlxuICAgKiBBZGRzIGEgY2xhc3MgdG8gdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2xhc3MgZnJvbSB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcm9vdCBlbGVtZW50IGNvbnRhaW5zIHRoZSBnaXZlbiBjbGFzcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY2xhc3MgdG8gdGhlIGxlYWRpbmcgaWNvbiBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBhZGRDbGFzc1RvTGVhZGluZ0ljb24oY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2xhc3MgZnJvbSB0aGUgbGVhZGluZyBpY29uIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIHJlbW92ZUNsYXNzRnJvbUxlYWRpbmdJY29uKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRhcmdldCBoYXMgY2xhc3NOYW1lLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwYXJhbSB7IUV2ZW50VGFyZ2V0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZXZlbnRUYXJnZXRIYXNDbGFzcyh0YXJnZXQsIGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSByb290IGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckV2ZW50SGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiB0aGUgcm9vdCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckV2ZW50SGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIHRyYWlsaW5nIGljb24gZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVyVHJhaWxpbmdJY29uSW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSB0cmFpbGluZyBpY29uIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyVHJhaWxpbmdJY29uSW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGEgY3VzdG9tIFwiTURDQ2hpcDppbnRlcmFjdGlvblwiIGV2ZW50IGRlbm90aW5nIHRoZSBjaGlwIGhhcyBiZWVuXG4gICAqIGludGVyYWN0ZWQgd2l0aCAodHlwaWNhbGx5IG9uIGNsaWNrIG9yIGtleWRvd24pLlxuICAgKi9cbiAgbm90aWZ5SW50ZXJhY3Rpb24oKSB7fVxuXG4gIC8qKlxuICAgKiBFbWl0cyBhIGN1c3RvbSBcIk1EQ0NoaXA6dHJhaWxpbmdJY29uSW50ZXJhY3Rpb25cIiBldmVudCBkZW5vdGluZyB0aGUgdHJhaWxpbmcgaWNvbiBoYXMgYmVlblxuICAgKiBpbnRlcmFjdGVkIHdpdGggKHR5cGljYWxseSBvbiBjbGljayBvciBrZXlkb3duKS5cbiAgICovXG4gIG5vdGlmeVRyYWlsaW5nSWNvbkludGVyYWN0aW9uKCkge31cblxuICAvKipcbiAgICogRW1pdHMgYSBjdXN0b20gZXZlbnQgXCJNRENDaGlwOnJlbW92YWxcIiBkZW5vdGluZyB0aGUgY2hpcCB3aWxsIGJlIHJlbW92ZWQuXG4gICAqL1xuICBub3RpZnlSZW1vdmFsKCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29tcHV0ZWQgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIHN0eWxlIHByb3BlcnR5IG9uIHRoZSByb290IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWVcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKHByb3BlcnR5TmFtZSkge31cblxuICAvKipcbiAgICogU2V0cyB0aGUgcHJvcGVydHkgdmFsdWUgb2YgdGhlIGdpdmVuIHN0eWxlIHByb3BlcnR5IG9uIHRoZSByb290IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRTdHlsZVByb3BlcnR5KHByb3BlcnR5TmFtZSwgdmFsdWUpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0NoaXBBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgRU5UUllfQU5JTUFUSU9OX05BTUU6ICdtZGMtY2hpcC1lbnRyeScsXG4gIElOVEVSQUNUSU9OX0VWRU5UOiAnTURDQ2hpcDppbnRlcmFjdGlvbicsXG4gIFRSQUlMSU5HX0lDT05fSU5URVJBQ1RJT05fRVZFTlQ6ICdNRENDaGlwOnRyYWlsaW5nSWNvbkludGVyYWN0aW9uJyxcbiAgUkVNT1ZBTF9FVkVOVDogJ01EQ0NoaXA6cmVtb3ZhbCcsXG4gIENIRUNLTUFSS19TRUxFQ1RPUjogJy5tZGMtY2hpcF9fY2hlY2ttYXJrJyxcbiAgTEVBRElOR19JQ09OX1NFTEVDVE9SOiAnLm1kYy1jaGlwX19pY29uLS1sZWFkaW5nJyxcbiAgVFJBSUxJTkdfSUNPTl9TRUxFQ1RPUjogJy5tZGMtY2hpcF9faWNvbi0tdHJhaWxpbmcnLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBDSEVDS01BUks6ICdtZGMtY2hpcF9fY2hlY2ttYXJrJyxcbiAgQ0hJUF9FWElUOiAnbWRjLWNoaXAtLWV4aXQnLFxuICBISURERU5fTEVBRElOR19JQ09OOiAnbWRjLWNoaXBfX2ljb24tLWxlYWRpbmctaGlkZGVuJyxcbiAgTEVBRElOR19JQ09OOiAnbWRjLWNoaXBfX2ljb24tLWxlYWRpbmcnLFxuICBUUkFJTElOR19JQ09OOiAnbWRjLWNoaXBfX2ljb24tLXRyYWlsaW5nJyxcbiAgU0VMRUNURUQ6ICdtZGMtY2hpcC0tc2VsZWN0ZWQnLFxufTtcblxuZXhwb3J0IHtzdHJpbmdzLCBjc3NDbGFzc2VzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENDaGlwQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IHtzdHJpbmdzLCBjc3NDbGFzc2VzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDQ2hpcEFkYXB0ZXI+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ0NoaXBGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgTURDQ2hpcEFkYXB0ZXJ9IGZvciB0eXBpbmcgaW5mb3JtYXRpb24gb24gcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAqIHR5cGVzLlxuICAgKiBAcmV0dXJuIHshTURDQ2hpcEFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENDaGlwQWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoKSA9PiB7fSxcbiAgICAgIGhhc0NsYXNzOiAoKSA9PiB7fSxcbiAgICAgIGFkZENsYXNzVG9MZWFkaW5nSWNvbjogKCkgPT4ge30sXG4gICAgICByZW1vdmVDbGFzc0Zyb21MZWFkaW5nSWNvbjogKCkgPT4ge30sXG4gICAgICBldmVudFRhcmdldEhhc0NsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyRXZlbnRIYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJFdmVudEhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgcmVnaXN0ZXJUcmFpbGluZ0ljb25JbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclRyYWlsaW5nSWNvbkludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBub3RpZnlJbnRlcmFjdGlvbjogKCkgPT4ge30sXG4gICAgICBub3RpZnlUcmFpbGluZ0ljb25JbnRlcmFjdGlvbjogKCkgPT4ge30sXG4gICAgICBub3RpZnlSZW1vdmFsOiAoKSA9PiB7fSxcbiAgICAgIGdldENvbXB1dGVkU3R5bGVWYWx1ZTogKCkgPT4ge30sXG4gICAgICBzZXRTdHlsZVByb3BlcnR5OiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENDaGlwQWRhcHRlcn0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDQ2hpcEZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgYSB0cmFpbGluZyBpY29uIGNsaWNrIHNob3VsZCBpbW1lZGlhdGVseSB0cmlnZ2VyIGV4aXQvcmVtb3ZhbCBvZiB0aGUgY2hpcC5cbiAgICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cbiAgICAgKiAqL1xuICAgIHRoaXMuc2hvdWxkUmVtb3ZlT25UcmFpbGluZ0ljb25DbGlja18gPSB0cnVlO1xuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlSW50ZXJhY3Rpb24oZXZ0KTtcbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlVHJhbnNpdGlvbkVuZChldnQpO1xuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMudHJhaWxpbmdJY29uSW50ZXJhY3Rpb25IYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlVHJhaWxpbmdJY29uSW50ZXJhY3Rpb24oZXZ0KTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgWydjbGljaycsICdrZXlkb3duJ10uZm9yRWFjaCgoZXZ0VHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckV2ZW50SGFuZGxlcihldnRUeXBlLCB0aGlzLmludGVyYWN0aW9uSGFuZGxlcl8pO1xuICAgIH0pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJFdmVudEhhbmRsZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyk7XG4gICAgWydjbGljaycsICdrZXlkb3duJywgJ3RvdWNoc3RhcnQnLCAncG9pbnRlcmRvd24nLCAnbW91c2Vkb3duJ10uZm9yRWFjaCgoZXZ0VHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclRyYWlsaW5nSWNvbkludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCB0aGlzLnRyYWlsaW5nSWNvbkludGVyYWN0aW9uSGFuZGxlcl8pO1xuICAgIH0pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBbJ2NsaWNrJywgJ2tleWRvd24nXS5mb3JFYWNoKChldnRUeXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJFdmVudEhhbmRsZXIoZXZ0VHlwZSwgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXJfKTtcbiAgICB9KTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJFdmVudEhhbmRsZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyk7XG4gICAgWydjbGljaycsICdrZXlkb3duJywgJ3RvdWNoc3RhcnQnLCAncG9pbnRlcmRvd24nLCAnbW91c2Vkb3duJ10uZm9yRWFjaCgoZXZ0VHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyVHJhaWxpbmdJY29uSW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMudHJhaWxpbmdJY29uSW50ZXJhY3Rpb25IYW5kbGVyXyk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzU2VsZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5TRUxFQ1RFRCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBzZWxlY3RlZFxuICAgKi9cbiAgc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpIHtcbiAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5TRUxFQ1RFRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5TRUxFQ1RFRCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBnZXRTaG91bGRSZW1vdmVPblRyYWlsaW5nSWNvbkNsaWNrKCkge1xuICAgIHJldHVybiB0aGlzLnNob3VsZFJlbW92ZU9uVHJhaWxpbmdJY29uQ2xpY2tfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkUmVtb3ZlXG4gICAqL1xuICBzZXRTaG91bGRSZW1vdmVPblRyYWlsaW5nSWNvbkNsaWNrKHNob3VsZFJlbW92ZSkge1xuICAgIHRoaXMuc2hvdWxkUmVtb3ZlT25UcmFpbGluZ0ljb25DbGlja18gPSBzaG91bGRSZW1vdmU7XG4gIH1cblxuICAvKipcbiAgICogQmVnaW5zIHRoZSBleGl0IGFuaW1hdGlvbiB3aGljaCBsZWFkcyB0byByZW1vdmFsIG9mIHRoZSBjaGlwLlxuICAgKi9cbiAgYmVnaW5FeGl0KCkge1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5DSElQX0VYSVQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYW4gaW50ZXJhY3Rpb24gZXZlbnQgb24gdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKi9cbiAgaGFuZGxlSW50ZXJhY3Rpb24oZXZ0KSB7XG4gICAgaWYgKGV2dC50eXBlID09PSAnY2xpY2snIHx8IGV2dC5rZXkgPT09ICdFbnRlcicgfHwgZXZ0LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUludGVyYWN0aW9uKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSB0cmFuc2l0aW9uIGVuZCBldmVudCBvbiB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqL1xuICBoYW5kbGVUcmFuc2l0aW9uRW5kKGV2dCkge1xuICAgIC8vIEhhbmRsZSB0cmFuc2l0aW9uIGVuZCBldmVudCBvbiB0aGUgY2hpcCB3aGVuIGl0IGlzIGFib3V0IHRvIGJlIHJlbW92ZWQuXG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uZXZlbnRUYXJnZXRIYXNDbGFzcygvKiogQHR5cGUgeyFFdmVudFRhcmdldH0gKi8gKGV2dC50YXJnZXQpLCBjc3NDbGFzc2VzLkNISVBfRVhJVCkpIHtcbiAgICAgIGlmIChldnQucHJvcGVydHlOYW1lID09PSAnd2lkdGgnKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5UmVtb3ZhbCgpO1xuICAgICAgfSBlbHNlIGlmIChldnQucHJvcGVydHlOYW1lID09PSAnb3BhY2l0eScpIHtcbiAgICAgICAgLy8gU2VlOiBodHRwczovL2Nzcy10cmlja3MuY29tL3VzaW5nLWNzcy10cmFuc2l0aW9ucy1hdXRvLWRpbWVuc2lvbnMvI2FydGljbGUtaGVhZGVyLWlkLTVcbiAgICAgICAgY29uc3QgY2hpcFdpZHRoID0gdGhpcy5hZGFwdGVyXy5nZXRDb21wdXRlZFN0eWxlVmFsdWUoJ3dpZHRoJyk7XG5cbiAgICAgICAgLy8gT24gdGhlIG5leHQgZnJhbWUgKG9uY2Ugd2UgZ2V0IHRoZSBjb21wdXRlZCB3aWR0aCksIGV4cGxpY2l0bHkgc2V0IHRoZSBjaGlwJ3Mgd2lkdGhcbiAgICAgICAgLy8gdG8gaXRzIGN1cnJlbnQgcGl4ZWwgd2lkdGgsIHNvIHdlIGFyZW4ndCB0cmFuc2l0aW9uaW5nIG91dCBvZiAnYXV0bycuXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZVByb3BlcnR5KCd3aWR0aCcsIGNoaXBXaWR0aCk7XG5cbiAgICAgICAgICAvLyBUbyBtaXRpZ2F0ZSBqaXR0ZXIsIHN0YXJ0IHRyYW5zaXRpb25pbmcgcGFkZGluZyBhbmQgbWFyZ2luIGJlZm9yZSB3aWR0aC5cbiAgICAgICAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlUHJvcGVydHkoJ3BhZGRpbmcnLCAnMCcpO1xuICAgICAgICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGVQcm9wZXJ0eSgnbWFyZ2luJywgJzAnKTtcblxuICAgICAgICAgIC8vIE9uIHRoZSBuZXh0IGZyYW1lIChvbmNlIHdpZHRoIGlzIGV4cGxpY2l0bHkgc2V0KSwgdHJhbnNpdGlvbiB3aWR0aCB0byAwLlxuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlUHJvcGVydHkoJ3dpZHRoJywgJzAnKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGEgdHJhbnNpdGlvbiBlbmQgZXZlbnQgb24gdGhlIGxlYWRpbmcgaWNvbiBvciBjaGVja21hcmssIHNpbmNlIHRoZSB0cmFuc2l0aW9uIGVuZCBldmVudCBidWJibGVzLlxuICAgIGlmIChldnQucHJvcGVydHlOYW1lICE9PSAnb3BhY2l0eScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uZXZlbnRUYXJnZXRIYXNDbGFzcygvKiogQHR5cGUgeyFFdmVudFRhcmdldH0gKi8gKGV2dC50YXJnZXQpLCBjc3NDbGFzc2VzLkxFQURJTkdfSUNPTikgJiZcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhjc3NDbGFzc2VzLlNFTEVDVEVEKSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzc1RvTGVhZGluZ0ljb24oY3NzQ2xhc3Nlcy5ISURERU5fTEVBRElOR19JQ09OKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYWRhcHRlcl8uZXZlbnRUYXJnZXRIYXNDbGFzcygvKiogQHR5cGUgeyFFdmVudFRhcmdldH0gKi8gKGV2dC50YXJnZXQpLCBjc3NDbGFzc2VzLkNIRUNLTUFSSykgJiZcbiAgICAgICAgICAgICAgICF0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuU0VMRUNURUQpKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzRnJvbUxlYWRpbmdJY29uKGNzc0NsYXNzZXMuSElEREVOX0xFQURJTkdfSUNPTik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYW4gaW50ZXJhY3Rpb24gZXZlbnQgb24gdGhlIHRyYWlsaW5nIGljb24gZWxlbWVudC4gVGhpcyBpcyB1c2VkIHRvXG4gICAqIHByZXZlbnQgdGhlIHJpcHBsZSBmcm9tIGFjdGl2YXRpbmcgb24gaW50ZXJhY3Rpb24gd2l0aCB0aGUgdHJhaWxpbmcgaWNvbi5cbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKi9cbiAgaGFuZGxlVHJhaWxpbmdJY29uSW50ZXJhY3Rpb24oZXZ0KSB7XG4gICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGlmIChldnQudHlwZSA9PT0gJ2NsaWNrJyB8fCBldnQua2V5ID09PSAnRW50ZXInIHx8IGV2dC5rZXlDb2RlID09PSAxMykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlUcmFpbGluZ0ljb25JbnRlcmFjdGlvbigpO1xuICAgICAgaWYgKHRoaXMuc2hvdWxkUmVtb3ZlT25UcmFpbGluZ0ljb25DbGlja18pIHtcbiAgICAgICAgdGhpcy5iZWdpbkV4aXQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBkZXRhaWw6IHtcbiAqICAgICBjaGlwOiB7Zm91bmRhdGlvbjogIU1EQ0NoaXBGb3VuZGF0aW9ufSxcbiAqICAgfSxcbiAqICAgYnViYmxlczogYm9vbGVhbixcbiAqIH19XG4gKi9cbmxldCBNRENDaGlwSW50ZXJhY3Rpb25FdmVudFR5cGU7XG5cbmV4cG9ydCB7TURDQ2hpcEZvdW5kYXRpb24sIE1EQ0NoaXBJbnRlcmFjdGlvbkV2ZW50VHlwZX07XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXZcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCJcbiAgICA6c3R5bGU9XCJzdHlsZXNcIlxuICAgIHRhYmluZGV4PVwiMFwiXG4gICAgdi1vbj1cIiRsaXN0ZW5lcnNcIj5cbiAgICA8aVxuICAgICAgdi1pZj1cImhhdmVsZWFkaW5nSWNvblwiXG4gICAgICByZWY9XCJsZWFkaW5nSWNvblwiXG4gICAgICA6Y2xhc3M9XCJsZWFkaW5nQ2xhc3Nlc1wiXG4gICAgICBjbGFzcz1cIm1kYy1jaGlwX19pY29uIG1kYy1jaGlwX19pY29uLS1sZWFkaW5nXCJcbiAgICA+e3sgbGVhZGluZ0ljb24gfX08L2k+XG4gICAgPGRpdlxuICAgICAgdi1pZj1cImlzRmlsdGVyXCJcbiAgICAgIGNsYXNzPVwibWRjLWNoaXBfX2NoZWNrbWFya1wiPlxuICAgICAgPHN2Z1xuICAgICAgICBjbGFzcz1cIm1kYy1jaGlwX19jaGVja21hcmstc3ZnXCJcbiAgICAgICAgdmlld0JveD1cIi0yIC0zIDMwIDMwXCI+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgY2xhc3M9XCJtZGMtY2hpcF9fY2hlY2ttYXJrLXBhdGhcIlxuICAgICAgICAgIGZpbGw9XCJub25lXCJcbiAgICAgICAgICBzdHJva2U9XCJibGFja1wiXG4gICAgICAgICAgZD1cIk0xLjczLDEyLjkxIDguMSwxOS4yOCAyMi43OSw0LjU5XCIvPlxuICAgICAgPC9zdmc+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cIm1kYy1jaGlwX190ZXh0XCI+XG4gICAgICA8c2xvdC8+XG4gICAgPC9kaXY+XG4gICAgPGlcbiAgICAgIHYtaWY9XCJoYXZldHJhaWxpbmdJY29uXCJcbiAgICAgIHJlZj1cInRyYWlsaW5nSWNvblwiXG4gICAgICA6Y2xhc3M9XCJ0cmFpbGluZ0NsYXNzZXNcIlxuICAgICAgY2xhc3M9XCJtZGMtY2hpcF9faWNvbiBtZGMtY2hpcF9faWNvbi0tdHJhaWxpbmdcIlxuICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgIHJvbGU9XCJidXR0b25cIlxuICAgID57eyB0cmFpbGluZ0ljb24gfX08L2k+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cbmFwcGx5UGFzc2l2ZVxuPHNjcmlwdD5cbmltcG9ydCB7IE1EQ0NoaXBGb3VuZGF0aW9uIH0gZnJvbSAnQG1hdGVyaWFsL2NoaXBzL2NoaXAvZm91bmRhdGlvbidcbmltcG9ydCB7IEN1c3RvbUxpbmtNaXhpbiwgZW1pdEN1c3RvbUV2ZW50LCBhcHBseVBhc3NpdmUgfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IHsgUmlwcGxlQmFzZSB9IGZyb20gJy4uL3JpcHBsZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWNoaXAnLFxuICBtaXhpbnM6IFtDdXN0b21MaW5rTWl4aW5dLFxuICBwcm9wczoge1xuICAgIGxlYWRpbmdJY29uOiBbU3RyaW5nXSxcbiAgICB0cmFpbGluZ0ljb246IFtTdHJpbmddLFxuICAgIGxlYWRpbmdJY29uQ2xhc3NlczogW09iamVjdF0sXG4gICAgdHJhaWxpbmdJY29uQ2xhc3NlczogW09iamVjdF1cbiAgfSxcbiAgaW5qZWN0OiBbJ21kY0NoaXBTZXQnXSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge1xuICAgICAgICAnbWRjLWNoaXAnOiB0cnVlXG4gICAgICB9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBpc0ZpbHRlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLm1kY0NoaXBTZXQgJiYgdGhpcy5tZGNDaGlwU2V0LmZpbHRlclxuICAgIH0sXG4gICAgaGF2ZWxlYWRpbmdJY29uKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5sZWFkaW5nSWNvbiB8fCB0aGlzLmxlYWRpbmdJY29uQ2xhc3Nlc1xuICAgIH0sXG4gICAgaGF2ZXRyYWlsaW5nSWNvbigpIHtcbiAgICAgIHJldHVybiAhIXRoaXMudHJhaWxpbmdJY29uIHx8IHRoaXMudHJhaWxpbmdJY29uQ2xhc3Nlc1xuICAgIH0sXG4gICAgbGVhZGluZ0NsYXNzZXMoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAge30sXG4gICAgICAgIHtcbiAgICAgICAgICAnbWF0ZXJpYWwtaWNvbnMnOiAhIXRoaXMubGVhZGluZ0ljb25cbiAgICAgICAgfSxcbiAgICAgICAgdGhpcy5sZWFkaW5nSWNvbkNsYXNzZXNcbiAgICAgIClcbiAgICB9LFxuICAgIHRyYWlsaW5nQ2xhc3NlcygpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFxuICAgICAgICB7fSxcbiAgICAgICAge1xuICAgICAgICAgICdtYXRlcmlhbC1pY29ucyc6ICEhdGhpcy50cmFpbGluZ0ljb25cbiAgICAgICAgfSxcbiAgICAgICAgdGhpcy50cmFpbGluZ0ljb25DbGFzc2VzXG4gICAgICApXG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENDaGlwRm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSksXG4gICAgICByZW1vdmVDbGFzczogY2xhc3NOYW1lID0+IHRoaXMuJGRlbGV0ZSh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSksXG4gICAgICBoYXNDbGFzczogY2xhc3NOYW1lID0+IHRoaXMuJGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpLFxuICAgICAgYWRkQ2xhc3NUb0xlYWRpbmdJY29uOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICBpZiAodGhpcy5oYXZlbGVhZGluZ0ljb24pIHtcbiAgICAgICAgICB0aGlzLiRyZWZzLmxlYWRpbmdJY29uLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVtb3ZlQ2xhc3NGcm9tTGVhZGluZ0ljb246IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmhhdmVsZWFkaW5nSWNvbikge1xuICAgICAgICAgIHRoaXMuJHJlZnMubGVhZGluZ0ljb24uY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBldmVudFRhcmdldEhhc0NsYXNzOiAodGFyZ2V0LCBjbGFzc05hbWUpID0+XG4gICAgICAgIHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSxcbiAgICAgIHJlZ2lzdGVyRXZlbnRIYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT5cbiAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJFdmVudEhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PlxuICAgICAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpLFxuICAgICAgbm90aWZ5SW50ZXJhY3Rpb246ICgpID0+IHtcbiAgICAgICAgZW1pdEN1c3RvbUV2ZW50KFxuICAgICAgICAgIHRoaXMuJGVsLFxuICAgICAgICAgIE1EQ0NoaXBGb3VuZGF0aW9uLnN0cmluZ3MuSU5URVJBQ1RJT05fRVZFTlQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2hpcDogdGhpc1xuICAgICAgICAgIH0sXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgbm90aWZ5VHJhaWxpbmdJY29uSW50ZXJhY3Rpb246ICgpID0+IHtcbiAgICAgICAgZW1pdEN1c3RvbUV2ZW50KFxuICAgICAgICAgIHRoaXMuJGVsLFxuICAgICAgICAgIE1EQ0NoaXBGb3VuZGF0aW9uLnN0cmluZ3MuVFJBSUxJTkdfSUNPTl9JTlRFUkFDVElPTl9FVkVOVCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjaGlwOiB0aGlzXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cnVlXG4gICAgICAgIClcbiAgICAgIH0sXG5cbiAgICAgIHJlZ2lzdGVyVHJhaWxpbmdJY29uSW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICBpZiAodGhpcy4kcmVmcy50cmFpbGluZ0ljb24pIHtcbiAgICAgICAgICB0aGlzLiRyZWZzLnRyYWlsaW5nSWNvbi5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgZXZ0VHlwZSxcbiAgICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgICBhcHBseVBhc3NpdmUoKVxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJUcmFpbGluZ0ljb25JbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLiRyZWZzLnRyYWlsaW5nSWNvbikge1xuICAgICAgICAgIHRoaXMuJHJlZnMudHJhaWxpbmdJY29uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICBldnRUeXBlLFxuICAgICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICAgIGFwcGx5UGFzc2l2ZSgpXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbm90aWZ5UmVtb3ZhbDogKCkgPT4ge1xuICAgICAgICBlbWl0Q3VzdG9tRXZlbnQoXG4gICAgICAgICAgdGhpcy4kZWwsXG4gICAgICAgICAgTURDQ2hpcEZvdW5kYXRpb24uc3RyaW5ncy5SRU1PVkFMX0VWRU5ULFxuICAgICAgICAgIHsgY2hpcDogdGhpcyB9LFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIGdldENvbXB1dGVkU3R5bGVWYWx1ZTogcHJvcGVydHlOYW1lID0+XG4gICAgICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuJGVsKS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5TmFtZSksXG4gICAgICBzZXRTdHlsZVByb3BlcnR5OiAocHJvcGVydHksIHZhbHVlKSA9PlxuICAgICAgICB0aGlzLiRzZXQodGhpcy5zdHlsZXMsIHByb3BlcnR5LCB2YWx1ZSlcbiAgICB9KVxuXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuXG4gICAgdGhpcy5yaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzKVxuICAgIHRoaXMucmlwcGxlLmluaXQoKVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMucmlwcGxlLmRlc3Ryb3koKVxuICAgIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIHRvZ2dsZVNlbGVjdGVkKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnRvZ2dsZVNlbGVjdGVkKClcbiAgICB9LFxuICAgIGlzU2VsZWN0ZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5mb3VuZGF0aW9uLmlzU2VsZWN0ZWQoKVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5pbXBvcnQge01EQ0NoaXBJbnRlcmFjdGlvbkV2ZW50VHlwZX0gZnJvbSAnLi4vY2hpcC9mb3VuZGF0aW9uJztcblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIENoaXAgU2V0LlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIENoaXAgU2V0IGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENDaGlwU2V0QWRhcHRlciB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJvb3QgZWxlbWVudCBjb250YWlucyB0aGUgZ2l2ZW4gY2xhc3MgbmFtZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgcm9vdCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFNRENDaGlwSW50ZXJhY3Rpb25FdmVudFR5cGUpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgb24gdGhlIHJvb3QgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighTURDQ2hpcEludGVyYWN0aW9uRXZlbnRUeXBlKTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGNoaXAgb2JqZWN0IGZyb20gdGhlIGNoaXAgc2V0LlxuICAgKiBAcGFyYW0geyFPYmplY3R9IGNoaXBcbiAgICovXG4gIHJlbW92ZUNoaXAoY2hpcCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDQ2hpcFNldEFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBDSElQX1NFTEVDVE9SOiAnLm1kYy1jaGlwJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgQ0hPSUNFOiAnbWRjLWNoaXAtc2V0LS1jaG9pY2UnLFxuICBGSUxURVI6ICdtZGMtY2hpcC1zZXQtLWZpbHRlcicsXG59O1xuXG5leHBvcnQge3N0cmluZ3MsIGNzc0NsYXNzZXN9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ0NoaXBTZXRBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCB7TURDQ2hpcEZvdW5kYXRpb24sIE1EQ0NoaXBJbnRlcmFjdGlvbkV2ZW50VHlwZX0gZnJvbSAnLi4vY2hpcC9mb3VuZGF0aW9uJztcbmltcG9ydCB7c3RyaW5ncywgY3NzQ2xhc3Nlc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENDaGlwU2V0QWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDQ2hpcFNldEZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBNRENDaGlwU2V0QWRhcHRlcn0gZm9yIHR5cGluZyBpbmZvcm1hdGlvbiBvbiBwYXJhbWV0ZXJzIGFuZCByZXR1cm5cbiAgICogdHlwZXMuXG4gICAqIEByZXR1cm4geyFNRENDaGlwU2V0QWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ0NoaXBTZXRBZGFwdGVyfSAqLyAoe1xuICAgICAgaGFzQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICByZW1vdmVDaGlwOiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENDaGlwU2V0QWRhcHRlcn0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDQ2hpcFNldEZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzZWxlY3RlZCBjaGlwcyBpbiB0aGUgc2V0LiBPbmx5IHVzZWQgZm9yIGNob2ljZSBjaGlwIHNldCBvciBmaWx0ZXIgY2hpcCBzZXQuXG4gICAgICogQHByaXZhdGUgeyFBcnJheTwhTURDQ2hpcEZvdW5kYXRpb24+fVxuICAgICAqL1xuICAgIHRoaXMuc2VsZWN0ZWRDaGlwc18gPSBbXTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIU1EQ0NoaXBJbnRlcmFjdGlvbkV2ZW50VHlwZSk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLmNoaXBJbnRlcmFjdGlvbkhhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVDaGlwSW50ZXJhY3Rpb25fKGV2dCk7XG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighTURDQ2hpcEludGVyYWN0aW9uRXZlbnRUeXBlKTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMuY2hpcFJlbW92YWxIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlQ2hpcFJlbW92YWxfKGV2dCk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoXG4gICAgICBNRENDaGlwRm91bmRhdGlvbi5zdHJpbmdzLklOVEVSQUNUSU9OX0VWRU5ULCB0aGlzLmNoaXBJbnRlcmFjdGlvbkhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKFxuICAgICAgTURDQ2hpcEZvdW5kYXRpb24uc3RyaW5ncy5SRU1PVkFMX0VWRU5ULCB0aGlzLmNoaXBSZW1vdmFsSGFuZGxlcl8pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoXG4gICAgICBNRENDaGlwRm91bmRhdGlvbi5zdHJpbmdzLklOVEVSQUNUSU9OX0VWRU5ULCB0aGlzLmNoaXBJbnRlcmFjdGlvbkhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoXG4gICAgICBNRENDaGlwRm91bmRhdGlvbi5zdHJpbmdzLlJFTU9WQUxfRVZFTlQsIHRoaXMuY2hpcFJlbW92YWxIYW5kbGVyXyk7XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0cyB0aGUgZ2l2ZW4gY2hpcC4gRGVzZWxlY3RzIGFsbCBvdGhlciBjaGlwcyBpZiB0aGUgY2hpcCBzZXQgaXMgb2YgdGhlIGNob2ljZSB2YXJpYW50LlxuICAgKiBAcGFyYW0geyFNRENDaGlwRm91bmRhdGlvbn0gY2hpcEZvdW5kYXRpb25cbiAgICovXG4gIHNlbGVjdChjaGlwRm91bmRhdGlvbikge1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuQ0hPSUNFKSkge1xuICAgICAgdGhpcy5kZXNlbGVjdEFsbF8oKTtcbiAgICB9XG4gICAgY2hpcEZvdW5kYXRpb24uc2V0U2VsZWN0ZWQodHJ1ZSk7XG4gICAgdGhpcy5zZWxlY3RlZENoaXBzXy5wdXNoKGNoaXBGb3VuZGF0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlbGVjdHMgdGhlIGdpdmVuIGNoaXAuXG4gICAqIEBwYXJhbSB7IU1EQ0NoaXBGb3VuZGF0aW9ufSBjaGlwRm91bmRhdGlvblxuICAgKi9cbiAgZGVzZWxlY3QoY2hpcEZvdW5kYXRpb24pIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuc2VsZWN0ZWRDaGlwc18uaW5kZXhPZihjaGlwRm91bmRhdGlvbik7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWRDaGlwc18uc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgY2hpcEZvdW5kYXRpb24uc2V0U2VsZWN0ZWQoZmFsc2UpO1xuICB9XG5cbiAgLyoqIERlc2VsZWN0cyBhbGwgc2VsZWN0ZWQgY2hpcHMuICovXG4gIGRlc2VsZWN0QWxsXygpIHtcbiAgICB0aGlzLnNlbGVjdGVkQ2hpcHNfLmZvckVhY2goKGNoaXBGb3VuZGF0aW9uKSA9PiB7XG4gICAgICBjaGlwRm91bmRhdGlvbi5zZXRTZWxlY3RlZChmYWxzZSk7XG4gICAgfSk7XG4gICAgdGhpcy5zZWxlY3RlZENoaXBzXy5sZW5ndGggPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBjaGlwIGludGVyYWN0aW9uIGV2ZW50XG4gICAqIEBwYXJhbSB7IU1EQ0NoaXBJbnRlcmFjdGlvbkV2ZW50VHlwZX0gZXZ0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVDaGlwSW50ZXJhY3Rpb25fKGV2dCkge1xuICAgIGNvbnN0IGNoaXBGb3VuZGF0aW9uID0gZXZ0LmRldGFpbC5jaGlwLmZvdW5kYXRpb247XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5DSE9JQ0UpIHx8IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5GSUxURVIpKSB7XG4gICAgICBpZiAoY2hpcEZvdW5kYXRpb24uaXNTZWxlY3RlZCgpKSB7XG4gICAgICAgIHRoaXMuZGVzZWxlY3QoY2hpcEZvdW5kYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZWxlY3QoY2hpcEZvdW5kYXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBldmVudCB3aGVuIGEgY2hpcCBpcyByZW1vdmVkLlxuICAgKiBAcGFyYW0geyFNRENDaGlwSW50ZXJhY3Rpb25FdmVudFR5cGV9IGV2dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlQ2hpcFJlbW92YWxfKGV2dCkge1xuICAgIGNvbnN0IHtjaGlwfSA9IGV2dC5kZXRhaWw7XG4gICAgdGhpcy5kZXNlbGVjdChjaGlwLmZvdW5kYXRpb24pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2hpcChjaGlwKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENDaGlwU2V0Rm91bmRhdGlvbjtcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdlxuICAgIDpjbGFzcz1cImNsYXNzZXNcIlxuICAgIHYtb249XCIkbGlzdGVuZXJzXCI+XG4gICAgPHNsb3QvPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDQ2hpcFNldEZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2NoaXBzL2NoaXAtc2V0L2ZvdW5kYXRpb24nXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtY2hpcC1zZXQnLFxuICBwcm9wczoge1xuICAgIGNob2ljZTogW0Jvb2xlYW5dLFxuICAgIGZpbHRlcjogW0Jvb2xlYW5dLFxuICAgIGlucHV0OiBbQm9vbGVhbl1cbiAgfSxcbiAgcHJvdmlkZSgpIHtcbiAgICByZXR1cm4geyBtZGNDaGlwU2V0OiB0aGlzIH1cbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge1xuICAgICAgICAnbWRjLWNoaXAtc2V0JzogdHJ1ZSxcbiAgICAgICAgJ21kYy1jaGlwLXNldC0tY2hvaWNlJzogdGhpcy5jaG9pY2UsXG4gICAgICAgICdtZGMtY2hpcC1zZXQtLWZpbHRlcic6IHRoaXMuZmlsdGVyLFxuICAgICAgICAnbWRjLWNoaXAtc2V0LS1pbnB1dCc6IHRoaXMuaW5wdXRcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ0NoaXBTZXRGb3VuZGF0aW9uKHtcbiAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSksXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICByZW1vdmVDaGlwOiBjaGlwID0+IHtcbiAgICAgICAgLy8gVE9ETzogbWF5IG5lZWQgcmVmYWN0b3JpbmdcbiAgICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4gY2hpcC4kZGVzdHJveSgpKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9LFxuICBtZXRob2RzOiB7fVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNDaGlwIGZyb20gJy4vbWRjLWNoaXAudnVlJ1xuaW1wb3J0IG1kY0NoaXBTZXQgZnJvbSAnLi9tZGMtY2hpcC1zZXQudnVlJ1xuXG5leHBvcnQgeyBtZGNDaGlwLCBtZGNDaGlwU2V0IH1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY0NoaXAsXG4gIG1kY0NoaXBTZXRcbn0pXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnLi9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENDb21wb25lbnQgZnJvbSAnLi9jb21wb25lbnQnO1xuXG5leHBvcnQge01EQ0ZvdW5kYXRpb24sIE1EQ0NvbXBvbmVudH07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgUk9PVDogJ21kYy1kaWFsb2cnLFxuICBPUEVOOiAnbWRjLWRpYWxvZy0tb3BlbicsXG4gIEFOSU1BVElORzogJ21kYy1kaWFsb2ctLWFuaW1hdGluZycsXG4gIEJBQ0tEUk9QOiAnbWRjLWRpYWxvZ19fYmFja2Ryb3AnLFxuICBTQ1JPTExfTE9DSzogJ21kYy1kaWFsb2ctc2Nyb2xsLWxvY2snLFxuICBBQ0NFUFRfQlROOiAnbWRjLWRpYWxvZ19fZm9vdGVyX19idXR0b24tLWFjY2VwdCcsXG4gIENBTkNFTF9CVE46ICdtZGMtZGlhbG9nX19mb290ZXJfX2J1dHRvbi0tY2FuY2VsJyxcbn07XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBPUEVOX0RJQUxPR19TRUxFQ1RPUjogJy5tZGMtZGlhbG9nLS1vcGVuJyxcbiAgRElBTE9HX1NVUkZBQ0VfU0VMRUNUT1I6ICcubWRjLWRpYWxvZ19fc3VyZmFjZScsXG4gIEFDQ0VQVF9TRUxFQ1RPUjogJy5tZGMtZGlhbG9nX19mb290ZXJfX2J1dHRvbi0tYWNjZXB0JyxcbiAgQUNDRVBUX0VWRU5UOiAnTURDRGlhbG9nOmFjY2VwdCcsXG4gIENBTkNFTF9FVkVOVDogJ01EQ0RpYWxvZzpjYW5jZWwnLFxufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7TURDRm91bmRhdGlvbn0gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvaW5kZXgnO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1EQ0RpYWxvZ0ZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWRkQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGFkZEJvZHlDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUJvZHlDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGV2ZW50VGFyZ2V0SGFzQ2xhc3M6ICgvKiB0YXJnZXQ6IEV2ZW50VGFyZ2V0LCBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4gLyogYm9vbGVhbiAqLyBmYWxzZSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0OiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dDogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyU3VyZmFjZUludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dDogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJTdXJmYWNlSW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0OiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBub3RpZnlBY2NlcHQ6ICgpID0+IHt9LFxuICAgICAgbm90aWZ5Q2FuY2VsOiAoKSA9PiB7fSxcbiAgICAgIHRyYXBGb2N1c09uU3VyZmFjZTogKCkgPT4ge30sXG4gICAgICB1bnRyYXBGb2N1c09uU3VyZmFjZTogKCkgPT4ge30sXG4gICAgICBpc0RpYWxvZzogKC8qIGVsOiBFbGVtZW50ICovKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENEaWFsb2dGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG4gICAgdGhpcy5pc09wZW5fID0gZmFsc2U7XG4gICAgdGhpcy5jb21wb25lbnRDbGlja0hhbmRsZXJfID0gKGV2dCkgPT4ge1xuICAgICAgaWYgKHRoaXMuYWRhcHRlcl8uZXZlbnRUYXJnZXRIYXNDbGFzcyhldnQudGFyZ2V0LCBjc3NDbGFzc2VzLkJBQ0tEUk9QKSkge1xuICAgICAgICB0aGlzLmNhbmNlbCh0cnVlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuZGlhbG9nQ2xpY2tIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlRGlhbG9nQ2xpY2tfKGV2dCk7XG4gICAgdGhpcy5kb2N1bWVudEtleWRvd25IYW5kbGVyXyA9IChldnQpID0+IHtcbiAgICAgIGlmIChldnQua2V5ICYmIGV2dC5rZXkgPT09ICdFc2NhcGUnIHx8IGV2dC5rZXlDb2RlID09PSAyNykge1xuICAgICAgICB0aGlzLmNhbmNlbCh0cnVlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVUcmFuc2l0aW9uRW5kXyhldnQpO1xuICB9O1xuXG4gIGRlc3Ryb3koKSB7XG4gICAgLy8gRW5zdXJlIHRoYXQgZGlhbG9nIGlzIGNsZWFuZWQgdXAgd2hlbiBkZXN0cm95ZWRcbiAgICBpZiAodGhpcy5pc09wZW5fKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJTdXJmYWNlSW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuZGlhbG9nQ2xpY2tIYW5kbGVyXyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyKHRoaXMuZG9jdW1lbnRLZXlkb3duSGFuZGxlcl8pO1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY29tcG9uZW50Q2xpY2tIYW5kbGVyXyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnVudHJhcEZvY3VzT25TdXJmYWNlKCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcih0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkcpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENEaWFsb2dGb3VuZGF0aW9uLmNzc0NsYXNzZXMuT1BFTik7XG4gICAgICB0aGlzLmVuYWJsZVNjcm9sbF8oKTtcbiAgICB9XG4gIH1cblxuICBvcGVuKCkge1xuICAgIHRoaXMuaXNPcGVuXyA9IHRydWU7XG4gICAgdGhpcy5kaXNhYmxlU2Nyb2xsXygpO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyKHRoaXMuZG9jdW1lbnRLZXlkb3duSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJTdXJmYWNlSW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuZGlhbG9nQ2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmNvbXBvbmVudENsaWNrSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcih0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENEaWFsb2dGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQU5JTUFUSU5HKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ0RpYWxvZ0ZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5PUEVOKTtcbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIHRoaXMuaXNPcGVuXyA9IGZhbHNlO1xuICAgIHRoaXMuZW5hYmxlU2Nyb2xsXygpO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclN1cmZhY2VJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5kaWFsb2dDbGlja0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyKHRoaXMuZG9jdW1lbnRLZXlkb3duSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmNvbXBvbmVudENsaWNrSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8udW50cmFwRm9jdXNPblN1cmZhY2UoKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXIodGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDRGlhbG9nRm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOSU1BVElORyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENEaWFsb2dGb3VuZGF0aW9uLmNzc0NsYXNzZXMuT1BFTik7XG4gIH1cblxuICBpc09wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNPcGVuXztcbiAgfVxuXG4gIGFjY2VwdChzaG91bGROb3RpZnkpIHtcbiAgICBpZiAoc2hvdWxkTm90aWZ5KSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUFjY2VwdCgpO1xuICAgIH1cblxuICAgIHRoaXMuY2xvc2UoKTtcbiAgfVxuXG4gIGNhbmNlbChzaG91bGROb3RpZnkpIHtcbiAgICBpZiAoc2hvdWxkTm90aWZ5KSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUNhbmNlbCgpO1xuICAgIH1cblxuICAgIHRoaXMuY2xvc2UoKTtcbiAgfVxuXG4gIGhhbmRsZURpYWxvZ0NsaWNrXyhldnQpIHtcbiAgICBjb25zdCB7dGFyZ2V0fSA9IGV2dDtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5ldmVudFRhcmdldEhhc0NsYXNzKHRhcmdldCwgY3NzQ2xhc3Nlcy5BQ0NFUFRfQlROKSkge1xuICAgICAgdGhpcy5hY2NlcHQodHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmFkYXB0ZXJfLmV2ZW50VGFyZ2V0SGFzQ2xhc3ModGFyZ2V0LCBjc3NDbGFzc2VzLkNBTkNFTF9CVE4pKSB7XG4gICAgICB0aGlzLmNhbmNlbCh0cnVlKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVUcmFuc2l0aW9uRW5kXyhldnQpIHtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc0RpYWxvZyhldnQudGFyZ2V0KSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXIodGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcl8pO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENEaWFsb2dGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQU5JTUFUSU5HKTtcbiAgICAgIGlmICh0aGlzLmlzT3Blbl8pIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy50cmFwRm9jdXNPblN1cmZhY2UoKTtcbiAgICAgIH07XG4gICAgfTtcbiAgfTtcblxuICBkaXNhYmxlU2Nyb2xsXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZEJvZHlDbGFzcyhjc3NDbGFzc2VzLlNDUk9MTF9MT0NLKTtcbiAgfVxuXG4gIGVuYWJsZVNjcm9sbF8oKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVCb2R5Q2xhc3MoY3NzQ2xhc3Nlcy5TQ1JPTExfTE9DSyk7XG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIGVsZW1lbnREb2N1bWVudCA9IGVsLm93bmVyRG9jdW1lbnQgfHwgZWw7XG4gIHZhciBiYXNpY1RhYmJhYmxlcyA9IFtdO1xuICB2YXIgb3JkZXJlZFRhYmJhYmxlcyA9IFtdO1xuXG4gIC8vIEEgbm9kZSBpcyBcImF2YWlsYWJsZVwiIGlmXG4gIC8vIC0gaXQncyBjb21wdXRlZCBzdHlsZVxuICB2YXIgaXNVbmF2YWlsYWJsZSA9IGNyZWF0ZUlzVW5hdmFpbGFibGUoZWxlbWVudERvY3VtZW50KTtcblxuICB2YXIgY2FuZGlkYXRlU2VsZWN0b3JzID0gW1xuICAgICdpbnB1dCcsXG4gICAgJ3NlbGVjdCcsXG4gICAgJ2FbaHJlZl0nLFxuICAgICd0ZXh0YXJlYScsXG4gICAgJ2J1dHRvbicsXG4gICAgJ1t0YWJpbmRleF0nLFxuICBdO1xuXG4gIHZhciBjYW5kaWRhdGVzID0gZWwucXVlcnlTZWxlY3RvckFsbChjYW5kaWRhdGVTZWxlY3RvcnMuam9pbignLCcpKTtcblxuICBpZiAob3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyKSB7XG4gICAgdmFyIG1hdGNoZXMgPSBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvcjtcblxuICAgIGlmIChcbiAgICAgIGNhbmRpZGF0ZVNlbGVjdG9ycy5zb21lKGZ1bmN0aW9uKGNhbmRpZGF0ZVNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzLmNhbGwoZWwsIGNhbmRpZGF0ZVNlbGVjdG9yKTtcbiAgICAgIH0pXG4gICAgKSB7XG4gICAgICBjYW5kaWRhdGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGNhbmRpZGF0ZXMpO1xuICAgICAgY2FuZGlkYXRlcy51bnNoaWZ0KGVsKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY2FuZGlkYXRlLCBjYW5kaWRhdGVJbmRleEF0dHIsIGNhbmRpZGF0ZUluZGV4O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGNhbmRpZGF0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY2FuZGlkYXRlID0gY2FuZGlkYXRlc1tpXTtcbiAgICBjYW5kaWRhdGVJbmRleEF0dHIgPSBwYXJzZUludChjYW5kaWRhdGUuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpLCAxMClcbiAgICBjYW5kaWRhdGVJbmRleCA9IGlzTmFOKGNhbmRpZGF0ZUluZGV4QXR0cikgPyBjYW5kaWRhdGUudGFiSW5kZXggOiBjYW5kaWRhdGVJbmRleEF0dHI7XG5cbiAgICBpZiAoXG4gICAgICBjYW5kaWRhdGVJbmRleCA8IDBcbiAgICAgIHx8IChjYW5kaWRhdGUudGFnTmFtZSA9PT0gJ0lOUFVUJyAmJiBjYW5kaWRhdGUudHlwZSA9PT0gJ2hpZGRlbicpXG4gICAgICB8fCBjYW5kaWRhdGUuZGlzYWJsZWRcbiAgICAgIHx8IGlzVW5hdmFpbGFibGUoY2FuZGlkYXRlLCBlbGVtZW50RG9jdW1lbnQpXG4gICAgKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoY2FuZGlkYXRlSW5kZXggPT09IDApIHtcbiAgICAgIGJhc2ljVGFiYmFibGVzLnB1c2goY2FuZGlkYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3JkZXJlZFRhYmJhYmxlcy5wdXNoKHtcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIHRhYkluZGV4OiBjYW5kaWRhdGVJbmRleCxcbiAgICAgICAgbm9kZTogY2FuZGlkYXRlLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRhYmJhYmxlTm9kZXMgPSBvcmRlcmVkVGFiYmFibGVzXG4gICAgLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgcmV0dXJuIGEudGFiSW5kZXggPT09IGIudGFiSW5kZXggPyBhLmluZGV4IC0gYi5pbmRleCA6IGEudGFiSW5kZXggLSBiLnRhYkluZGV4O1xuICAgIH0pXG4gICAgLm1hcChmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gYS5ub2RlXG4gICAgfSk7XG5cbiAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkodGFiYmFibGVOb2RlcywgYmFzaWNUYWJiYWJsZXMpO1xuXG4gIHJldHVybiB0YWJiYWJsZU5vZGVzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJc1VuYXZhaWxhYmxlKGVsZW1lbnREb2N1bWVudCkge1xuICAvLyBOb2RlIGNhY2hlIG11c3QgYmUgcmVmcmVzaGVkIG9uIGV2ZXJ5IGNoZWNrLCBpbiBjYXNlXG4gIC8vIHRoZSBjb250ZW50IG9mIHRoZSBlbGVtZW50IGhhcyBjaGFuZ2VkXG4gIHZhciBpc09mZkNhY2hlID0gW107XG5cbiAgLy8gXCJvZmZcIiBtZWFucyBgZGlzcGxheTogbm9uZTtgLCBhcyBvcHBvc2VkIHRvIFwiaGlkZGVuXCIsXG4gIC8vIHdoaWNoIG1lYW5zIGB2aXNpYmlsaXR5OiBoaWRkZW47YC4gZ2V0Q29tcHV0ZWRTdHlsZVxuICAvLyBhY2N1cmF0ZWx5IHJlZmxlY3RzIHZpc2libGl0eSBpbiBjb250ZXh0IGJ1dCBub3RcbiAgLy8gXCJvZmZcIiBzdGF0ZSwgc28gd2UgbmVlZCB0byByZWN1cnNpdmVseSBjaGVjayBwYXJlbnRzLlxuXG4gIGZ1bmN0aW9uIGlzT2ZmKG5vZGUsIG5vZGVDb21wdXRlZFN0eWxlKSB7XG4gICAgaWYgKG5vZGUgPT09IGVsZW1lbnREb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIEZpbmQgdGhlIGNhY2hlZCBub2RlIChBcnJheS5wcm90b3R5cGUuZmluZCBub3QgYXZhaWxhYmxlIGluIElFOSlcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gaXNPZmZDYWNoZS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGlzT2ZmQ2FjaGVbaV1bMF0gPT09IG5vZGUpIHJldHVybiBpc09mZkNhY2hlW2ldWzFdO1xuICAgIH1cblxuICAgIG5vZGVDb21wdXRlZFN0eWxlID0gbm9kZUNvbXB1dGVkU3R5bGUgfHwgZWxlbWVudERvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cbiAgICB2YXIgcmVzdWx0ID0gZmFsc2U7XG5cbiAgICBpZiAobm9kZUNvbXB1dGVkU3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICByZXN1bHQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICByZXN1bHQgPSBpc09mZihub2RlLnBhcmVudE5vZGUpO1xuICAgIH1cblxuICAgIGlzT2ZmQ2FjaGUucHVzaChbbm9kZSwgcmVzdWx0XSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGlzVW5hdmFpbGFibGUobm9kZSkge1xuICAgIGlmIChub2RlID09PSBlbGVtZW50RG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IGVsZW1lbnREb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXG4gICAgaWYgKGlzT2ZmKG5vZGUsIGNvbXB1dGVkU3R5bGUpKSByZXR1cm4gdHJ1ZTtcblxuICAgIHJldHVybiBjb21wdXRlZFN0eWxlLnZpc2liaWxpdHkgPT09ICdoaWRkZW4nO1xuICB9XG59XG4iLCJ2YXIgdGFiYmFibGUgPSByZXF1aXJlKCd0YWJiYWJsZScpO1xuXG52YXIgbGlzdGVuaW5nRm9jdXNUcmFwID0gbnVsbDtcblxuZnVuY3Rpb24gZm9jdXNUcmFwKGVsZW1lbnQsIHVzZXJPcHRpb25zKSB7XG4gIHZhciB0YWJiYWJsZU5vZGVzID0gW107XG4gIHZhciBmaXJzdFRhYmJhYmxlTm9kZSA9IG51bGw7XG4gIHZhciBsYXN0VGFiYmFibGVOb2RlID0gbnVsbDtcbiAgdmFyIG5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbiA9IG51bGw7XG4gIHZhciBhY3RpdmUgPSBmYWxzZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuICB2YXIgdGFiRXZlbnQgPSBudWxsO1xuXG4gIHZhciBjb250YWluZXIgPSAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnKVxuICAgID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbGVtZW50KVxuICAgIDogZWxlbWVudDtcblxuICB2YXIgY29uZmlnID0gdXNlck9wdGlvbnMgfHwge307XG4gIGNvbmZpZy5yZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZSA9ICh1c2VyT3B0aW9ucyAmJiB1c2VyT3B0aW9ucy5yZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZSAhPT0gdW5kZWZpbmVkKVxuICAgID8gdXNlck9wdGlvbnMucmV0dXJuRm9jdXNPbkRlYWN0aXZhdGVcbiAgICA6IHRydWU7XG4gIGNvbmZpZy5lc2NhcGVEZWFjdGl2YXRlcyA9ICh1c2VyT3B0aW9ucyAmJiB1c2VyT3B0aW9ucy5lc2NhcGVEZWFjdGl2YXRlcyAhPT0gdW5kZWZpbmVkKVxuICAgID8gdXNlck9wdGlvbnMuZXNjYXBlRGVhY3RpdmF0ZXNcbiAgICA6IHRydWU7XG5cbiAgdmFyIHRyYXAgPSB7XG4gICAgYWN0aXZhdGU6IGFjdGl2YXRlLFxuICAgIGRlYWN0aXZhdGU6IGRlYWN0aXZhdGUsXG4gICAgcGF1c2U6IHBhdXNlLFxuICAgIHVucGF1c2U6IHVucGF1c2UsXG4gIH07XG5cbiAgcmV0dXJuIHRyYXA7XG5cbiAgZnVuY3Rpb24gYWN0aXZhdGUoYWN0aXZhdGVPcHRpb25zKSB7XG4gICAgaWYgKGFjdGl2ZSkgcmV0dXJuO1xuXG4gICAgdmFyIGRlZmF1bHRlZEFjdGl2YXRlT3B0aW9ucyA9IHtcbiAgICAgIG9uQWN0aXZhdGU6IChhY3RpdmF0ZU9wdGlvbnMgJiYgYWN0aXZhdGVPcHRpb25zLm9uQWN0aXZhdGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgPyBhY3RpdmF0ZU9wdGlvbnMub25BY3RpdmF0ZVxuICAgICAgICA6IGNvbmZpZy5vbkFjdGl2YXRlLFxuICAgIH07XG5cbiAgICBhY3RpdmUgPSB0cnVlO1xuICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgIG5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbiA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgICBpZiAoZGVmYXVsdGVkQWN0aXZhdGVPcHRpb25zLm9uQWN0aXZhdGUpIHtcbiAgICAgIGRlZmF1bHRlZEFjdGl2YXRlT3B0aW9ucy5vbkFjdGl2YXRlKCk7XG4gICAgfVxuXG4gICAgYWRkTGlzdGVuZXJzKCk7XG4gICAgcmV0dXJuIHRyYXA7XG4gIH1cblxuICBmdW5jdGlvbiBkZWFjdGl2YXRlKGRlYWN0aXZhdGVPcHRpb25zKSB7XG4gICAgaWYgKCFhY3RpdmUpIHJldHVybjtcblxuICAgIHZhciBkZWZhdWx0ZWREZWFjdGl2YXRlT3B0aW9ucyA9IHtcbiAgICAgIHJldHVybkZvY3VzOiAoZGVhY3RpdmF0ZU9wdGlvbnMgJiYgZGVhY3RpdmF0ZU9wdGlvbnMucmV0dXJuRm9jdXMgIT09IHVuZGVmaW5lZClcbiAgICAgICAgPyBkZWFjdGl2YXRlT3B0aW9ucy5yZXR1cm5Gb2N1c1xuICAgICAgICA6IGNvbmZpZy5yZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZSxcbiAgICAgIG9uRGVhY3RpdmF0ZTogKGRlYWN0aXZhdGVPcHRpb25zICYmIGRlYWN0aXZhdGVPcHRpb25zLm9uRGVhY3RpdmF0ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICA/IGRlYWN0aXZhdGVPcHRpb25zLm9uRGVhY3RpdmF0ZVxuICAgICAgICA6IGNvbmZpZy5vbkRlYWN0aXZhdGUsXG4gICAgfTtcblxuICAgIHJlbW92ZUxpc3RlbmVycygpO1xuXG4gICAgaWYgKGRlZmF1bHRlZERlYWN0aXZhdGVPcHRpb25zLm9uRGVhY3RpdmF0ZSkge1xuICAgICAgZGVmYXVsdGVkRGVhY3RpdmF0ZU9wdGlvbnMub25EZWFjdGl2YXRlKCk7XG4gICAgfVxuXG4gICAgaWYgKGRlZmF1bHRlZERlYWN0aXZhdGVPcHRpb25zLnJldHVybkZvY3VzKSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdHJ5Rm9jdXMobm9kZUZvY3VzZWRCZWZvcmVBY3RpdmF0aW9uKTtcbiAgICAgIH0sIDApO1xuICAgIH1cblxuICAgIGFjdGl2ZSA9IGZhbHNlO1xuICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZnVuY3Rpb24gcGF1c2UoKSB7XG4gICAgaWYgKHBhdXNlZCB8fCAhYWN0aXZlKSByZXR1cm47XG4gICAgcGF1c2VkID0gdHJ1ZTtcbiAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVucGF1c2UoKSB7XG4gICAgaWYgKCFwYXVzZWQgfHwgIWFjdGl2ZSkgcmV0dXJuO1xuICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgIGFkZExpc3RlbmVycygpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkTGlzdGVuZXJzKCkge1xuICAgIGlmICghYWN0aXZlKSByZXR1cm47XG5cbiAgICAvLyBUaGVyZSBjYW4gYmUgb25seSBvbmUgbGlzdGVuaW5nIGZvY3VzIHRyYXAgYXQgYSB0aW1lXG4gICAgaWYgKGxpc3RlbmluZ0ZvY3VzVHJhcCkge1xuICAgICAgbGlzdGVuaW5nRm9jdXNUcmFwLnBhdXNlKCk7XG4gICAgfVxuICAgIGxpc3RlbmluZ0ZvY3VzVHJhcCA9IHRyYXA7XG5cbiAgICB1cGRhdGVUYWJiYWJsZU5vZGVzKCk7XG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlIGZvY3VzZWQgZWxlbWVudCBkb2Vzbid0IGNhcHR1cmUgdGhlIGV2ZW50IHRoYXQgY2F1c2VkIHRoZSBmb2N1cyB0cmFwIGFjdGl2YXRpb25cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeUZvY3VzKGZpcnN0Rm9jdXNOb2RlKCkpO1xuICAgIH0sIDApO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgY2hlY2tGb2N1cywgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjaGVja0NsaWNrLCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBjaGVja1BvaW50ZXJEb3duLCB0cnVlKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgY2hlY2tQb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGNoZWNrS2V5LCB0cnVlKTtcblxuICAgIHJldHVybiB0cmFwO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKCkge1xuICAgIGlmICghYWN0aXZlIHx8IGxpc3RlbmluZ0ZvY3VzVHJhcCAhPT0gdHJhcCkgcmV0dXJuO1xuXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBjaGVja0ZvY3VzLCB0cnVlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGNoZWNrQ2xpY2ssIHRydWUpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGNoZWNrUG9pbnRlckRvd24sIHRydWUpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBjaGVja1BvaW50ZXJEb3duLCB0cnVlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgY2hlY2tLZXksIHRydWUpO1xuXG4gICAgbGlzdGVuaW5nRm9jdXNUcmFwID0gbnVsbDtcblxuICAgIHJldHVybiB0cmFwO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Tm9kZUZvck9wdGlvbihvcHRpb25OYW1lKSB7XG4gICAgdmFyIG9wdGlvblZhbHVlID0gY29uZmlnW29wdGlvbk5hbWVdO1xuICAgIHZhciBub2RlID0gb3B0aW9uVmFsdWU7XG4gICAgaWYgKCFvcHRpb25WYWx1ZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9uVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBub2RlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihvcHRpb25WYWx1ZSk7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgJyArIG9wdGlvbk5hbWUgKyAnYCByZWZlcnMgdG8gbm8ga25vd24gbm9kZScpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvblZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBub2RlID0gb3B0aW9uVmFsdWUoKTtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2AnICsgb3B0aW9uTmFtZSArICdgIGRpZCBub3QgcmV0dXJuIGEgbm9kZScpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpcnN0Rm9jdXNOb2RlKCkge1xuICAgIHZhciBub2RlO1xuICAgIGlmIChnZXROb2RlRm9yT3B0aW9uKCdpbml0aWFsRm9jdXMnKSAhPT0gbnVsbCkge1xuICAgICAgbm9kZSA9IGdldE5vZGVGb3JPcHRpb24oJ2luaXRpYWxGb2N1cycpO1xuICAgIH0gZWxzZSBpZiAoY29udGFpbmVyLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICBub2RlID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IHRhYmJhYmxlTm9kZXNbMF0gfHwgZ2V0Tm9kZUZvck9wdGlvbignZmFsbGJhY2tGb2N1cycpO1xuICAgIH1cblxuICAgIGlmICghbm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2FuXFwndCBoYXZlIGEgZm9jdXMtdHJhcCB3aXRob3V0IGF0IGxlYXN0IG9uZSBmb2N1c2FibGUgZWxlbWVudCcpO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgLy8gVGhpcyBuZWVkcyB0byBiZSBkb25lIG9uIG1vdXNlZG93biBhbmQgdG91Y2hzdGFydCBpbnN0ZWFkIG9mIGNsaWNrXG4gIC8vIHNvIHRoYXQgaXQgcHJlY2VkZXMgdGhlIGZvY3VzIGV2ZW50XG4gIGZ1bmN0aW9uIGNoZWNrUG9pbnRlckRvd24oZSkge1xuICAgIGlmIChjb25maWcuY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXMgJiYgIWNvbnRhaW5lci5jb250YWlucyhlLnRhcmdldCkpIHtcbiAgICAgIGRlYWN0aXZhdGUoeyByZXR1cm5Gb2N1czogZmFsc2UgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tDbGljayhlKSB7XG4gICAgaWYgKGNvbmZpZy5jbGlja091dHNpZGVEZWFjdGl2YXRlcykgcmV0dXJuO1xuICAgIGlmIChjb250YWluZXIuY29udGFpbnMoZS50YXJnZXQpKSByZXR1cm47XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0ZvY3VzKGUpIHtcbiAgICBpZiAoY29udGFpbmVyLmNvbnRhaW5zKGUudGFyZ2V0KSkgcmV0dXJuO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIC8vIENoZWNraW5nIGZvciBhIGJsdXIgbWV0aG9kIGhlcmUgcmVzb2x2ZXMgYSBGaXJlZm94IGlzc3VlICgjMTUpXG4gICAgaWYgKHR5cGVvZiBlLnRhcmdldC5ibHVyID09PSAnZnVuY3Rpb24nKSBlLnRhcmdldC5ibHVyKCk7XG5cbiAgICBpZiAodGFiRXZlbnQpIHtcbiAgICAgIHJlYWRqdXN0Rm9jdXModGFiRXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrS2V5KGUpIHtcbiAgICBpZiAoZS5rZXkgPT09ICdUYWInIHx8IGUua2V5Q29kZSA9PT0gOSkge1xuICAgICAgaGFuZGxlVGFiKGUpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuZXNjYXBlRGVhY3RpdmF0ZXMgIT09IGZhbHNlICYmIGlzRXNjYXBlRXZlbnQoZSkpIHtcbiAgICAgIGRlYWN0aXZhdGUoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVUYWIoZSkge1xuICAgIHVwZGF0ZVRhYmJhYmxlTm9kZXMoKTtcblxuICAgIGlmIChlLnRhcmdldC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykgJiYgTnVtYmVyKGUudGFyZ2V0LmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSkgPCAwKSB7XG4gICAgICByZXR1cm4gdGFiRXZlbnQgPSBlO1xuICAgIH1cblxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB2YXIgY3VycmVudEZvY3VzSW5kZXggPSB0YWJiYWJsZU5vZGVzLmluZGV4T2YoZS50YXJnZXQpO1xuXG4gICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgIGlmIChlLnRhcmdldCA9PT0gZmlyc3RUYWJiYWJsZU5vZGUgfHwgdGFiYmFibGVOb2Rlcy5pbmRleE9mKGUudGFyZ2V0KSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRyeUZvY3VzKGxhc3RUYWJiYWJsZU5vZGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyeUZvY3VzKHRhYmJhYmxlTm9kZXNbY3VycmVudEZvY3VzSW5kZXggLSAxXSk7XG4gICAgfVxuXG4gICAgaWYgKGUudGFyZ2V0ID09PSBsYXN0VGFiYmFibGVOb2RlKSByZXR1cm4gdHJ5Rm9jdXMoZmlyc3RUYWJiYWJsZU5vZGUpO1xuXG4gICAgdHJ5Rm9jdXModGFiYmFibGVOb2Rlc1tjdXJyZW50Rm9jdXNJbmRleCArIDFdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVRhYmJhYmxlTm9kZXMoKSB7XG4gICAgdGFiYmFibGVOb2RlcyA9IHRhYmJhYmxlKGNvbnRhaW5lcik7XG4gICAgZmlyc3RUYWJiYWJsZU5vZGUgPSB0YWJiYWJsZU5vZGVzWzBdO1xuICAgIGxhc3RUYWJiYWJsZU5vZGUgPSB0YWJiYWJsZU5vZGVzW3RhYmJhYmxlTm9kZXMubGVuZ3RoIC0gMV07XG4gIH1cblxuICBmdW5jdGlvbiByZWFkanVzdEZvY3VzKGUpIHtcbiAgICBpZiAoZS5zaGlmdEtleSkgcmV0dXJuIHRyeUZvY3VzKGxhc3RUYWJiYWJsZU5vZGUpO1xuXG4gICAgdHJ5Rm9jdXMoZmlyc3RUYWJiYWJsZU5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzRXNjYXBlRXZlbnQoZSkge1xuICByZXR1cm4gZS5rZXkgPT09ICdFc2NhcGUnIHx8IGUua2V5ID09PSAnRXNjJyB8fCBlLmtleUNvZGUgPT09IDI3O1xufVxuXG5mdW5jdGlvbiB0cnlGb2N1cyhub2RlKSB7XG4gIGlmICghbm9kZSB8fCAhbm9kZS5mb2N1cykgcmV0dXJuO1xuICBpZiAobm9kZSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkgIHJldHVybjtcblxuICBub2RlLmZvY3VzKCk7XG4gIGlmIChub2RlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0Jykge1xuICAgIG5vZGUuc2VsZWN0KCk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb2N1c1RyYXA7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgY3JlYXRlRm9jdXNUcmFwIGZyb20gJ2ZvY3VzLXRyYXAnO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRm9jdXNUcmFwSW5zdGFuY2Uoc3VyZmFjZUVsLCBhY2NlcHRCdXR0b25FbCwgZm9jdXNUcmFwRmFjdG9yeSA9IGNyZWF0ZUZvY3VzVHJhcCkge1xuICByZXR1cm4gZm9jdXNUcmFwRmFjdG9yeShzdXJmYWNlRWwsIHtcbiAgICBpbml0aWFsRm9jdXM6IGFjY2VwdEJ1dHRvbkVsLFxuICAgIGNsaWNrT3V0c2lkZURlYWN0aXZhdGVzOiB0cnVlLFxuICB9KTtcbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgPGFzaWRlXG4gICAgcmVmPVwicm9vdFwiXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiXG4gICAgOnN0eWxlPVwic3R5bGVzXCJcbiAgICA6YXJpYS1sYWJlbGxlZGJ5PVwiJ2xhYmVsJyArIHZtYV91aWRfXCJcbiAgICA6YXJpYS1kZXNjcmliZWRieT1cIidkZXNjJyArIHZtYV91aWRfXCJcbiAgICBjbGFzcz1cIm1kYy1kaWFsb2dcIlxuICAgIHJvbGU9XCJhbGVydGRpYWxvZ1wiXG4gID5cbiAgICA8ZGl2XG4gICAgICByZWY9XCJzdXJmYWNlXCJcbiAgICAgIDpjbGFzcz1cInN1cmZhY2VDbGFzc2VzXCJcbiAgICAgIGNsYXNzPVwibWRjLWRpYWxvZ19fc3VyZmFjZVwiPlxuICAgICAgPGhlYWRlclxuICAgICAgICB2LWlmPVwidGl0bGVcIlxuICAgICAgICBjbGFzcz1cIm1kYy1kaWFsb2dfX2hlYWRlclwiPlxuICAgICAgICA8aDJcbiAgICAgICAgICA6aWQ9XCInbGFiZWwnICsgdm1hX3VpZF9cIlxuICAgICAgICAgIGNsYXNzPVwibWRjLWRpYWxvZ19faGVhZGVyX190aXRsZVwiPlxuICAgICAgICAgIHt7IHRpdGxlIH19XG4gICAgICAgIDwvaDI+XG4gICAgICA8L2hlYWRlcj5cbiAgICAgIDxzZWN0aW9uXG4gICAgICAgIDppZD1cIidkZXNjJyArIHZtYV91aWRfXCJcbiAgICAgICAgOmNsYXNzPVwiYm9keUNsYXNzZXNcIlxuICAgICAgICBjbGFzcz1cIm1kYy1kaWFsb2dfX2JvZHlcIj5cbiAgICAgICAgPHNsb3QgLz5cbiAgICAgIDwvc2VjdGlvbj5cbiAgICAgIDxmb290ZXJcbiAgICAgICAgdi1pZj1cImFjY2VwdHx8Y2FuY2VsXCJcbiAgICAgICAgY2xhc3M9XCJtZGMtZGlhbG9nX19mb290ZXJcIj5cbiAgICAgICAgPG1kY0J1dHRvblxuICAgICAgICAgIHYtaWY9XCJjYW5jZWxcIlxuICAgICAgICAgIHJlZj1cImNhbmNlbFwiXG4gICAgICAgICAgOmNsYXNzPVwieydtZGMtZGlhbG9nX19hY3Rpb24nOmFjY2VudH1cIlxuICAgICAgICAgIGNsYXNzPVwibWRjLWRpYWxvZ19fZm9vdGVyX19idXR0b24gbWRjLWRpYWxvZ19fZm9vdGVyX19idXR0b24tLWNhbmNlbFwiXG4gICAgICAgICAgQGNsaWNrPVwib25DYW5jZWxcIlxuICAgICAgICA+e3sgY2FuY2VsIH19PC9tZGNCdXR0b24+XG4gICAgICAgIDxtZGNCdXR0b25cbiAgICAgICAgICByZWY9XCJhY2NlcHRcIlxuICAgICAgICAgIDpjbGFzcz1cInsnbWRjLWRpYWxvZ19fYWN0aW9uJzphY2NlbnR9XCJcbiAgICAgICAgICA6ZGlzYWJsZWQ9XCJhY2NlcHREaXNhYmxlZFwiXG4gICAgICAgICAgY2xhc3M9XCJtZGMtZGlhbG9nX19mb290ZXJfX2J1dHRvbiBtZGMtZGlhbG9nX19mb290ZXJfX2J1dHRvbi0tYWNjZXB0XCJcbiAgICAgICAgICBAY2xpY2s9XCJvbkFjY2VwdFwiXG4gICAgICAgID57eyBhY2NlcHQgfX08L21kY0J1dHRvbj5cbiAgICAgIDwvZm9vdGVyPlxuICAgIDwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJtZGMtZGlhbG9nX19iYWNrZHJvcFwiLz5cbiAgPC9hc2lkZT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDRGlhbG9nRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvZGlhbG9nL2ZvdW5kYXRpb24nXG5pbXBvcnQgeyBjcmVhdGVGb2N1c1RyYXBJbnN0YW5jZSB9IGZyb20gJ0BtYXRlcmlhbC9kaWFsb2cvdXRpbCdcbmltcG9ydCB7IG1kY0J1dHRvbiB9IGZyb20gJy4uL2J1dHRvbidcbmltcG9ydCB7IFZNQVVuaXF1ZUlkTWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtZGlhbG9nJyxcbiAgY29tcG9uZW50czoge1xuICAgIG1kY0J1dHRvbjogbWRjQnV0dG9uXG4gIH0sXG4gIG1peGluczogW1ZNQVVuaXF1ZUlkTWl4aW5dLFxuICBtb2RlbDoge1xuICAgIHByb3A6ICdvcGVuJyxcbiAgICBldmVudDogJ2NoYW5nZSdcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICB0aXRsZTogeyB0eXBlOiBTdHJpbmcgfSxcbiAgICBhY2NlcHQ6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiAnT2snIH0sXG4gICAgYWNjZXB0RGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgY2FuY2VsOiB7IHR5cGU6IFN0cmluZyB9LFxuICAgIGFjY2VudDogQm9vbGVhbixcbiAgICBzY3JvbGxhYmxlOiBCb29sZWFuLFxuICAgIG9wZW46IEJvb2xlYW5cbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge1xuICAgICAgICAnbWRjLXRoZW1lLS1kYXJrJzogdGhpcy5kYXJrXG4gICAgICB9LFxuICAgICAgc3R5bGVzOiB7fSxcbiAgICAgIHN1cmZhY2VDbGFzc2VzOiB7fSxcbiAgICAgIGJvZHlDbGFzc2VzOiB7XG4gICAgICAgICdtZGMtZGlhbG9nX19ib2R5LS1zY3JvbGxhYmxlJzogdGhpcy5zY3JvbGxhYmxlXG4gICAgICB9XG4gICAgfVxuICB9LFxuICB3YXRjaDogeyBvcGVuOiAnb25PcGVuXycgfSxcbiAgbW91bnRlZCgpIHtcbiAgICBpZiAodGhpcy5hY2NlcHQpIHtcbiAgICAgIHRoaXMuZm9jdXNUcmFwID0gY3JlYXRlRm9jdXNUcmFwSW5zdGFuY2UoXG4gICAgICAgIHRoaXMuJHJlZnMuc3VyZmFjZSxcbiAgICAgICAgdGhpcy4kcmVmcy5hY2NlcHRcbiAgICAgIClcbiAgICB9XG5cbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDRGlhbG9nRm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSksXG4gICAgICByZW1vdmVDbGFzczogY2xhc3NOYW1lID0+IHRoaXMuJGRlbGV0ZSh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSksXG4gICAgICBhZGRCb2R5Q2xhc3M6IGNsYXNzTmFtZSA9PiBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSxcbiAgICAgIHJlbW92ZUJvZHlDbGFzczogY2xhc3NOYW1lID0+IGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpLFxuICAgICAgZXZlbnRUYXJnZXRIYXNDbGFzczogKHRhcmdldCwgY2xhc3NOYW1lKSA9PlxuICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSksXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5yb290LmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+XG4gICAgICAgIHRoaXMuJHJlZnMucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciksXG4gICAgICByZWdpc3RlclN1cmZhY2VJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKmV2dCwgaGFuZGxlciovKSA9PiB7XG4gICAgICAgIC8vIFZNQV9IQUNLOiBoYW5kbGUgYnV0dG9uIGNsaWNrcyBvdXJzZWx2ZXNcbiAgICAgICAgLy8gdGhpcy4kcmVmcy5zdXJmYWNlLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJTdXJmYWNlSW50ZXJhY3Rpb25IYW5kbGVyOiAoLypldnQsIGhhbmRsZXIqLykgPT4ge1xuICAgICAgICAvLyBWTUFfSEFDSzogaGFuZGxlIGJ1dHRvbiBjbGlja3Mgb3Vyc2VsdmVzXG4gICAgICAgIC8vIHRoaXMuJHJlZnMuc3VyZmFjZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICByZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpLFxuICAgICAgcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcjogaGFuZGxlciA9PlxuICAgICAgICB0aGlzLiRyZWZzLnN1cmZhY2UuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiBoYW5kbGVyID0+XG4gICAgICAgIHRoaXMuJHJlZnMuc3VyZmFjZS5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgaGFuZGxlciksXG4gICAgICBub3RpZnlBY2NlcHQ6ICgpID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZmFsc2UpXG4gICAgICAgIHRoaXMuJGVtaXQoJ2FjY2VwdCcpXG4gICAgICB9LFxuICAgICAgbm90aWZ5Q2FuY2VsOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGZhbHNlKVxuICAgICAgICB0aGlzLiRlbWl0KCdjYW5jZWwnKVxuICAgICAgfSxcbiAgICAgIHRyYXBGb2N1c09uU3VyZmFjZTogKCkgPT4gdGhpcy5mb2N1c1RyYXAgJiYgdGhpcy5mb2N1c1RyYXAuYWN0aXZhdGUoKSxcbiAgICAgIHVudHJhcEZvY3VzT25TdXJmYWNlOiAoKSA9PiB0aGlzLmZvY3VzVHJhcCAmJiB0aGlzLmZvY3VzVHJhcC5kZWFjdGl2YXRlKCksXG4gICAgICBpc0RpYWxvZzogZWwgPT4gdGhpcy4kcmVmcy5zdXJmYWNlID09PSBlbFxuICAgIH0pXG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gICAgdGhpcy5vcGVuICYmIHRoaXMuZm91bmRhdGlvbi5vcGVuKClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbk9wZW5fKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uLm9wZW4oKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uLmNsb3NlKClcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uQ2FuY2VsKCkge1xuICAgICAgaWYgKHRoaXMuJGxpc3RlbmVyc1sndmFsaWRhdGVDYW5jZWwnXSkge1xuICAgICAgICB0aGlzLiRlbWl0KCd2YWxpZGF0ZUNhbmNlbCcsIHtcbiAgICAgICAgICBjYW5jZWw6IChub3RpZnkgPSB0cnVlKSA9PiB7XG4gICAgICAgICAgICAvLyBpZiBub3RpZnkgPSBmYWxzZSwgdGhlIGRpYWxvZyB3aWxsIGNsb3NlXG4gICAgICAgICAgICAvLyBidXQgdGhlIG5vdGlmeUFjY2VwdCBtZXRob2Qgd2lsbCBub3QgYmUgY2FsbGVkXG4gICAgICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIG5vdGlmeSBsaXN0ZW5lcnMgdGhlIG9wZW4gc3RhdGVcbiAgICAgICAgICAgIC8vIGlzIGNoYW5naW5nLlxuICAgICAgICAgICAgaWYgKCFub3RpZnkpIHtcbiAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZmFsc2UpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmZvdW5kYXRpb24uY2FuY2VsKG5vdGlmeSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24uY2FuY2VsKHRydWUpXG4gICAgICB9XG4gICAgfSxcbiAgICBvbkFjY2VwdCgpIHtcbiAgICAgIGlmICh0aGlzLiRsaXN0ZW5lcnNbJ3ZhbGlkYXRlJ10pIHtcbiAgICAgICAgdGhpcy4kZW1pdCgndmFsaWRhdGUnLCB7XG4gICAgICAgICAgYWNjZXB0OiAobm90aWZ5ID0gdHJ1ZSkgPT4ge1xuICAgICAgICAgICAgLy8gaWYgbm90aWZ5ID0gZmFsc2UsIHRoZSBkaWFsb2cgd2lsbCBjbG9zZVxuICAgICAgICAgICAgLy8gYnV0IHRoZSBub3RpZnlBY2NlcHQgbWV0aG9kIHdpbGwgbm90IGJlIGNhbGxlZFxuICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBub3RpZnkgbGlzdGVuZXJzIHRoZSBvcGVuIHN0YXRlXG4gICAgICAgICAgICAvLyBpcyBjaGFuZ2luZy5cbiAgICAgICAgICAgIGlmICghbm90aWZ5KSB7XG4gICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGZhbHNlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mb3VuZGF0aW9uLmFjY2VwdChub3RpZnkpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uLmFjY2VwdCh0cnVlKVxuICAgICAgfVxuICAgIH0sXG4gICAgc2hvdygpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5vcGVuKClcbiAgICB9LFxuICAgIGNsb3NlKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLmNsb3NlKClcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjRGlhbG9nIGZyb20gJy4vbWRjLWRpYWxvZy52dWUnXG5cbmV4cG9ydCB7IG1kY0RpYWxvZyB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNEaWFsb2dcbn0pXG4iLCI8dGVtcGxhdGU+XG4gIDxuYXYgY2xhc3M9XCJtZGMtcGVybWFuZW50LWRyYXdlciBtZGMtZHJhd2VyLS1wZXJtYW5lbnQgbWRjLXR5cG9ncmFwaHlcIj5cbiAgICA8bmF2IGNsYXNzPVwibWRjLWRyYXdlcl9fY29udGVudFwiPlxuICAgICAgPGRpdiBcbiAgICAgICAgdi1pZj1cInRvb2xiYXJTcGFjZXJcIiBcbiAgICAgICAgY2xhc3M9XCJtZGMtZHJhd2VyX190b29sYmFyLXNwYWNlclwiLz5cbiAgICAgIDxzbG90IC8+XG4gICAgPC9uYXY+XG4gIDwvbmF2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1wZXJtYW5lbnQtZHJhd2VyJyxcbiAgcHJvcHM6IHtcbiAgICAndG9vbGJhci1zcGFjZXInOiBCb29sZWFuXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGNvbnN0IEZPQ1VTQUJMRV9FTEVNRU5UUyA9XG4gICdhW2hyZWZdLCBhcmVhW2hyZWZdLCBpbnB1dDpub3QoW2Rpc2FibGVkXSksIHNlbGVjdDpub3QoW2Rpc2FibGVkXSksIHRleHRhcmVhOm5vdChbZGlzYWJsZWRdKSwgJyArXG4gICdidXR0b246bm90KFtkaXNhYmxlZF0pLCBpZnJhbWUsIG9iamVjdCwgZW1iZWQsIFt0YWJpbmRleF0sIFtjb250ZW50ZWRpdGFibGVdJztcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7TURDRm91bmRhdGlvbn0gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvaW5kZXgnO1xuXG5leHBvcnQgY2xhc3MgTURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBoYXNDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGhhc05lY2Vzc2FyeURvbTogKCkgPT4gLyogYm9vbGVhbiAqLyBmYWxzZSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0OiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dDogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyRHJhd2VySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0OiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckRyYXdlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dDogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgc2V0VHJhbnNsYXRlWDogKC8qIHZhbHVlOiBudW1iZXIgfCBudWxsICovKSA9PiB7fSxcbiAgICAgIGdldEZvY3VzYWJsZUVsZW1lbnRzOiAoKSA9PiAvKiBOb2RlTGlzdCAqLyB7fSxcbiAgICAgIHNhdmVFbGVtZW50VGFiU3RhdGU6ICgvKiBlbDogRWxlbWVudCAqLykgPT4ge30sXG4gICAgICByZXN0b3JlRWxlbWVudFRhYlN0YXRlOiAoLyogZWw6IEVsZW1lbnQgKi8pID0+IHt9LFxuICAgICAgbWFrZUVsZW1lbnRVbnRhYmJhYmxlOiAoLyogZWw6IEVsZW1lbnQgKi8pID0+IHt9LFxuICAgICAgbm90aWZ5T3BlbjogKCkgPT4ge30sXG4gICAgICBub3RpZnlDbG9zZTogKCkgPT4ge30sXG4gICAgICBpc1J0bDogKCkgPT4gLyogYm9vbGVhbiAqLyBmYWxzZSxcbiAgICAgIGdldERyYXdlcldpZHRoOiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICB9O1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlciwgcm9vdENzc0NsYXNzLCBhbmltYXRpbmdDc3NDbGFzcywgb3BlbkNzc0NsYXNzKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIHRoaXMucm9vdENzc0NsYXNzXyA9IHJvb3RDc3NDbGFzcztcbiAgICB0aGlzLmFuaW1hdGluZ0Nzc0NsYXNzXyA9IGFuaW1hdGluZ0Nzc0NsYXNzO1xuICAgIHRoaXMub3BlbkNzc0NsYXNzXyA9IG9wZW5Dc3NDbGFzcztcblxuICAgIHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVUcmFuc2l0aW9uRW5kXyhldnQpO1xuXG4gICAgdGhpcy5pbmVydF8gPSBmYWxzZTtcblxuICAgIHRoaXMuY29tcG9uZW50VG91Y2hTdGFydEhhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVUb3VjaFN0YXJ0XyhldnQpO1xuICAgIHRoaXMuY29tcG9uZW50VG91Y2hNb3ZlSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZVRvdWNoTW92ZV8oZXZ0KTtcbiAgICB0aGlzLmNvbXBvbmVudFRvdWNoRW5kSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZVRvdWNoRW5kXyhldnQpO1xuICAgIHRoaXMuZG9jdW1lbnRLZXlkb3duSGFuZGxlcl8gPSAoZXZ0KSA9PiB7XG4gICAgICBpZiAoZXZ0LmtleSAmJiBldnQua2V5ID09PSAnRXNjYXBlJyB8fCBldnQua2V5Q29kZSA9PT0gMjcpIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBpbml0KCkge1xuICAgIGNvbnN0IFJPT1QgPSB0aGlzLnJvb3RDc3NDbGFzc187XG4gICAgY29uc3QgT1BFTiA9IHRoaXMub3BlbkNzc0NsYXNzXztcblxuICAgIGlmICghdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhST09UKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke1JPT1R9IGNsYXNzIHJlcXVpcmVkIGluIHJvb3QgZWxlbWVudC5gKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuYWRhcHRlcl8uaGFzTmVjZXNzYXJ5RG9tKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUmVxdWlyZWQgRE9NIG5vZGVzIG1pc3NpbmcgaW4gJHtST09UfSBjb21wb25lbnQuYCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoT1BFTikpIHtcbiAgICAgIHRoaXMuaXNPcGVuXyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGV0YWJpbmF0ZV8oKTtcbiAgICAgIHRoaXMuaXNPcGVuXyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJEcmF3ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLmNvbXBvbmVudFRvdWNoU3RhcnRIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigndG91Y2htb3ZlJywgdGhpcy5jb21wb25lbnRUb3VjaE1vdmVIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigndG91Y2hlbmQnLCB0aGlzLmNvbXBvbmVudFRvdWNoRW5kSGFuZGxlcl8pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJEcmF3ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLmNvbXBvbmVudFRvdWNoU3RhcnRIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCd0b3VjaG1vdmUnLCB0aGlzLmNvbXBvbmVudFRvdWNoTW92ZUhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ3RvdWNoZW5kJywgdGhpcy5jb21wb25lbnRUb3VjaEVuZEhhbmRsZXJfKTtcbiAgICAvLyBEZXJlZ2lzdGVyIHRoZSBkb2N1bWVudCBrZXlkb3duIGhhbmRsZXIganVzdCBpbiBjYXNlIHRoZSBjb21wb25lbnQgaXMgZGVzdHJveWVkIHdoaWxlIHRoZSBtZW51IGlzIG9wZW4uXG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcih0aGlzLmRvY3VtZW50S2V5ZG93bkhhbmRsZXJfKTtcbiAgfVxuXG4gIG9wZW4oKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyKHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcih0aGlzLmRvY3VtZW50S2V5ZG93bkhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKHRoaXMuYW5pbWF0aW5nQ3NzQ2xhc3NfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKHRoaXMub3BlbkNzc0NsYXNzXyk7XG4gICAgdGhpcy5yZXRhYmluYXRlXygpO1xuICAgIC8vIERlYm91bmNlIG11bHRpcGxlIGNhbGxzXG4gICAgaWYgKCF0aGlzLmlzT3Blbl8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5T3BlbigpO1xuICAgIH1cbiAgICB0aGlzLmlzT3Blbl8gPSB0cnVlO1xuICB9XG5cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcih0aGlzLmRvY3VtZW50S2V5ZG93bkhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXIodGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3ModGhpcy5hbmltYXRpbmdDc3NDbGFzc18pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3ModGhpcy5vcGVuQ3NzQ2xhc3NfKTtcbiAgICB0aGlzLmRldGFiaW5hdGVfKCk7XG4gICAgLy8gRGVib3VuY2UgbXVsdGlwbGUgY2FsbHNcbiAgICBpZiAodGhpcy5pc09wZW5fKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUNsb3NlKCk7XG4gICAgfVxuICAgIHRoaXMuaXNPcGVuXyA9IGZhbHNlO1xuICB9XG5cbiAgaXNPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLmlzT3Blbl87XG4gIH1cblxuICAvKipcbiAgICogIFJlbmRlciBhbGwgY2hpbGRyZW4gb2YgdGhlIGRyYXdlciBpbmVydCB3aGVuIGl0J3MgY2xvc2VkLlxuICAgKi9cbiAgZGV0YWJpbmF0ZV8oKSB7XG4gICAgaWYgKHRoaXMuaW5lcnRfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmFkYXB0ZXJfLmdldEZvY3VzYWJsZUVsZW1lbnRzKCk7XG4gICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uc2F2ZUVsZW1lbnRUYWJTdGF0ZShlbGVtZW50c1tpXSk7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ubWFrZUVsZW1lbnRVbnRhYmJhYmxlKGVsZW1lbnRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmluZXJ0XyA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogIE1ha2UgYWxsIGNoaWxkcmVuIG9mIHRoZSBkcmF3ZXIgdGFiYmFibGUgYWdhaW4gd2hlbiBpdCdzIG9wZW4uXG4gICAqL1xuICByZXRhYmluYXRlXygpIHtcbiAgICBpZiAoIXRoaXMuaW5lcnRfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmFkYXB0ZXJfLmdldEZvY3VzYWJsZUVsZW1lbnRzKCk7XG4gICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ucmVzdG9yZUVsZW1lbnRUYWJTdGF0ZShlbGVtZW50c1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5pbmVydF8gPSBmYWxzZTtcbiAgfVxuXG4gIGhhbmRsZVRvdWNoU3RhcnRfKGV2dCkge1xuICAgIGlmICghdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyh0aGlzLm9wZW5Dc3NDbGFzc18pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChldnQucG9pbnRlclR5cGUgJiYgZXZ0LnBvaW50ZXJUeXBlICE9PSAndG91Y2gnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kaXJlY3Rpb25fID0gdGhpcy5hZGFwdGVyXy5pc1J0bCgpID8gLTEgOiAxO1xuICAgIHRoaXMuZHJhd2VyV2lkdGhfID0gdGhpcy5hZGFwdGVyXy5nZXREcmF3ZXJXaWR0aCgpO1xuICAgIHRoaXMuc3RhcnRYXyA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0ucGFnZVggOiBldnQucGFnZVg7XG4gICAgdGhpcy5jdXJyZW50WF8gPSB0aGlzLnN0YXJ0WF87XG5cbiAgICB0aGlzLnVwZGF0ZVJhZl8gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGVEcmF3ZXJfLmJpbmQodGhpcykpO1xuICB9XG5cbiAgaGFuZGxlVG91Y2hNb3ZlXyhldnQpIHtcbiAgICBpZiAoZXZ0LnBvaW50ZXJUeXBlICYmIGV2dC5wb2ludGVyVHlwZSAhPT0gJ3RvdWNoJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudFhfID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXS5wYWdlWCA6IGV2dC5wYWdlWDtcbiAgfVxuXG4gIGhhbmRsZVRvdWNoRW5kXyhldnQpIHtcbiAgICBpZiAoZXZ0LnBvaW50ZXJUeXBlICYmIGV2dC5wb2ludGVyVHlwZSAhPT0gJ3RvdWNoJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucHJlcGFyZUZvclRvdWNoRW5kXygpO1xuXG4gICAgLy8gRGlkIHRoZSB1c2VyIGNsb3NlIHRoZSBkcmF3ZXIgYnkgbW9yZSB0aGFuIDUwJT9cbiAgICBpZiAoTWF0aC5hYnModGhpcy5uZXdQb3NpdGlvbl8gLyB0aGlzLmRyYXdlcldpZHRoXykgPj0gMC41KSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRyaWdnZXJpbmcgYW4gb3BlbiBoZXJlIG1lYW5zIHdlJ2xsIGdldCBhIG5pY2UgYW5pbWF0aW9uIGJhY2sgdG8gdGhlIGZ1bGx5IG9wZW4gc3RhdGUuXG4gICAgICB0aGlzLm9wZW4oKTtcbiAgICB9XG4gIH1cblxuICBwcmVwYXJlRm9yVG91Y2hFbmRfKCkge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlUmFmXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRUcmFuc2xhdGVYKG51bGwpO1xuICB9XG5cbiAgdXBkYXRlRHJhd2VyXygpIHtcbiAgICB0aGlzLnVwZGF0ZVJhZl8gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGVEcmF3ZXJfLmJpbmQodGhpcykpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0VHJhbnNsYXRlWCh0aGlzLm5ld1Bvc2l0aW9uXyk7XG4gIH1cblxuICBnZXQgbmV3UG9zaXRpb25fKCkge1xuICAgIGxldCBuZXdQb3MgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuZGlyZWN0aW9uXyA9PT0gMSkge1xuICAgICAgbmV3UG9zID0gTWF0aC5taW4oMCwgdGhpcy5jdXJyZW50WF8gLSB0aGlzLnN0YXJ0WF8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdQb3MgPSBNYXRoLm1heCgwLCB0aGlzLmN1cnJlbnRYXyAtIHRoaXMuc3RhcnRYXyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1BvcztcbiAgfVxuXG4gIGlzUm9vdFRyYW5zaXRpb25pbmdFdmVudFRhcmdldF8oKSB7XG4gICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9uIHNob3VsZCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmV0dXJuIHRydWUgb3IgZmFsc2VcbiAgICAvLyBpZiB0aGUgZXZlbnQgdGFyZ2V0IGlzIHRoZSByb290IGV2ZW50IHRhcmdldCBjdXJyZW50bHkgdHJhbnNpdGlvbmluZy5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBoYW5kbGVUcmFuc2l0aW9uRW5kXyhldnQpIHtcbiAgICBpZiAodGhpcy5pc1Jvb3RUcmFuc2l0aW9uaW5nRXZlbnRUYXJnZXRfKGV2dC50YXJnZXQpKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKHRoaXMuYW5pbWF0aW5nQ3NzQ2xhc3NfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyKHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfKTtcbiAgICB9XG4gIH07XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQge0ZPQ1VTQUJMRV9FTEVNRU5UU30gZnJvbSAnLi9jb25zdGFudHMnO1xuZXhwb3J0IHtNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb259IGZyb20gJy4vZm91bmRhdGlvbic7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge0ZPQ1VTQUJMRV9FTEVNRU5UU30gZnJvbSAnLi4vc2xpZGFibGUvaW5kZXgnO1xuXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgUk9PVDogJ21kYy1kcmF3ZXItLXBlcnNpc3RlbnQnLFxuICBPUEVOOiAnbWRjLWRyYXdlci0tb3BlbicsXG4gIEFOSU1BVElORzogJ21kYy1kcmF3ZXItLWFuaW1hdGluZycsXG59O1xuXG5leHBvcnQgY29uc3Qgc3RyaW5ncyA9IHtcbiAgRFJBV0VSX1NFTEVDVE9SOiAnLm1kYy1kcmF3ZXItLXBlcnNpc3RlbnQgLm1kYy1kcmF3ZXJfX2RyYXdlcicsXG4gIEZPQ1VTQUJMRV9FTEVNRU5UUyxcbiAgT1BFTl9FVkVOVDogJ01EQ1BlcnNpc3RlbnREcmF3ZXI6b3BlbicsXG4gIENMT1NFX0VWRU5UOiAnTURDUGVyc2lzdGVudERyYXdlcjpjbG9zZScsXG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb259IGZyb20gJy4uL3NsaWRhYmxlL2luZGV4JztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNRENQZXJzaXN0ZW50RHJhd2VyRm91bmRhdGlvbiBleHRlbmRzIE1EQ1NsaWRhYmxlRHJhd2VyRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oTURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCB7XG4gICAgICBpc0RyYXdlcjogKCkgPT4gZmFsc2UsXG4gICAgfSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoXG4gICAgICBPYmplY3QuYXNzaWduKE1EQ1BlcnNpc3RlbnREcmF3ZXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSxcbiAgICAgIE1EQ1BlcnNpc3RlbnREcmF3ZXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuUk9PVCxcbiAgICAgIE1EQ1BlcnNpc3RlbnREcmF3ZXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQU5JTUFUSU5HLFxuICAgICAgTURDUGVyc2lzdGVudERyYXdlckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5PUEVOKTtcbiAgfVxuXG4gIGlzUm9vdFRyYW5zaXRpb25pbmdFdmVudFRhcmdldF8oZWwpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5pc0RyYXdlcihlbCk7XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmNvbnN0IFRBQl9EQVRBID0gJ2RhdGEtbWRjLXRhYmluZGV4JztcbmNvbnN0IFRBQl9EQVRBX0hBTkRMRUQgPSAnZGF0YS1tZGMtdGFiaW5kZXgtaGFuZGxlZCc7XG5cbmxldCBzdG9yZWRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWVfO1xubGV0IHN1cHBvcnRzUGFzc2l2ZV87XG5cbi8vIFJlbWFwIHRvdWNoIGV2ZW50cyB0byBwb2ludGVyIGV2ZW50cywgaWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRvdWNoIGV2ZW50cy5cbmV4cG9ydCBmdW5jdGlvbiByZW1hcEV2ZW50KGV2ZW50TmFtZSwgZ2xvYmFsT2JqID0gd2luZG93KSB7XG4gIGlmICghKCdvbnRvdWNoc3RhcnQnIGluIGdsb2JhbE9iai5kb2N1bWVudCkpIHtcbiAgICBzd2l0Y2ggKGV2ZW50TmFtZSkge1xuICAgIGNhc2UgJ3RvdWNoc3RhcnQnOlxuICAgICAgcmV0dXJuICdwb2ludGVyZG93bic7XG4gICAgY2FzZSAndG91Y2htb3ZlJzpcbiAgICAgIHJldHVybiAncG9pbnRlcm1vdmUnO1xuICAgIGNhc2UgJ3RvdWNoZW5kJzpcbiAgICAgIHJldHVybiAncG9pbnRlcnVwJztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGV2ZW50TmFtZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXZlbnROYW1lO1xufVxuXG4vLyBDaG9vc2UgdGhlIGNvcnJlY3QgdHJhbnNmb3JtIHByb3BlcnR5IHRvIHVzZSBvbiB0aGUgY3VycmVudCBicm93c2VyLlxuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zZm9ybVByb3BlcnR5TmFtZShnbG9iYWxPYmogPSB3aW5kb3csIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gIGlmIChzdG9yZWRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWVfID09PSB1bmRlZmluZWQgfHwgZm9yY2VSZWZyZXNoKSB7XG4gICAgY29uc3QgZWwgPSBnbG9iYWxPYmouZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3QgdHJhbnNmb3JtUHJvcGVydHlOYW1lID0gKCd0cmFuc2Zvcm0nIGluIGVsLnN0eWxlID8gJ3RyYW5zZm9ybScgOiAnLXdlYmtpdC10cmFuc2Zvcm0nKTtcbiAgICBzdG9yZWRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWVfID0gdHJhbnNmb3JtUHJvcGVydHlOYW1lO1xuICB9XG5cbiAgcmV0dXJuIHN0b3JlZFRyYW5zZm9ybVByb3BlcnR5TmFtZV87XG59XG5cbi8vIERldGVybWluZSB3aGV0aGVyIHRoZSBjdXJyZW50IGJyb3dzZXIgc3VwcG9ydHMgQ1NTIHByb3BlcnRpZXMuXG5leHBvcnQgZnVuY3Rpb24gc3VwcG9ydHNDc3NDdXN0b21Qcm9wZXJ0aWVzKGdsb2JhbE9iaiA9IHdpbmRvdykge1xuICBpZiAoJ0NTUycgaW4gZ2xvYmFsT2JqKSB7XG4gICAgcmV0dXJuIGdsb2JhbE9iai5DU1Muc3VwcG9ydHMoJygtLWNvbG9yOiByZWQpJyk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBEZXRlcm1pbmUgd2hldGhlciB0aGUgY3VycmVudCBicm93c2VyIHN1cHBvcnRzIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzLCBhbmQgaWYgc28sIHVzZSB0aGVtLlxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UGFzc2l2ZShnbG9iYWxPYmogPSB3aW5kb3csIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gIGlmIChzdXBwb3J0c1Bhc3NpdmVfID09PSB1bmRlZmluZWQgfHwgZm9yY2VSZWZyZXNoKSB7XG4gICAgbGV0IGlzU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGdsb2JhbE9iai5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwge2dldCBwYXNzaXZlKCkge1xuICAgICAgICBpc1N1cHBvcnRlZCA9IHRydWU7XG4gICAgICB9fSk7XG4gICAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgICBzdXBwb3J0c1Bhc3NpdmVfID0gaXNTdXBwb3J0ZWQ7XG4gIH1cblxuICByZXR1cm4gc3VwcG9ydHNQYXNzaXZlXyA/IHtwYXNzaXZlOiB0cnVlfSA6IGZhbHNlO1xufVxuXG4vLyBTYXZlIHRoZSB0YWIgc3RhdGUgZm9yIGFuIGVsZW1lbnQuXG5leHBvcnQgZnVuY3Rpb24gc2F2ZUVsZW1lbnRUYWJTdGF0ZShlbCkge1xuICBpZiAoZWwuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKFRBQl9EQVRBLCBlbC5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykpO1xuICB9XG4gIGVsLnNldEF0dHJpYnV0ZShUQUJfREFUQV9IQU5ETEVELCB0cnVlKTtcbn1cblxuLy8gUmVzdG9yZSB0aGUgdGFiIHN0YXRlIGZvciBhbiBlbGVtZW50LCBpZiBpdCB3YXMgc2F2ZWQuXG5leHBvcnQgZnVuY3Rpb24gcmVzdG9yZUVsZW1lbnRUYWJTdGF0ZShlbCkge1xuICAvLyBPbmx5IG1vZGlmeSBlbGVtZW50cyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQsIGluIGNhc2UgYW55dGhpbmcgd2FzIGR5bmFtaWNhbGx5IGFkZGVkIHNpbmNlIHdlIHNhdmVkIHN0YXRlLlxuICBpZiAoZWwuaGFzQXR0cmlidXRlKFRBQl9EQVRBX0hBTkRMRUQpKSB7XG4gICAgaWYgKGVsLmhhc0F0dHJpYnV0ZShUQUJfREFUQSkpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCBlbC5nZXRBdHRyaWJ1dGUoVEFCX0RBVEEpKTtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShUQUJfREFUQSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICB9XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKFRBQl9EQVRBX0hBTkRMRUQpO1xuICB9XG59XG4iLCI8dGVtcGxhdGU+XG4gIDxhc2lkZVxuICAgIDpjbGFzcz1cImNsYXNzZXNcIlxuICAgIGNsYXNzPVwibWRjLXBlcnNpc3RlbnQtZHJhd2VyIG1kYy1kcmF3ZXItLXBlcnNpc3RlbnQgbWRjLXR5cG9ncmFwaHlcIj5cbiAgICA8bmF2XG4gICAgICByZWY9XCJkcmF3ZXJcIlxuICAgICAgY2xhc3M9XCJtZGMtZHJhd2VyX19kcmF3ZXJcIj5cbiAgICAgIDxkaXZcbiAgICAgICAgdi1pZj1cInRvb2xiYXJTcGFjZXJcIlxuICAgICAgICBjbGFzcz1cIm1kYy1kcmF3ZXJfX3Rvb2xiYXItc3BhY2VyXCIvPlxuICAgICAgPHNsb3QgLz5cbiAgICA8L25hdj5cbiAgPC9hc2lkZT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDUGVyc2lzdGVudERyYXdlckZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2RyYXdlci9wZXJzaXN0ZW50L2ZvdW5kYXRpb24nXG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJ0BtYXRlcmlhbC9kcmF3ZXIvdXRpbCdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXBlcnNpc3RlbnQtZHJhd2VyJyxcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAnb3BlbicsXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgJ3Rvb2xiYXItc3BhY2VyJzogQm9vbGVhbixcbiAgICBvcGVuOiBCb29sZWFuXG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHt9XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIG9wZW46ICdfcmVmcmVzaCdcbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICBjb25zdCB7IEZPQ1VTQUJMRV9FTEVNRU5UUyB9ID0gTURDUGVyc2lzdGVudERyYXdlckZvdW5kYXRpb24uc3RyaW5nc1xuXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ1BlcnNpc3RlbnREcmF3ZXJGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICB9LFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSlcbiAgICAgIH0sXG4gICAgICBoYXNDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgaGFzTmVjZXNzYXJ5RG9tOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuJHJlZnMuZHJhd2VyXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICB1dGlsLnJlbWFwRXZlbnQoZXZ0KSxcbiAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgIHV0aWwuYXBwbHlQYXNzaXZlKClcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICB1dGlsLnJlbWFwRXZlbnQoZXZ0KSxcbiAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgIHV0aWwuYXBwbHlQYXNzaXZlKClcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyRHJhd2VySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgdXRpbC5yZW1hcEV2ZW50KGV2dCksXG4gICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICB1dGlsLmFwcGx5UGFzc2l2ZSgpXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyRHJhd2VySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgdXRpbC5yZW1hcEV2ZW50KGV2dCksXG4gICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICB1dGlsLmFwcGx5UGFzc2l2ZSgpXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICByZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5kcmF3ZXIuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5kcmF3ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBnZXREcmF3ZXJXaWR0aDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5kcmF3ZXIub2Zmc2V0V2lkdGhcbiAgICAgIH0sXG4gICAgICBzZXRUcmFuc2xhdGVYOiB2YWx1ZSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgIHV0aWwuZ2V0VHJhbnNmb3JtUHJvcGVydHlOYW1lKCksXG4gICAgICAgICAgdmFsdWUgPT09IG51bGwgPyBudWxsIDogYHRyYW5zbGF0ZVgoJHt2YWx1ZX1weClgXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBnZXRGb2N1c2FibGVFbGVtZW50czogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5kcmF3ZXIucXVlcnlTZWxlY3RvckFsbChGT0NVU0FCTEVfRUxFTUVOVFMpXG4gICAgICB9LFxuICAgICAgc2F2ZUVsZW1lbnRUYWJTdGF0ZTogZWwgPT4ge1xuICAgICAgICB1dGlsLnNhdmVFbGVtZW50VGFiU3RhdGUoZWwpXG4gICAgICB9LFxuICAgICAgcmVzdG9yZUVsZW1lbnRUYWJTdGF0ZTogZWwgPT4ge1xuICAgICAgICB1dGlsLnJlc3RvcmVFbGVtZW50VGFiU3RhdGUoZWwpXG4gICAgICB9LFxuICAgICAgbWFrZUVsZW1lbnRVbnRhYmJhYmxlOiBlbCA9PiB7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAtMSlcbiAgICAgIH0sXG4gICAgICBub3RpZnlPcGVuOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIHRydWUpXG4gICAgICAgIHRoaXMuJGVtaXQoJ29wZW4nKVxuICAgICAgfSxcbiAgICAgIG5vdGlmeUNsb3NlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGZhbHNlKVxuICAgICAgICB0aGlzLiRlbWl0KCdjbG9zZScpXG4gICAgICB9LFxuICAgICAgaXNSdGw6ICgpID0+IHtcbiAgICAgICAgLyogZ2xvYmFsIGdldENvbXB1dGVkU3R5bGUgKi9cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBnZXRDb21wdXRlZFN0eWxlKHRoaXMuJGVsKS5nZXRQcm9wZXJ0eVZhbHVlKCdkaXJlY3Rpb24nKSA9PT0gJ3J0bCdcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIGlzRHJhd2VyOiBlbCA9PiB7XG4gICAgICAgIHJldHVybiBlbCA9PT0gdGhpcy4kcmVmcy5kcmF3ZXJcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gICAgdGhpcy5fcmVmcmVzaCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBudWxsXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBfcmVmcmVzaCgpIHtcbiAgICAgIGlmICh0aGlzLm9wZW4pIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5vcGVuKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uY2xvc2UoKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge0ZPQ1VTQUJMRV9FTEVNRU5UU30gZnJvbSAnLi4vc2xpZGFibGUvaW5kZXgnO1xuXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgUk9PVDogJ21kYy1kcmF3ZXItLXRlbXBvcmFyeScsXG4gIE9QRU46ICdtZGMtZHJhd2VyLS1vcGVuJyxcbiAgQU5JTUFUSU5HOiAnbWRjLWRyYXdlci0tYW5pbWF0aW5nJyxcbiAgU0NST0xMX0xPQ0s6ICdtZGMtZHJhd2VyLXNjcm9sbC1sb2NrJyxcbn07XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBEUkFXRVJfU0VMRUNUT1I6ICcubWRjLWRyYXdlci0tdGVtcG9yYXJ5IC5tZGMtZHJhd2VyX19kcmF3ZXInLFxuICBPUEFDSVRZX1ZBUl9OQU1FOiAnLS1tZGMtdGVtcG9yYXJ5LWRyYXdlci1vcGFjaXR5JyxcbiAgRk9DVVNBQkxFX0VMRU1FTlRTLFxuICBPUEVOX0VWRU5UOiAnTURDVGVtcG9yYXJ5RHJhd2VyOm9wZW4nLFxuICBDTE9TRV9FVkVOVDogJ01EQ1RlbXBvcmFyeURyYXdlcjpjbG9zZScsXG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb259IGZyb20gJy4uL3NsaWRhYmxlL2luZGV4JztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNRENUZW1wb3JhcnlEcmF3ZXJGb3VuZGF0aW9uIGV4dGVuZHMgTURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIHtcbiAgICAgIGFkZEJvZHlDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUJvZHlDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGlzRHJhd2VyOiAoKSA9PiBmYWxzZSxcbiAgICAgIHVwZGF0ZUNzc1ZhcmlhYmxlOiAoLyogdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBldmVudFRhcmdldEhhc0NsYXNzOiAoLyogdGFyZ2V0OiBFdmVudFRhcmdldCwgY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IC8qIGJvb2xlYW4gKi8gZmFsc2UsXG4gICAgfSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoXG4gICAgICBPYmplY3QuYXNzaWduKE1EQ1RlbXBvcmFyeURyYXdlckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpLFxuICAgICAgTURDVGVtcG9yYXJ5RHJhd2VyRm91bmRhdGlvbi5jc3NDbGFzc2VzLlJPT1QsXG4gICAgICBNRENUZW1wb3JhcnlEcmF3ZXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQU5JTUFUSU5HLFxuICAgICAgTURDVGVtcG9yYXJ5RHJhd2VyRm91bmRhdGlvbi5jc3NDbGFzc2VzLk9QRU4pO1xuXG4gICAgdGhpcy5jb21wb25lbnRDbGlja0hhbmRsZXJfID0gKGV2dCkgPT4ge1xuICAgICAgaWYgKHRoaXMuYWRhcHRlcl8uZXZlbnRUYXJnZXRIYXNDbGFzcyhldnQudGFyZ2V0LCBjc3NDbGFzc2VzLlJPT1QpKSB7XG4gICAgICAgIHRoaXMuY2xvc2UodHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgc3VwZXIuaW5pdCgpO1xuXG4gICAgLy8gTWFrZSBicm93c2VyIGF3YXJlIG9mIGN1c3RvbSBwcm9wZXJ0eSBiZWluZyB1c2VkIGluIHRoaXMgZWxlbWVudC5cbiAgICAvLyBXb3JrYXJvdW5kIGZvciBjZXJ0YWluIHR5cGVzIG9mIGhhcmQtdG8tcmVwcm9kdWNlIGhlaXNlbmJ1Z3MuXG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZSgwKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY29tcG9uZW50Q2xpY2tIYW5kbGVyXyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcblxuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmNvbXBvbmVudENsaWNrSGFuZGxlcl8pO1xuICAgIHRoaXMuZW5hYmxlU2Nyb2xsXygpO1xuICB9XG5cbiAgb3BlbigpIHtcbiAgICB0aGlzLmRpc2FibGVTY3JvbGxfKCk7XG4gICAgLy8gTWFrZSBzdXJlIGN1c3RvbSBwcm9wZXJ0eSB2YWx1ZXMgYXJlIGNsZWFyZWQgYmVmb3JlIHN0YXJ0aW5nLlxuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoJycpO1xuXG4gICAgc3VwZXIub3BlbigpO1xuICB9XG5cbiAgY2xvc2UoKSB7XG4gICAgLy8gTWFrZSBzdXJlIGN1c3RvbSBwcm9wZXJ0eSB2YWx1ZXMgYXJlIGNsZWFyZWQgYmVmb3JlIG1ha2luZyBhbnkgY2hhbmdlcy5cbiAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKCcnKTtcblxuICAgIHN1cGVyLmNsb3NlKCk7XG4gIH1cblxuICBwcmVwYXJlRm9yVG91Y2hFbmRfKCkge1xuICAgIHN1cGVyLnByZXBhcmVGb3JUb3VjaEVuZF8oKTtcblxuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoJycpO1xuICB9XG5cbiAgdXBkYXRlRHJhd2VyXygpIHtcbiAgICBzdXBlci51cGRhdGVEcmF3ZXJfKCk7XG5cbiAgICBjb25zdCBuZXdPcGFjaXR5ID0gTWF0aC5tYXgoMCwgMSArIHRoaXMuZGlyZWN0aW9uXyAqICh0aGlzLm5ld1Bvc2l0aW9uXyAvIHRoaXMuZHJhd2VyV2lkdGhfKSk7XG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShuZXdPcGFjaXR5KTtcbiAgfVxuXG4gIGlzUm9vdFRyYW5zaXRpb25pbmdFdmVudFRhcmdldF8oZWwpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5pc0RyYXdlcihlbCk7XG4gIH1cblxuICBoYW5kbGVUcmFuc2l0aW9uRW5kXyhldnQpIHtcbiAgICBzdXBlci5oYW5kbGVUcmFuc2l0aW9uRW5kXyhldnQpO1xuICAgIGlmICghdGhpcy5pc09wZW5fKSB7XG4gICAgICB0aGlzLmVuYWJsZVNjcm9sbF8oKTtcbiAgICB9XG4gIH07XG5cbiAgZGlzYWJsZVNjcm9sbF8oKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRCb2R5Q2xhc3MoY3NzQ2xhc3Nlcy5TQ1JPTExfTE9DSyk7XG4gIH1cblxuICBlbmFibGVTY3JvbGxfKCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQm9keUNsYXNzKGNzc0NsYXNzZXMuU0NST0xMX0xPQ0spO1xuICB9XG59XG4iLCI8dGVtcGxhdGU+XG4gIDxhc2lkZVxuICAgIDpjbGFzcz1cImNsYXNzZXNcIlxuICAgIGNsYXNzPVwibWRjLXRlbXBvcmFyeS1kcmF3ZXIgbWRjLWRyYXdlci0tdGVtcG9yYXJ5IG1kYy10eXBvZ3JhcGh5XCI+XG4gICAgPG5hdlxuICAgICAgcmVmPVwiZHJhd2VyXCJcbiAgICAgIGNsYXNzPVwibWRjLWRyYXdlcl9fZHJhd2VyXCI+XG4gICAgICA8ZGl2XG4gICAgICAgIHYtaWY9XCJ0b29sYmFyU3BhY2VyXCJcbiAgICAgICAgY2xhc3M9XCJtZGMtZHJhd2VyX190b29sYmFyLXNwYWNlclwiLz5cbiAgICAgIDxzbG90IC8+XG4gICAgPC9uYXY+XG4gIDwvYXNpZGU+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ1RlbXBvcmFyeURyYXdlckZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2RyYXdlci90ZW1wb3JhcnkvZm91bmRhdGlvbidcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnQG1hdGVyaWFsL2RyYXdlci91dGlsJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtdGVtcG9yYXJ5LWRyYXdlcicsXG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ29wZW4nLFxuICAgIGV2ZW50OiAnY2hhbmdlJ1xuICB9LFxuICBwcm9wczoge1xuICAgIG9wZW46IEJvb2xlYW4sXG4gICAgJ3Rvb2xiYXItc3BhY2VyJzogQm9vbGVhblxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7fVxuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBvcGVuOiAnX3JlZnJlc2gnXG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgRk9DVVNBQkxFX0VMRU1FTlRTLFxuICAgICAgT1BBQ0lUWV9WQVJfTkFNRVxuICAgIH0gPSBNRENUZW1wb3JhcnlEcmF3ZXJGb3VuZGF0aW9uLnN0cmluZ3NcblxuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENUZW1wb3JhcnlEcmF3ZXJGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICB9LFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSlcbiAgICAgIH0sXG4gICAgICBoYXNDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgYWRkQm9keUNsYXNzOiBjbGFzc05hbWUgPT4gZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSksXG4gICAgICByZW1vdmVCb2R5Q2xhc3M6IGNsYXNzTmFtZSA9PiBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKSxcbiAgICAgIGV2ZW50VGFyZ2V0SGFzQ2xhc3M6ICh0YXJnZXQsIGNsYXNzTmFtZSkgPT5cbiAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpLFxuICAgICAgaGFzTmVjZXNzYXJ5RG9tOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuJHJlZnMuZHJhd2VyXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICB1dGlsLnJlbWFwRXZlbnQoZXZ0KSxcbiAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgIHV0aWwuYXBwbHlQYXNzaXZlKClcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICB1dGlsLnJlbWFwRXZlbnQoZXZ0KSxcbiAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgIHV0aWwuYXBwbHlQYXNzaXZlKClcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyRHJhd2VySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgdXRpbC5yZW1hcEV2ZW50KGV2dCksXG4gICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICB1dGlsLmFwcGx5UGFzc2l2ZSgpXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyRHJhd2VySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgdXRpbC5yZW1hcEV2ZW50KGV2dCksXG4gICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICB1dGlsLmFwcGx5UGFzc2l2ZSgpXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICByZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5kcmF3ZXIuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5kcmF3ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBnZXREcmF3ZXJXaWR0aDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5kcmF3ZXIub2Zmc2V0V2lkdGhcbiAgICAgIH0sXG4gICAgICBzZXRUcmFuc2xhdGVYOiB2YWx1ZSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgICAgIHV0aWwuZ2V0VHJhbnNmb3JtUHJvcGVydHlOYW1lKCksXG4gICAgICAgICAgdmFsdWUgPT09IG51bGwgPyBudWxsIDogYHRyYW5zbGF0ZVgoJHt2YWx1ZX1weClgXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICB1cGRhdGVDc3NWYXJpYWJsZTogdmFsdWUgPT4ge1xuICAgICAgICBpZiAodXRpbC5zdXBwb3J0c0Nzc0N1c3RvbVByb3BlcnRpZXMoKSkge1xuICAgICAgICAgIHRoaXMuJGVsLnN0eWxlLnNldFByb3BlcnR5KE9QQUNJVFlfVkFSX05BTUUsIHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2V0Rm9jdXNhYmxlRWxlbWVudHM6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMuZHJhd2VyLnF1ZXJ5U2VsZWN0b3JBbGwoRk9DVVNBQkxFX0VMRU1FTlRTKVxuICAgICAgfSxcbiAgICAgIHNhdmVFbGVtZW50VGFiU3RhdGU6IGVsID0+IHtcbiAgICAgICAgdXRpbC5zYXZlRWxlbWVudFRhYlN0YXRlKGVsKVxuICAgICAgfSxcbiAgICAgIHJlc3RvcmVFbGVtZW50VGFiU3RhdGU6IGVsID0+IHtcbiAgICAgICAgdXRpbC5yZXN0b3JlRWxlbWVudFRhYlN0YXRlKGVsKVxuICAgICAgfSxcbiAgICAgIG1ha2VFbGVtZW50VW50YWJiYWJsZTogZWwgPT4ge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgLTEpXG4gICAgICB9LFxuICAgICAgbm90aWZ5T3BlbjogKCkgPT4ge1xuICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCB0cnVlKVxuICAgICAgICB0aGlzLiRlbWl0KCdvcGVuJylcbiAgICAgIH0sXG4gICAgICBub3RpZnlDbG9zZTogKCkgPT4ge1xuICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBmYWxzZSlcbiAgICAgICAgdGhpcy4kZW1pdCgnY2xvc2UnKVxuICAgICAgfSxcbiAgICAgIGlzUnRsOiAoKSA9PiB7XG4gICAgICAgIC8qIGdsb2JhbCBnZXRDb21wdXRlZFN0eWxlICovXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRlbCkuZ2V0UHJvcGVydHlWYWx1ZSgnZGlyZWN0aW9uJykgPT09ICdydGwnXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBpc0RyYXdlcjogZWwgPT4gZWwgPT09IHRoaXMuJHJlZnMuZHJhd2VyXG4gICAgfSlcbiAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuICAgIHRoaXMuX3JlZnJlc2goKVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbnVsbFxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgX3JlZnJlc2goKSB7XG4gICAgICBpZiAodGhpcy5vcGVuKSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24ub3BlbigpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLmNsb3NlKClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8Y29tcG9uZW50XG4gICAgcmVmPVwiZHJhd2VyXCJcbiAgICA6aXM9XCJ0eXBlXCJcbiAgICB2LW1vZGVsPVwib3Blbl9cIlxuICAgIDp0b29sYmFyLXNwYWNlcj1cInRvb2xiYXJTcGFjZXJcIlxuICAgIGNsYXNzPVwibWRjLWRyYXdlclwiXG4gICAgQGNoYW5nZT1cIm9uQ2hhbmdlXCJcbiAgICBAb3Blbj1cIiRlbWl0KCdvcGVuJylcIlxuICAgIEBjbG9zZT1cIiRlbWl0KCdjbG9zZScpXCIgPlxuICAgIDxzbG90IC8+XG4gIDwvY29tcG9uZW50PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBtZGNQZXJtYW5lbnREcmF3ZXIgZnJvbSAnLi9tZGMtcGVybWFuZW50LWRyYXdlci52dWUnXG5pbXBvcnQgbWRjUGVyc2lzdGVudERyYXdlciBmcm9tICcuL21kYy1wZXJzaXN0ZW50LWRyYXdlci52dWUnXG5pbXBvcnQgbWRjVGVtcG9yYXJ5RHJhd2VyIGZyb20gJy4vbWRjLXRlbXBvcmFyeS1kcmF3ZXIudnVlJ1xuXG5jb25zdCBtZWRpYSA9IG5ldyBjbGFzcyB7XG4gIGdldCBzbWFsbCgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5fc21hbGwgfHwgKHRoaXMuX3NtYWxsID0gd2luZG93Lm1hdGNoTWVkaWEoJyhtYXgtd2lkdGg6IDgzOXB4KScpKVxuICAgIClcbiAgfVxuXG4gIGdldCBsYXJnZSgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5fbGFyZ2UgfHwgKHRoaXMuX2xhcmdlID0gd2luZG93Lm1hdGNoTWVkaWEoJyhtaW4td2lkdGg6IDEyMDBweCknKSlcbiAgICApXG4gIH1cbn0oKVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtZHJhd2VyJyxcbiAgY29tcG9uZW50czoge1xuICAgICdtZGMtcGVybWFuZW50LWRyYXdlcic6IG1kY1Blcm1hbmVudERyYXdlcixcbiAgICAnbWRjLXBlcnNpc3RlbnQtZHJhd2VyJzogbWRjUGVyc2lzdGVudERyYXdlcixcbiAgICAnbWRjLXRlbXBvcmFyeS1kcmF3ZXInOiBtZGNUZW1wb3JhcnlEcmF3ZXJcbiAgfSxcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAnb3BlbicsXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgb3BlbjogQm9vbGVhbixcbiAgICBwZXJtYW5lbnQ6IEJvb2xlYW4sXG4gICAgcGVyc2lzdGVudDogQm9vbGVhbixcbiAgICB0ZW1wb3Jhcnk6IEJvb2xlYW4sXG4gICAgZHJhd2VyVHlwZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgdmFsaWRhdG9yOiB2YWwgPT4ge1xuICAgICAgICByZXR1cm4gdmFsIGluIFsndGVtcG9yYXJ5JywgJ3BlcnNpc3RlbnQnLCAncGVybWFuZW50J11cbiAgICAgIH1cbiAgICB9LFxuICAgIHRvb2xiYXJTcGFjZXI6IEJvb2xlYW4sXG4gICAgdG9nZ2xlT246IFN0cmluZyxcbiAgICB0b2dnbGVPblNvdXJjZTogeyB0eXBlOiBPYmplY3QsIHJlcXVpcmVkOiBmYWxzZSB9LFxuICAgIG9wZW5PbjogU3RyaW5nLFxuICAgIG9wZW5PblNvdXJjZTogeyB0eXBlOiBPYmplY3QsIHJlcXVpcmVkOiBmYWxzZSB9LFxuICAgIGNsb3NlT246IFN0cmluZyxcbiAgICBjbG9zZU9uU291cmNlOiB7IHR5cGU6IE9iamVjdCwgcmVxdWlyZWQ6IGZhbHNlIH1cbiAgfSxcbiAgcHJvdmlkZSgpIHtcbiAgICByZXR1cm4geyBtZGNEcmF3ZXI6IHRoaXMgfVxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzbWFsbDogZmFsc2UsXG4gICAgICBsYXJnZTogZmFsc2UsXG4gICAgICBvcGVuXzogZmFsc2VcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgdHlwZSgpIHtcbiAgICAgIGlmICh0aGlzLnBlcm1hbmVudCkge1xuICAgICAgICByZXR1cm4gJ21kYy1wZXJtYW5lbnQtZHJhd2VyJ1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnBlcnNpc3RlbnQpIHtcbiAgICAgICAgcmV0dXJuICdtZGMtcGVyc2lzdGVudC1kcmF3ZXInXG4gICAgICB9IGVsc2UgaWYgKHRoaXMudGVtcG9yYXJ5KSB7XG4gICAgICAgIHJldHVybiAnbWRjLXRlbXBvcmFyeS1kcmF3ZXInXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuZHJhd2VyVHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3Blcm1hbmVudCc6XG4gICAgICAgICAgICByZXR1cm4gJ21kYy1wZXJtYW5lbnQtZHJhd2VyJ1xuICAgICAgICAgIGNhc2UgJ3BlcnNpc3RlbnQnOlxuICAgICAgICAgICAgcmV0dXJuICdtZGMtcGVyc2lzdGVudC1kcmF3ZXInXG4gICAgICAgICAgY2FzZSAndGVtcG9yYXJ5JzpcbiAgICAgICAgICAgIHJldHVybiAnbWRjLXRlbXBvcmFyeS1kcmF3ZXInXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNtYWxsID8gJ21kYy10ZW1wb3JhcnktZHJhd2VyJyA6ICdtZGMtcGVyc2lzdGVudC1kcmF3ZXInXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGlzUGVybWFuZW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGVybWFuZW50IHx8IHRoaXMudHlwZSA9PT0gJ21kYy1wZXJtYW5lbnQtZHJhd2VyJ1xuICAgIH0sXG4gICAgaXNQZXJzaXN0ZW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGVyc2lzdGVudCB8fCB0aGlzLnR5cGUgPT09ICdtZGMtcGVyc2lzdGVudC1kcmF3ZXInXG4gICAgfSxcbiAgICBpc1RlbXBvcmFyeSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRlbXBvcmFyeSB8fCB0aGlzLnR5cGUgPT09ICdtZGMtdGVtcG9yYXJ5LWRyYXdlcidcbiAgICB9LFxuICAgIGlzUmVzcG9uc2l2ZSgpIHtcbiAgICAgIHJldHVybiAhKFxuICAgICAgICB0aGlzLnBlcm1hbmVudCB8fFxuICAgICAgICB0aGlzLnBlcnNpc3RlbnQgfHxcbiAgICAgICAgdGhpcy50ZW1wb3JhcnkgfHxcbiAgICAgICAgdGhpcy5kcmF3ZXJUeXBlXG4gICAgICApXG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIG9wZW46ICdvbk9wZW5fJ1xuICB9LFxuICBjcmVhdGVkKCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubWF0Y2hNZWRpYSkge1xuICAgICAgdGhpcy5zbWFsbCA9IG1lZGlhLnNtYWxsLm1hdGNoZXNcbiAgICAgIHRoaXMubGFyZ2UgPSBtZWRpYS5sYXJnZS5tYXRjaGVzXG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIGlmICh0aGlzLnRvZ2dsZU9uKSB7XG4gICAgICB0aGlzLnRvZ2dsZU9uRXZlbnRTb3VyY2UgPSB0aGlzLnRvZ2dsZU9uU291cmNlIHx8IHRoaXMuJHJvb3RcbiAgICAgIHRoaXMudG9nZ2xlT25FdmVudFNvdXJjZS4kb24odGhpcy50b2dnbGVPbiwgdGhpcy50b2dnbGUpXG4gICAgfVxuICAgIGlmICh0aGlzLm9wZW5Pbikge1xuICAgICAgdGhpcy5vcGVuT25FdmVudFNvdXJjZSA9IHRoaXMub3Blbk9uU291cmNlIHx8IHRoaXMuJHJvb3RcbiAgICAgIHRoaXMub3Blbk9uRXZlbnRTb3VyY2UuJG9uKHRoaXMub3Blbk9uLCB0aGlzLnNob3cpXG4gICAgfVxuICAgIGlmICh0aGlzLmNsb3NlT24pIHtcbiAgICAgIHRoaXMuY2xvc2VPbkV2ZW50U291cmNlID0gdGhpcy5jbG9zZU9uU291cmNlIHx8IHRoaXMuJHJvb3RcbiAgICAgIHRoaXMuY2xvc2VPbkV2ZW50U291cmNlLiRvbih0aGlzLmNsb3NlT24sIHRoaXMuY2xvc2UpXG4gICAgfVxuICAgIG1lZGlhLnNtYWxsLmFkZExpc3RlbmVyKHRoaXMucmVmcmVzaE1lZGlhKVxuICAgIG1lZGlhLmxhcmdlLmFkZExpc3RlbmVyKHRoaXMucmVmcmVzaE1lZGlhKVxuICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHRoaXMucmVmcmVzaE1lZGlhKCkpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgbWVkaWEuc21hbGwucmVtb3ZlTGlzdGVuZXIodGhpcy5yZWZyZXNoTWVkaWEpXG4gICAgbWVkaWEubGFyZ2UucmVtb3ZlTGlzdGVuZXIodGhpcy5yZWZyZXNoTWVkaWEpXG5cbiAgICBpZiAodGhpcy50b2dnbGVPbkV2ZW50U291cmNlKSB7XG4gICAgICB0aGlzLnRvZ2dsZU9uRXZlbnRTb3VyY2UuJG9mZih0aGlzLnRvZ2dsZU9uLCB0aGlzLnRvZ2dsZSlcbiAgICB9XG4gICAgaWYgKHRoaXMub3Blbk9uRXZlbnRTb3VyY2UpIHtcbiAgICAgIHRoaXMub3Blbk9uRXZlbnRTb3VyY2UuJG9mZih0aGlzLm9wZW5PbiwgdGhpcy5zaG93KVxuICAgIH1cbiAgICBpZiAodGhpcy5jbG9zZU9uRXZlbnRTb3VyY2UpIHtcbiAgICAgIHRoaXMuY2xvc2VPbkV2ZW50U291cmNlLiRvZmYodGhpcy5jbG9zZU9uLCB0aGlzLmNsb3NlKVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uT3Blbl8odmFsdWUpIHtcbiAgICAgIHRoaXMuaXNQZXJtYW5lbnQgfHwgKHRoaXMub3Blbl8gPSB2YWx1ZSlcbiAgICB9LFxuICAgIG9uQ2hhbmdlKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBldmVudClcbiAgICAgIHRoaXMuJHJvb3QuJGVtaXQoJ3ZtYTpsYXlvdXQnKVxuICAgIH0sXG4gICAgc2hvdygpIHtcbiAgICAgIHRoaXMub3Blbl8gPSB0cnVlXG4gICAgfSxcbiAgICBjbG9zZSgpIHtcbiAgICAgIHRoaXMuaXNQZXJtYW5lbnQgfHwgKHRoaXMub3Blbl8gPSBmYWxzZSlcbiAgICB9LFxuICAgIHRvZ2dsZSgpIHtcbiAgICAgIHRoaXMuaXNQZXJtYW5lbnQgfHwgKHRoaXMuaXNPcGVuKCkgPyB0aGlzLmNsb3NlKCkgOiB0aGlzLnNob3coKSlcbiAgICB9LFxuICAgIGlzT3BlbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzUGVybWFuZW50IHx8IHRoaXMub3Blbl9cbiAgICB9LFxuICAgIHJlZnJlc2hNZWRpYSgpIHtcbiAgICAgIHRoaXMuc21hbGwgPSBtZWRpYS5zbWFsbC5tYXRjaGVzXG4gICAgICB0aGlzLmxhcmdlID0gbWVkaWEubGFyZ2UubWF0Y2hlc1xuICAgICAgaWYgKHRoaXMuaXNSZXNwb25zaXZlKSB7XG4gICAgICAgIGlmICh0aGlzLmxhcmdlKSB7XG4gICAgICAgICAgdGhpcy5zaG93KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNsb3NlKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJtZGMtZHJhd2VyLWxheW91dFwiPlxuICAgIDxzbG90IC8+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1kcmF3ZXItbGF5b3V0J1xufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxoZWFkZXIgXG4gICAgdi1pZj1cInNob3dcIiBcbiAgICBjbGFzcz1cIm1kYy1kcmF3ZXItaGVhZGVyIG1kYy1kcmF3ZXJfX2hlYWRlclwiPlxuICAgIDxkaXYgY2xhc3M9XCJtZGMtZHJhd2VyX19oZWFkZXItY29udGVudFwiPlxuICAgICAgPHNsb3QgLz5cbiAgICA8L2Rpdj5cbiAgPC9oZWFkZXI+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWRyYXdlci1oZWFkZXInLFxuICBwcm9wczoge1xuICAgIHBlcm1hbmVudDogQm9vbGVhbixcbiAgICBwZXJzaXN0ZW50OiBCb29sZWFuLFxuICAgIHRlbXBvcmFyeTogQm9vbGVhblxuICB9LFxuICBpbmplY3Q6IFsnbWRjRHJhd2VyJ10sXG4gIGNvbXB1dGVkOiB7XG4gICAgc2hvdygpIHtcbiAgICAgIGlmICh0aGlzLnRlbXBvcmFyeSB8fCB0aGlzLnBlcnNpc3RlbnQgfHwgdGhpcy5wZXJtYW5lbnQpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAodGhpcy50ZW1wb3JhcnkgJiYgdGhpcy5tZGNEcmF3ZXIuaXNUZW1wb3JhcnkpIHx8XG4gICAgICAgICAgKHRoaXMucGVyc2lzdGVudCAmJiB0aGlzLm1kY0RyYXdlci5pc1BlcnNpc3RlbnQpIHx8XG4gICAgICAgICAgKHRoaXMucGVybWFuZW50ICYmIHRoaXMubWRjRHJhd2VyLmlzUGVybWFuZW50KVxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxuYXYgXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiIFxuICAgIGNsYXNzPVwibWRjLWRyYXdlci1saXN0IG1kYy1saXN0XCI+XG4gICAgPHNsb3QvPlxuICA8L25hdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtZHJhd2VyLWxpc3QnLFxuICBwcm9wczoge1xuICAgIGRlbnNlOiBCb29sZWFuXG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1saXN0LS1kZW5zZSc6IHRoaXMuZGVuc2VcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8Y3VzdG9tLWxpbmtcbiAgICA6bGluaz1cImxpbmtcIlxuICAgIDpjbGFzcz1cIltjbGFzc2VzLCBpdGVtQ2xhc3Nlc11cIlxuICAgIDpzdHlsZT1cInN0eWxlc1wiXG4gICAgY2xhc3M9XCJtZGMtZHJhd2VyLWl0ZW0gbWRjLWxpc3QtaXRlbVwiXG4gICAgdi1vbj1cIm15bGlzdGVuZXJzXCI+XG4gICAgPHNwYW5cbiAgICAgIHYtaWY9XCJoYXNTdGFydERldGFpbFwiXG4gICAgICBjbGFzcz1cIm1kYy1saXN0LWl0ZW1fX2dyYXBoaWNcIj5cbiAgICAgIDxzbG90IG5hbWU9XCJzdGFydC1kZXRhaWxcIj5cbiAgICAgICAgPGlcbiAgICAgICAgICBjbGFzcz1cIm1hdGVyaWFsLWljb25zXCJcbiAgICAgICAgICBhcmlhLWhpZGRlbj1cInRydWVcIj57eyBzdGFydEljb24gfX08L2k+XG4gICAgICA8L3Nsb3Q+XG4gICAgPC9zcGFuPlxuICAgIDxzbG90Lz5cbiAgPC9jdXN0b20tbGluaz5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBEaXNwYXRjaEV2ZW50TWl4aW4sIEN1c3RvbUxpbmtNaXhpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgeyBSaXBwbGVCYXNlIH0gZnJvbSAnLi4vcmlwcGxlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtZHJhd2VyLWl0ZW0nLFxuICBpbmplY3Q6IFsnbWRjRHJhd2VyJ10sXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbiwgQ3VzdG9tTGlua01peGluXSxcbiAgcHJvcHM6IHtcbiAgICBzdGFydEljb246IFN0cmluZyxcbiAgICB0ZW1wb3JhcnlDbG9zZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9LFxuICAgIGFjdGl2YXRlZDogQm9vbGVhbixcbiAgICBleGFjdEFjdGl2ZUNsYXNzOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnbWRjLWxpc3QtaXRlbS0tYWN0aXZhdGVkJ1xuICAgIH1cbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIG15bGlzdGVuZXJzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4udGhpcy4kbGlzdGVuZXJzLFxuICAgICAgICBjbGljazogZSA9PiB7XG4gICAgICAgICAgdGhpcy5tZGNEcmF3ZXIuaXNUZW1wb3JhcnkgJiZcbiAgICAgICAgICAgIHRoaXMudGVtcG9yYXJ5Q2xvc2UgJiZcbiAgICAgICAgICAgIHRoaXMubWRjRHJhd2VyLmNsb3NlKClcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgaXRlbUNsYXNzZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWRjLWxpc3QtaXRlbS0tYWN0aXZhdGVkJzogdGhpcy5hY3RpdmF0ZWRcbiAgICAgIH1cbiAgICB9LFxuICAgIGhhc1N0YXJ0RGV0YWlsKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhcnRJY29uIHx8IHRoaXMuJHNsb3RzWydzdGFydC1kZXRhaWwnXVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLnJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMpXG4gICAgdGhpcy5yaXBwbGUuaW5pdCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5yaXBwbGUgJiYgdGhpcy5yaXBwbGUuZGVzdHJveSgpXG4gICAgdGhpcy5yaXBwbGUgPSBudWxsXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8aHIgY2xhc3M9XCJtZGMtbGlzdC1kaXZpZGVyXCI+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWRyYXdlci1kaXZpZGVyJ1xufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNEcmF3ZXIgZnJvbSAnLi9tZGMtZHJhd2VyLnZ1ZSdcbmltcG9ydCBtZGNEcmF3ZXJMYXlvdXQgZnJvbSAnLi9tZGMtZHJhd2VyLWxheW91dC52dWUnXG5pbXBvcnQgbWRjRHJhd2VySGVhZGVyIGZyb20gJy4vbWRjLWRyYXdlci1oZWFkZXIudnVlJ1xuaW1wb3J0IG1kY0RyYXdlckxpc3QgZnJvbSAnLi9tZGMtZHJhd2VyLWxpc3QudnVlJ1xuaW1wb3J0IG1kY0RyYXdlckl0ZW0gZnJvbSAnLi9tZGMtZHJhd2VyLWl0ZW0udnVlJ1xuaW1wb3J0IG1kY0RyYXdlckRpdmlkZXIgZnJvbSAnLi9tZGMtZHJhd2VyLWRpdmlkZXIudnVlJ1xuXG5leHBvcnQge1xuICBtZGNEcmF3ZXIsXG4gIG1kY0RyYXdlckxheW91dCxcbiAgbWRjRHJhd2VySGVhZGVyLFxuICBtZGNEcmF3ZXJMaXN0LFxuICBtZGNEcmF3ZXJJdGVtLFxuICBtZGNEcmF3ZXJEaXZpZGVyXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNEcmF3ZXIsXG4gIG1kY0RyYXdlckxheW91dCxcbiAgbWRjRHJhd2VySGVhZGVyLFxuICBtZGNEcmF3ZXJMaXN0LFxuICBtZGNEcmF3ZXJJdGVtLFxuICBtZGNEcmF3ZXJEaXZpZGVyXG59KVxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwibWRjLWVsZXZhdGlvblwiLz5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtZWxldmF0aW9uJyxcbiAgcHJvcHM6IHt9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0VsZXZhdGlvbiBmcm9tICcuL21kYy1lbGV2YXRpb24udnVlJ1xuXG5leHBvcnQgeyBtZGNFbGV2YXRpb24gfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjRWxldmF0aW9uXG59KVxuIiwiPHRlbXBsYXRlPlxuICA8Y3VzdG9tLWJ1dHRvbiBcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgXG4gICAgOnN0eWxlPVwic3R5bGVzXCIgXG4gICAgOmhyZWY9XCJocmVmXCJcbiAgICA6bGluaz1cImxpbmtcIiBcbiAgICBjbGFzcz1cIm1kYy1mYWJcIiBcbiAgICB2LW9uPVwibGlzdGVuZXJzXCIgPlxuICAgIDxzcGFuIGNsYXNzPVwibWRjLWZhYl9faWNvblwiPlxuICAgICAgPHNsb3Q+e3sgaWNvbiB9fTwvc2xvdD5cbiAgICA8L3NwYW4+XG4gIDwvY3VzdG9tLWJ1dHRvbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBEaXNwYXRjaEV2ZW50TWl4aW4sIEN1c3RvbUJ1dHRvbk1peGluIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCB7IFJpcHBsZU1peGluIH0gZnJvbSAnLi4vcmlwcGxlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtZmFiJyxcbiAgbWl4aW5zOiBbRGlzcGF0Y2hFdmVudE1peGluLCBDdXN0b21CdXR0b25NaXhpbiwgUmlwcGxlTWl4aW5dLFxuICBwcm9wczoge1xuICAgIGljb246IFN0cmluZyxcbiAgICBtaW5pOiBCb29sZWFuLFxuICAgIGFic29sdXRlOiBCb29sZWFuLFxuICAgIGZpeGVkOiBCb29sZWFuXG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgJ21hdGVyaWFsLWljb25zJzogdGhpcy5pY29uLFxuICAgICAgICAnbWRjLWZhYi0tbWluaSc6IHRoaXMubWluaSxcbiAgICAgICAgJ21kYy1mYWItLWFic29sdXRlJzogdGhpcy5hYnNvbHV0ZSxcbiAgICAgICAgJ21kYy1mYWItLWZpeGVkJzogdGhpcy5maXhlZFxuICAgICAgfSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgaWNvbigpIHtcbiAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsICdtYXRlcmlhbC1pY29ucycsIHRoaXMuaWNvbilcbiAgICB9LFxuICAgIG1pbmkoKSB7XG4gICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCAnbWRjLWZhYi0tbWluaScsIHRoaXMubWluaSlcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjRkFCIGZyb20gJy4vbWRjLWZhYi52dWUnXG5cbmV4cG9ydCB7IG1kY0ZBQiB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNGQUJcbn0pXG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZXhwb3J0IGNvbnN0IHN0cmluZ3MgPSB7XG4gIFRJTEVTX1NFTEVDVE9SOiAnLm1kYy1ncmlkLWxpc3RfX3RpbGVzJyxcbiAgVElMRV9TRUxFQ1RPUjogJy5tZGMtZ3JpZC10aWxlJyxcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge01EQ0ZvdW5kYXRpb259IGZyb20gJ0BtYXRlcmlhbC9iYXNlL2luZGV4JztcbmltcG9ydCB7c3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNRENHcmlkTGlzdEZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0T2Zmc2V0V2lkdGg6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgZ2V0TnVtYmVyT2ZUaWxlczogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBnZXRPZmZzZXRXaWR0aEZvclRpbGVBdEluZGV4OiAoLyogaW5kZXg6IG51bWJlciAqLykgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBzZXRTdHlsZUZvclRpbGVzRWxlbWVudDogKC8qIHByb3BlcnR5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgIH07XG4gIH1cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDR3JpZExpc3RGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG4gICAgdGhpcy5yZXNpemVIYW5kbGVyXyA9ICgpID0+IHRoaXMuYWxpZ25DZW50ZXIoKTtcbiAgICB0aGlzLnJlc2l6ZUZyYW1lXyA9IDA7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmFsaWduQ2VudGVyKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclJlc2l6ZUhhbmRsZXIodGhpcy5yZXNpemVIYW5kbGVyXyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICB9XG4gIGFsaWduQ2VudGVyKCkge1xuICAgIGlmICh0aGlzLnJlc2l6ZUZyYW1lXyAhPT0gMCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yZXNpemVGcmFtZV8pO1xuICAgIH1cbiAgICB0aGlzLnJlc2l6ZUZyYW1lXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmFsaWduQ2VudGVyXygpO1xuICAgICAgdGhpcy5yZXNpemVGcmFtZV8gPSAwO1xuICAgIH0pO1xuICB9XG4gIGFsaWduQ2VudGVyXygpIHtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5nZXROdW1iZXJPZlRpbGVzKCkgPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBncmlkV2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldE9mZnNldFdpZHRoKCk7XG4gICAgY29uc3QgaXRlbVdpZHRoID0gdGhpcy5hZGFwdGVyXy5nZXRPZmZzZXRXaWR0aEZvclRpbGVBdEluZGV4KDApO1xuICAgIGNvbnN0IHRpbGVzV2lkdGggPSBpdGVtV2lkdGggKiBNYXRoLmZsb29yKGdyaWRXaWR0aCAvIGl0ZW1XaWR0aCk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZUZvclRpbGVzRWxlbWVudCgnd2lkdGgnLCBgJHt0aWxlc1dpZHRofXB4YCk7XG4gIH1cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1ncmlkLWxpc3RcIj5cbiAgICA8dWwgXG4gICAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgXG4gICAgICA6c3R5bGU9XCJzdHlsZXNcIiBcbiAgICAgIGNsYXNzPVwibWRjLWdyaWQtbGlzdF9fdGlsZXNcIj5cbiAgICAgIDxzbG90Lz5cbiAgICA8L3VsPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDR3JpZExpc3RGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9ncmlkLWxpc3QvZm91bmRhdGlvbidcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWdyaWQtbGlzdCcsXG4gIHByb3BzOiB7XG4gICAgd2lkdGg6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgcmF0aW86IFN0cmluZyxcbiAgICAnbmFycm93LWd1dHRlcic6IEJvb2xlYW4sXG4gICAgJ2hlYWRlci1jYXB0aW9uJzogQm9vbGVhbixcbiAgICAnaWNvbi1hbGlnbi1zdGFydCc6IEJvb2xlYW4sXG4gICAgJ2ljb24tYWxpZ24tZW5kJzogQm9vbGVhbixcbiAgICAnd2l0aC1zdXBwb3J0LXRleHQnOiBCb29sZWFuLFxuICAgIGludGVyYWN0aXZlOiBCb29sZWFuXG4gIH0sXG4gIHByb3ZpZGUoKSB7XG4gICAgcmV0dXJuIHsgbWRjR3JpZDogdGhpcyB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcygpIHtcbiAgICAgIGxldCBjbGFzc2VzID0ge31cblxuICAgICAgY2xhc3Nlc1snbWRjLWdyaWQtbGlzdC0tdGlsZS1ndXR0ZXItMSddID0gdGhpcy5uYXJyb3dHdXR0ZXJcbiAgICAgIGNsYXNzZXNbJ21kYy1ncmlkLWxpc3QtLWhlYWRlci1jYXB0aW9uJ10gPSB0aGlzLmhlYWRlckNhcHRpb25cbiAgICAgIGNsYXNzZXNbYG1kYy1ncmlkLWxpc3QtLXRpbGUtYXNwZWN0LSR7dGhpcy5yYXRpb31gXSA9IHRoaXMucmF0aW9cbiAgICAgIGNsYXNzZXNbJ21kYy1ncmlkLWxpc3QtLXdpdGgtaWNvbi1hbGlnbi1zdGFydCddID0gdGhpcy5pY29uQWxpZ25TdGFydFxuICAgICAgY2xhc3Nlc1snbWRjLWdyaWQtbGlzdC0td2l0aC1pY29uLWFsaWduLWVuZCddID0gdGhpcy5pY29uQWxpZ25FbmRcbiAgICAgIGNsYXNzZXNbJ21kYy1ncmlkLWxpc3QtLXR3b2xpbmUtY2FwdGlvbiddID0gdGhpcy53aXRoU3VwcG9ydFRleHRcbiAgICAgIGNsYXNzZXNbJ21kYy1ncmlkLWxpc3QtLW5vbi1pbnRlcmFjdGl2ZSddID0gIXRoaXMuaW50ZXJhY3RpdmVcblxuICAgICAgcmV0dXJuIGNsYXNzZXNcbiAgICB9LFxuICAgIHN0eWxlcygpIHtcbiAgICAgIHZhciBkZWZhdWx0V2lkdGggPSAyMDBcbiAgICAgIHJldHVybiB7XG4gICAgICAgICctLW1kYy1ncmlkLWxpc3QtdGlsZS13aWR0aCc6IGAke3RoaXMud2lkdGggfHwgZGVmYXVsdFdpZHRofXB4YFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDR3JpZExpc3RGb3VuZGF0aW9uKHtcbiAgICAgIGdldE9mZnNldFdpZHRoOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiRlbC5vZmZzZXRXaWR0aFxuICAgICAgfSxcbiAgICAgIGdldE51bWJlck9mVGlsZXM6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgTURDR3JpZExpc3RGb3VuZGF0aW9uLnN0cmluZ3MuVElMRV9TRUxFQ1RPUlxuICAgICAgICApLmxlbmd0aFxuICAgICAgfSxcbiAgICAgIGdldE9mZnNldFdpZHRoRm9yVGlsZUF0SW5kZXg6IGluZGV4ID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgTURDR3JpZExpc3RGb3VuZGF0aW9uLnN0cmluZ3MuVElMRV9TRUxFQ1RPUlxuICAgICAgICApW2luZGV4XS5vZmZzZXRXaWR0aFxuICAgICAgfSxcbiAgICAgIHNldFN0eWxlRm9yVGlsZXNFbGVtZW50OiAocHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgTURDR3JpZExpc3RGb3VuZGF0aW9uLnN0cmluZ3MuVElMRVNfU0VMRUNUT1JcbiAgICAgICAgKS5zdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGxpIFxuICAgIDpjbGFzcz1cIltjbGFzc2VzLCBpdGVtQ2xhc3Nlc11cIlxuICAgIDpzdHlsZT1cInN0eWxlc1wiIFxuICAgIDp0YWJpbmRleD1cImlzSW50ZXJhY3RpdmUgPyAnMCcgOiB1bmRlZmluZWRcIlxuICAgIGNsYXNzPVwibWRjLWdyaWQtdGlsZVwiXG4gICAgdi1vbj1cImlzSW50ZXJhY3RpdmUgPyBsaXN0ZW5lcnMgOiBjbGlja0xpc3RlbmVyXCI+XG4gICAgPGRpdiBcbiAgICAgIHYtaWY9XCJjb3ZlclwiIFxuICAgICAgY2xhc3M9XCJtZGMtZ3JpZC10aWxlX19wcmltYXJ5XCI+XG4gICAgICA8ZGl2IFxuICAgICAgICA6c3R5bGU9XCJ7IGJhY2tncm91bmRJbWFnZTogJ3VybCgnICsgc3JjICsgJyknIH1cIlxuICAgICAgICBjbGFzcz1cIm1kYy1ncmlkLXRpbGVfX3ByaW1hcnktY29udGVudFwiLz5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IFxuICAgICAgdi1lbHNlIFxuICAgICAgY2xhc3M9XCJtZGMtZ3JpZC10aWxlX19wcmltYXJ5XCI+XG4gICAgICA8aW1nIFxuICAgICAgICA6c3JjPVwic3JjXCIgXG4gICAgICAgIGNsYXNzPVwibWRjLWdyaWQtdGlsZV9fcHJpbWFyeS1jb250ZW50XCIgPlxuICAgIDwvZGl2PlxuICAgIDxzcGFuIFxuICAgICAgdi1pZj1cInRpdGxlIHx8IHN1cHBvcnRUZXh0XCIgXG4gICAgICBjbGFzcz1cIm1kYy1ncmlkLXRpbGVfX3NlY29uZGFyeVwiPlxuICAgICAgPGkgXG4gICAgICAgIHYtaWY9XCJpY29uXCIgXG4gICAgICAgIGNsYXNzPVwibWRjLWdyaWQtdGlsZV9faWNvbiBtYXRlcmlhbC1pY29uc1wiPnt7IGljb24gfX08L2k+XG4gICAgICA8c3BhbiBcbiAgICAgICAgdi1pZj1cInRpdGxlXCIgXG4gICAgICAgIGNsYXNzPVwibWRjLWdyaWQtdGlsZV9fdGl0bGVcIj57eyB0aXRsZSB9fTwvc3Bhbj5cbiAgICAgIDxzcGFuIFxuICAgICAgICB2LWlmPVwic3VwcG9ydFRleHRcIiBcbiAgICAgICAgY2xhc3M9XCJtZGMtZ3JpZC10aWxlX19zdXBwb3J0LXRleHRcIj57eyBzdXBwb3J0VGV4dCB9fTwvc3Bhbj5cbiAgICA8L3NwYW4+XG4gIDwvbGk+XG48L3RlbXBsYXRlPlxuXG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBEaXNwYXRjaEV2ZW50TWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IHsgUmlwcGxlQmFzZSB9IGZyb20gJy4uL3JpcHBsZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWdyaWQtdGlsZScsXG4gIGluamVjdDogWydtZGNHcmlkJ10sXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbl0sXG4gIHByb3BzOiB7XG4gICAgc3JjOiBTdHJpbmcsXG4gICAgY292ZXI6IEJvb2xlYW4sXG4gICAgaWNvbjogU3RyaW5nLFxuICAgIHRpdGxlOiBTdHJpbmcsXG4gICAgJ3N1cHBvcnQtdGV4dCc6IFN0cmluZyxcbiAgICBzZWxlY3RlZDogQm9vbGVhbixcbiAgICBhY3RpdmF0ZWQ6IEJvb2xlYW5cbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGNsaWNrTGlzdGVuZXIoKSB7XG4gICAgICByZXR1cm4geyBjbGljazogZSA9PiB0aGlzLmRpc3BhdGNoRXZlbnQoZSkgfVxuICAgIH0sXG4gICAgaXRlbUNsYXNzZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWRjLWdyaWQtdGlsZS0tc2VsZWN0ZWQnOiB0aGlzLnNlbGVjdGVkLFxuICAgICAgICAnbWRjLWdyaWQtdGlsZS0tYWN0aXZhdGVkJzogdGhpcy5hY3RpdmF0ZWRcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzSW50ZXJhY3RpdmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZGNHcmlkICYmIHRoaXMubWRjR3JpZC5pbnRlcmFjdGl2ZVxuICAgIH0sXG4gICAgaGFzU3RhcnREZXRhaWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGFydEljb24gfHwgdGhpcy4kc2xvdHNbJ3N0YXJ0LWRldGFpbCddXG4gICAgfSxcbiAgICBoYXNFbmREZXRhaWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmRJY29uIHx8IHRoaXMuJHNsb3RzWydlbmQtZGV0YWlsJ11cbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgaXNJbnRlcmFjdGl2ZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYWRkUmlwcGxlKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVtb3ZlUmlwcGxlKClcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5pc0ludGVyYWN0aXZlICYmIHRoaXMuYWRkUmlwcGxlKClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbW92ZVJpcHBsZSgpXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBhZGRSaXBwbGUoKSB7XG4gICAgICBpZiAoIXRoaXMucmlwcGxlKSB7XG4gICAgICAgIGxldCByaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzKVxuICAgICAgICByaXBwbGUuaW5pdCgpXG4gICAgICAgIHRoaXMucmlwcGxlID0gcmlwcGxlXG4gICAgICB9XG4gICAgfSxcbiAgICByZW1vdmVSaXBwbGUoKSB7XG4gICAgICBpZiAodGhpcy5yaXBwbGUpIHtcbiAgICAgICAgbGV0IHJpcHBsZSA9IHRoaXMucmlwcGxlXG4gICAgICAgIHRoaXMucmlwcGxlID0gbnVsbFxuICAgICAgICByaXBwbGUuZGVzdHJveSgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0dyaWRMaXN0IGZyb20gJy4vbWRjLWdyaWQtbGlzdC52dWUnXG5pbXBvcnQgbWRjR3JpZFRpbGUgZnJvbSAnLi9tZGMtZ3JpZC10aWxlLnZ1ZSdcblxuZXhwb3J0IHsgbWRjR3JpZExpc3QsIG1kY0dyaWRUaWxlIH1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY0dyaWRMaXN0LFxuICBtZGNHcmlkVGlsZVxufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPHNwYW4gXG4gICAgOmNsYXNzPVwieydtYXRlcmlhbC1pY29ucyc6ISFpY29ufVwiIFxuICAgIGNsYXNzPVwibWRjLWljb24gbWRjLWljb24tLW1hdGVyaWFsXCI+XG4gICAgPHNsb3Q+e3sgaWNvbiB9fTwvc2xvdD5cbiAgPC9zcGFuPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1pY29uJyxcbiAgcHJvcHM6IHtcbiAgICBpY29uOiBTdHJpbmdcbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcclxuaW1wb3J0IG1kY0ljb24gZnJvbSAnLi9tZGMtaWNvbi52dWUnXHJcblxyXG5leHBvcnQgeyBtZGNJY29uIH1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xyXG4gIG1kY0ljb25cclxufSlcclxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBJY29uIFRvZ2dsZS4gUHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBtYW5hZ2luZ1xuICogLSBjbGFzc2VzXG4gKiAtIGRvbVxuICogLSBpbm5lciB0ZXh0XG4gKiAtIGV2ZW50IGhhbmRsZXJzXG4gKiAtIGV2ZW50IGRpc3BhdGNoXG4gKlxuICogQWRkaXRpb25hbGx5LCBwcm92aWRlcyB0eXBlIGluZm9ybWF0aW9uIGZvciB0aGUgYWRhcHRlciB0byB0aGUgQ2xvc3VyZVxuICogY29tcGlsZXIuXG4gKlxuICogSW1wbGVtZW50IHRoaXMgYWRhcHRlciBmb3IgeW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlIHRvIGRlbGVnYXRlIHVwZGF0ZXMgdG9cbiAqIHRoZSBjb21wb25lbnQgaW4geW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlLiBTZWUgYXJjaGl0ZWN0dXJlIGRvY3VtZW50YXRpb25cbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2NvZGUvYXJjaGl0ZWN0dXJlLm1kXG4gKlxuICogQHJlY29yZFxuICovXG5cbmNsYXNzIE1EQ0ljb25Ub2dnbGVBZGFwdGVyIHtcbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHshRXZlbnRMaXN0ZW5lcn0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHshRXZlbnRMaXN0ZW5lcn0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAqL1xuICBzZXRUZXh0KHRleHQpIHt9XG5cbiAgLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbiAgZ2V0VGFiSW5kZXgoKSB7fVxuXG4gIC8qKiBAcGFyYW0ge251bWJlcn0gdGFiSW5kZXggKi9cbiAgc2V0VGFiSW5kZXgodGFiSW5kZXgpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldEF0dHIobmFtZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRBdHRyKG5hbWUsIHZhbHVlKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAqL1xuICBybUF0dHIobmFtZSkge31cblxuICAvKiogQHBhcmFtIHshSWNvblRvZ2dsZUV2ZW50fSBldnREYXRhICovXG4gIG5vdGlmeUNoYW5nZShldnREYXRhKSB7fVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGlzT246IGJvb2xlYW4sXG4gKiB9fVxuICovXG5sZXQgSWNvblRvZ2dsZUV2ZW50O1xuXG5leHBvcnQge01EQ0ljb25Ub2dnbGVBZGFwdGVyLCBJY29uVG9nZ2xlRXZlbnR9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgUk9PVDogJ21kYy1pY29uLXRvZ2dsZScsXG4gIERJU0FCTEVEOiAnbWRjLWljb24tdG9nZ2xlLS1kaXNhYmxlZCcsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIERBVEFfVE9HR0xFX09OOiAnZGF0YS10b2dnbGUtb24nLFxuICBEQVRBX1RPR0dMRV9PRkY6ICdkYXRhLXRvZ2dsZS1vZmYnLFxuICBBUklBX1BSRVNTRUQ6ICdhcmlhLXByZXNzZWQnLFxuICBBUklBX0RJU0FCTEVEOiAnYXJpYS1kaXNhYmxlZCcsXG4gIEFSSUFfTEFCRUw6ICdhcmlhLWxhYmVsJyxcbiAgQ0hBTkdFX0VWRU5UOiAnTURDSWNvblRvZ2dsZTpjaGFuZ2UnLFxufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ0ljb25Ub2dnbGVBZGFwdGVyLCBJY29uVG9nZ2xlRXZlbnR9IGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDSWNvblRvZ2dsZUFkYXB0ZXI+fVxuICovXG5jbGFzcyBNRENJY29uVG9nZ2xlRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBzZXRUZXh0OiAoLyogdGV4dDogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGdldFRhYkluZGV4OiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIHNldFRhYkluZGV4OiAoLyogdGFiSW5kZXg6IG51bWJlciAqLykgPT4ge30sXG4gICAgICBnZXRBdHRyOiAoLyogbmFtZTogc3RyaW5nICovKSA9PiAvKiBzdHJpbmcgKi8gJycsXG4gICAgICBzZXRBdHRyOiAoLyogbmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJtQXR0cjogKC8qIG5hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBub3RpZnlDaGFuZ2U6ICgvKiBldnREYXRhOiBJY29uVG9nZ2xlRXZlbnQgKi8pID0+IHt9LFxuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENJY29uVG9nZ2xlRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMub25fID0gZmFsc2U7XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5kaXNhYmxlZF8gPSBmYWxzZTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuc2F2ZWRUYWJJbmRleF8gPSAtMTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7P0ljb25Ub2dnbGVTdGF0ZX0gKi9cbiAgICB0aGlzLnRvZ2dsZU9uRGF0YV8gPSBudWxsO1xuXG4gICAgLyoqIEBwcml2YXRlIHs/SWNvblRvZ2dsZVN0YXRlfSAqL1xuICAgIHRoaXMudG9nZ2xlT2ZmRGF0YV8gPSBudWxsO1xuXG4gICAgdGhpcy5jbGlja0hhbmRsZXJfID0gLyoqIEBwcml2YXRlIHshRXZlbnRMaXN0ZW5lcn0gKi8gKFxuICAgICAgKCkgPT4gdGhpcy50b2dnbGVGcm9tRXZ0XygpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmlzSGFuZGxpbmdLZXlkb3duXyA9IGZhbHNlO1xuXG4gICAgdGhpcy5rZXlkb3duSGFuZGxlcl8gPSAvKiogQHByaXZhdGUgeyFFdmVudExpc3RlbmVyfSAqLyAoKC8qKiBAdHlwZSB7IUtleWJvYXJkS2V5fSAqLyBldnQpID0+IHtcbiAgICAgIGlmIChpc1NwYWNlKGV2dCkpIHtcbiAgICAgICAgdGhpcy5pc0hhbmRsaW5nS2V5ZG93bl8gPSB0cnVlO1xuICAgICAgICByZXR1cm4gZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmtleXVwSGFuZGxlcl8gPSAvKiogQHByaXZhdGUgeyFFdmVudExpc3RlbmVyfSAqLyAoKC8qKiBAdHlwZSB7IUtleWJvYXJkS2V5fSAqLyBldnQpID0+IHtcbiAgICAgIGlmIChpc1NwYWNlKGV2dCkpIHtcbiAgICAgICAgdGhpcy5pc0hhbmRsaW5nS2V5ZG93bl8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy50b2dnbGVGcm9tRXZ0XygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLnJlZnJlc2hUb2dnbGVEYXRhKCk7XG4gICAgdGhpcy5zYXZlZFRhYkluZGV4XyA9IHRoaXMuYWRhcHRlcl8uZ2V0VGFiSW5kZXgoKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXl1cCcsIHRoaXMua2V5dXBIYW5kbGVyXyk7XG4gIH1cblxuICByZWZyZXNoVG9nZ2xlRGF0YSgpIHtcbiAgICBjb25zdCB7REFUQV9UT0dHTEVfT04sIERBVEFfVE9HR0xFX09GRn0gPSBNRENJY29uVG9nZ2xlRm91bmRhdGlvbi5zdHJpbmdzO1xuICAgIHRoaXMudG9nZ2xlT25EYXRhXyA9IHRoaXMucGFyc2VKc29uRGF0YUF0dHJfKERBVEFfVE9HR0xFX09OKTtcbiAgICB0aGlzLnRvZ2dsZU9mZkRhdGFfID0gdGhpcy5wYXJzZUpzb25EYXRhQXR0cl8oREFUQV9UT0dHTEVfT0ZGKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXlkb3duJywgdGhpcy5rZXlkb3duSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5dXAnLCB0aGlzLmtleXVwSGFuZGxlcl8pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHRvZ2dsZUZyb21FdnRfKCkge1xuICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgY29uc3Qge29uXzogaXNPbn0gPSB0aGlzO1xuICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2hhbmdlKC8qKiBAdHlwZSB7IUljb25Ub2dnbGVFdmVudH0gKi8gKHtpc09ufSkpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzT24oKSB7XG4gICAgcmV0dXJuIHRoaXMub25fO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbj19IGlzT24gKi9cbiAgdG9nZ2xlKGlzT24gPSAhdGhpcy5vbl8pIHtcbiAgICB0aGlzLm9uXyA9IGlzT247XG5cbiAgICBjb25zdCB7QVJJQV9MQUJFTCwgQVJJQV9QUkVTU0VEfSA9IE1EQ0ljb25Ub2dnbGVGb3VuZGF0aW9uLnN0cmluZ3M7XG5cbiAgICBpZiAodGhpcy5vbl8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cihBUklBX1BSRVNTRUQsICd0cnVlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cihBUklBX1BSRVNTRUQsICdmYWxzZScpO1xuICAgIH1cblxuICAgIGNvbnN0IHtjc3NDbGFzczogY2xhc3NUb1JlbW92ZX0gPVxuICAgICAgICB0aGlzLm9uXyA/IHRoaXMudG9nZ2xlT2ZmRGF0YV8gOiB0aGlzLnRvZ2dsZU9uRGF0YV87XG5cbiAgICBpZiAoY2xhc3NUb1JlbW92ZSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjbGFzc1RvUmVtb3ZlKTtcbiAgICB9XG5cbiAgICBjb25zdCB7Y29udGVudCwgbGFiZWwsIGNzc0NsYXNzfSA9IHRoaXMub25fID8gdGhpcy50b2dnbGVPbkRhdGFfIDogdGhpcy50b2dnbGVPZmZEYXRhXztcblxuICAgIGlmIChjc3NDbGFzcykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjb250ZW50KSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldFRleHQoY29udGVudCk7XG4gICAgfVxuICAgIGlmIChsYWJlbCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKEFSSUFfTEFCRUwsIGxhYmVsKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFBdHRyXG4gICAqIEByZXR1cm4geyFJY29uVG9nZ2xlU3RhdGV9XG4gICAqL1xuICBwYXJzZUpzb25EYXRhQXR0cl8oZGF0YUF0dHIpIHtcbiAgICBjb25zdCB2YWwgPSB0aGlzLmFkYXB0ZXJfLmdldEF0dHIoZGF0YUF0dHIpO1xuICAgIGlmICghdmFsKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiAvKiogQHR5cGUgeyFJY29uVG9nZ2xlU3RhdGV9ICovIChKU09OLnBhcnNlKHZhbCkpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzYWJsZWRfO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gaXNEaXNhYmxlZCAqL1xuICBzZXREaXNhYmxlZChpc0Rpc2FibGVkKSB7XG4gICAgdGhpcy5kaXNhYmxlZF8gPSBpc0Rpc2FibGVkO1xuXG4gICAgY29uc3Qge0RJU0FCTEVEfSA9IE1EQ0ljb25Ub2dnbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgY29uc3Qge0FSSUFfRElTQUJMRUR9ID0gTURDSWNvblRvZ2dsZUZvdW5kYXRpb24uc3RyaW5ncztcblxuICAgIGlmICh0aGlzLmRpc2FibGVkXykge1xuICAgICAgdGhpcy5zYXZlZFRhYkluZGV4XyA9IHRoaXMuYWRhcHRlcl8uZ2V0VGFiSW5kZXgoKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0VGFiSW5kZXgoLTEpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKEFSSUFfRElTQUJMRUQsICd0cnVlJyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKERJU0FCTEVEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRUYWJJbmRleCh0aGlzLnNhdmVkVGFiSW5kZXhfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucm1BdHRyKEFSSUFfRElTQUJMRUQpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhESVNBQkxFRCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzS2V5Ym9hcmRBY3RpdmF0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNIYW5kbGluZ0tleWRvd25fO1xuICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAga2V5OiBzdHJpbmcsXG4gKiAgIGtleUNvZGU6IG51bWJlclxuICogfX1cbiAqL1xubGV0IEtleWJvYXJkS2V5O1xuXG4vKipcbiAqIEBwYXJhbSB7IUtleWJvYXJkS2V5fSBrZXlib2FyZEtleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNTcGFjZShrZXlib2FyZEtleSkge1xuICByZXR1cm4ga2V5Ym9hcmRLZXkua2V5ID09PSAnU3BhY2UnIHx8IGtleWJvYXJkS2V5LmtleUNvZGUgPT09IDMyO1xufVxuXG5cbi8qKiBAcmVjb3JkICovXG5jbGFzcyBJY29uVG9nZ2xlU3RhdGUge31cblxuLyoqXG4gKiBUaGUgYXJpYS1sYWJlbCB2YWx1ZSBvZiB0aGUgaWNvbiB0b2dnbGUsIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBhcmlhLWxhYmVsLlxuICogQGV4cG9ydCB7c3RyaW5nfHVuZGVmaW5lZH1cbiAqL1xuSWNvblRvZ2dsZVN0YXRlLnByb3RvdHlwZS5sYWJlbDtcblxuLyoqXG4gKiBUaGUgdGV4dCBmb3IgdGhlIGljb24gdG9nZ2xlLCBvciB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gdGV4dC5cbiAqIEBleHBvcnQge3N0cmluZ3x1bmRlZmluZWR9XG4gKi9cbkljb25Ub2dnbGVTdGF0ZS5wcm90b3R5cGUuY29udGVudDtcblxuLyoqXG4gKiBUaGUgQ1NTIGNsYXNzIHRvIGFkZCB0byB0aGUgaWNvbiB0b2dnbGUsIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBDU1MgY2xhc3MuXG4gKiBAZXhwb3J0IHtzdHJpbmd8dW5kZWZpbmVkfVxuICovXG5JY29uVG9nZ2xlU3RhdGUucHJvdG90eXBlLmNzc0NsYXNzO1xuXG5leHBvcnQgZGVmYXVsdCBNRENJY29uVG9nZ2xlRm91bmRhdGlvbjtcbiIsIjx0ZW1wbGF0ZT5cbiAgPHNwYW4gXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiIFxuICAgIDpzdHlsZT1cInN0eWxlc1wiIFxuICAgIDp0YWJpbmRleD1cInRhYkluZGV4XCJcbiAgICA6ZGF0YS10b2dnbGUtb249XCJ0b2dnbGVPbkRhdGFcIiBcbiAgICA6ZGF0YS10b2dnbGUtb2ZmPVwidG9nZ2xlT2ZmRGF0YVwiXG4gICAgY2xhc3M9XCJtZGMtaWNvbi10b2dnbGVcIlxuICAgIHJvbGU9XCJidXR0b25cIlxuICAgIGFyaWEtcHJlc3NlZD1cImZhbHNlXCI+XG4gICAgPGkgXG4gICAgICA6Y2xhc3M9XCJpY29uQ2xhc3Nlc1wiIFxuICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCI+e3sgdGV4dCB9fTwvaT5cbiAgPC9zcGFuPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNRENJY29uVG9nZ2xlRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvaWNvbi10b2dnbGUvZm91bmRhdGlvbidcbmltcG9ydCB7IFJpcHBsZUJhc2UgfSBmcm9tICcuLi9yaXBwbGUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1pY29uLXRvZ2dsZScsXG4gIHByb3BzOiB7XG4gICAgdG9nZ2xlT246IFtTdHJpbmcsIE9iamVjdF0sXG4gICAgdG9nZ2xlT2ZmOiBbU3RyaW5nLCBPYmplY3RdLFxuICAgIHZhbHVlOiBCb29sZWFuLFxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgIGFjY2VudDogQm9vbGVhblxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgICdtZGMtaWNvbi10b2dnbGUtLWFjY2VudCc6IHRoaXMuYWNjZW50XG4gICAgICB9LFxuICAgICAgc3R5bGVzOiB7fSxcbiAgICAgIGljb25DbGFzc2VzOiB7fSxcbiAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgdGV4dDogJydcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgdG9nZ2xlT25EYXRhKCkge1xuICAgICAgbGV0IHRvZ2dsZSA9IHRoaXMudG9nZ2xlT25cbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRvZ2dsZSAmJlxuICAgICAgICBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICB0eXBlb2YgdG9nZ2xlID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgY29udGVudDogdG9nZ2xlLFxuICAgICAgICAgICAgICAgIGNzc0NsYXNzOiAnbWF0ZXJpYWwtaWNvbnMnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRvZ2dsZS5pY29uIHx8IHRvZ2dsZS5jb250ZW50LFxuICAgICAgICAgICAgICAgIGxhYmVsOiB0b2dnbGUubGFiZWwsXG4gICAgICAgICAgICAgICAgY3NzQ2xhc3M6IHRvZ2dsZS5pY29uID8gJ21hdGVyaWFsLWljb25zJyA6IHRvZ2dsZS5jc3NDbGFzc1xuICAgICAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIClcbiAgICB9LFxuICAgIHRvZ2dsZU9mZkRhdGEoKSB7XG4gICAgICBsZXQgdG9nZ2xlID0gdGhpcy50b2dnbGVPZmZcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRvZ2dsZSAmJlxuICAgICAgICBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICB0eXBlb2YgdG9nZ2xlID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgY29udGVudDogdG9nZ2xlLFxuICAgICAgICAgICAgICAgIGNzc0NsYXNzOiAnbWF0ZXJpYWwtaWNvbnMnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRvZ2dsZS5pY29uIHx8IHRvZ2dsZS5jb250ZW50LFxuICAgICAgICAgICAgICAgIGxhYmVsOiB0b2dnbGUubGFiZWwsXG4gICAgICAgICAgICAgICAgY3NzQ2xhc3M6IHRvZ2dsZS5pY29uID8gJ21hdGVyaWFsLWljb25zJyA6IHRvZ2dsZS5jc3NDbGFzc1xuICAgICAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIClcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgdmFsdWUodmFsdWUpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24udG9nZ2xlKHZhbHVlKVxuICAgIH0sXG4gICAgZGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uc2V0RGlzYWJsZWQoZGlzYWJsZWQpXG4gICAgfSxcbiAgICB0b2dnbGVPbkRhdGEoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLnJlZnJlc2hUb2dnbGVEYXRhKClcbiAgICB9LFxuICAgIHRvZ2dsZU9mZkRhdGEoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLnJlZnJlc2hUb2dnbGVEYXRhKClcbiAgICB9LFxuICAgIGFjY2VudCh2YWx1ZSkge1xuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21kYy1pY29uLXRvZ2dsZS0tc2Vjb25kYXJ5JywgdmFsdWUpXG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENJY29uVG9nZ2xlRm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHRoaXMuJHNldCh0aGlzLmljb25DbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRkZWxldGUodGhpcy5pY29uQ2xhc3NlcywgY2xhc3NOYW1lKSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PlxuICAgICAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PlxuICAgICAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciksXG4gICAgICBzZXRUZXh0OiB0ZXh0ID0+IHtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dFxuICAgICAgfSxcbiAgICAgIGdldFRhYkluZGV4OiAoKSA9PiB0aGlzLnRhYkluZGV4LFxuICAgICAgc2V0VGFiSW5kZXg6IHRhYkluZGV4ID0+IHtcbiAgICAgICAgdGhpcy50YWJJbmRleCA9IHRhYkluZGV4XG4gICAgICB9LFxuICAgICAgZ2V0QXR0cjogKG5hbWUsIHZhbHVlKSA9PiB0aGlzLiRlbC5nZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpLFxuICAgICAgc2V0QXR0cjogKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSlcbiAgICAgIH0sXG4gICAgICBybUF0dHI6IG5hbWUgPT4ge1xuICAgICAgICB0aGlzLiRlbC5yZW1vdmVBdHRyaWJ1dGUobmFtZSlcbiAgICAgIH0sXG4gICAgICBub3RpZnlDaGFuZ2U6IGV2dERhdGEgPT4ge1xuICAgICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIGV2dERhdGEuaXNPbilcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgICB0aGlzLmZvdW5kYXRpb24udG9nZ2xlKHRoaXMudmFsdWUpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHRoaXMuZGlzYWJsZWQpXG5cbiAgICB0aGlzLnJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMsIHtcbiAgICAgIGlzVW5ib3VuZGVkOiAoKSA9PiB0cnVlLFxuICAgICAgaXNTdXJmYWNlQWN0aXZlOiAoKSA9PiB0aGlzLmZvdW5kYXRpb24uaXNLZXlib2FyZEFjdGl2YXRlZCgpXG4gICAgfSlcbiAgICB0aGlzLnJpcHBsZS5pbml0KClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gICAgdGhpcy5yaXBwbGUuZGVzdHJveSgpXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjSUNvblRvZ2dsZSBmcm9tICcuL21kYy1pY29uLXRvZ2dsZS52dWUnXG5cbmV4cG9ydCB7IG1kY0lDb25Ub2dnbGUgfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjSUNvblRvZ2dsZVxufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1sYXlvdXQtYXBwXCI+XG5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLWxheW91dC1hcHAtLXRvb2xiYXItd3JhcHBlclwiPlxuICAgICAgPHNsb3QgbmFtZT1cInRvb2xiYXJcIiAvPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cIm1kYy1sYXlvdXQtYXBwLS1tYWluLWNvbnRhaW5lclwiPlxuXG4gICAgICA8ZGl2IGNsYXNzPVwibWRjLWxheW91dC1hcHAtLWRyYXdlci13cmFwcGVyXCI+XG4gICAgICAgIDxzbG90IG5hbWU9XCJkcmF3ZXJcIiAvPlxuICAgICAgPC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtbGF5b3V0LWFwcC0tY29udGVudC13cmFwcGVyXCI+XG4gICAgICAgIDxzbG90IC8+XG4gICAgICA8L2Rpdj5cblxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbGF5b3V0LWFwcCdcbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjTGF5b3V0QXBwIGZyb20gJy4vbWRjLWxheW91dC1hcHAudnVlJ1xuXG5leHBvcnQgeyBtZGNMYXlvdXRBcHAgfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjTGF5b3V0QXBwXG59KVxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IDpjbGFzcz1cImNsYXNzZXNcIj5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLWxheW91dC1ncmlkX19pbm5lclwiPlxuICAgICAgPHNsb3QvPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbGF5b3V0LWdyaWQnLFxuICBwcm9wczoge1xuICAgICdmaXhlZC1jb2x1bW4td2lkdGgnOiBCb29sZWFuLFxuICAgICdhbGlnbi1sZWZ0JzogQm9vbGVhbixcbiAgICAnYWxpZ24tcmlnaHQnOiBCb29sZWFuXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdtZGMtbGF5b3V0LWdyaWQnOiB0cnVlLFxuICAgICAgICAnbWRjLWxheW91dC1ncmlkLS1maXhlZC1jb2x1bW4td2lkdGgnOiB0aGlzLmZpeGVkQ29sdW1uV2lkdGgsXG4gICAgICAgICdtZGMtbGF5b3V0LWdyaWQtLWFsaWduLWxlZnQnOiB0aGlzLmFsaWduTGVmdCxcbiAgICAgICAgJ21kYy1sYXlvdXQtZ3JpZC0tYWxpZ24tcmlnaHQnOiB0aGlzLmFsaWduUmlnaHRcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IFxuICAgIDpjbGFzcz1cImNsYXNzZXNcIiBcbiAgICBjbGFzcz1cIm1kYy1sYXlvdXQtY2VsbCBtZGMtbGF5b3V0LWdyaWRfX2NlbGxcIj5cbiAgICA8c2xvdC8+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmNvbnN0IHNwYW5PcHRpb25zID0ge1xuICB0eXBlOiBbU3RyaW5nLCBOdW1iZXJdLFxuICBkZWZhdWx0OiBudWxsLFxuICB2YWxpZGF0b3I6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIG51bSA9IE51bWJlcih2YWx1ZSlcbiAgICByZXR1cm4gaXNGaW5pdGUobnVtKSAmJiBudW0gPD0gMTIgJiYgbnVtID4gMFxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1sYXlvdXQtY2VsbCcsXG4gIHByb3BzOiB7XG4gICAgc3Bhbjogc3Bhbk9wdGlvbnMsXG4gICAgb3JkZXI6IHNwYW5PcHRpb25zLFxuICAgIHBob25lOiBzcGFuT3B0aW9ucyxcbiAgICB0YWJsZXQ6IHNwYW5PcHRpb25zLFxuICAgIGRlc2t0b3A6IHNwYW5PcHRpb25zLFxuICAgIGFsaWduOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBbJ3RvcCcsICdib3R0b20nLCAnbWlkZGxlJ10uaW5kZXhPZih2YWx1ZSkgIT09IC0xXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMoKSB7XG4gICAgICBsZXQgY2xhc3NlcyA9IFtdXG5cbiAgICAgIGlmICh0aGlzLnNwYW4pIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKGBtZGMtbGF5b3V0LWdyaWRfX2NlbGwtLXNwYW4tJHt0aGlzLnNwYW59YClcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3JkZXIpIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKGBtZGMtbGF5b3V0LWdyaWRfX2NlbGwtLW9yZGVyLSR7dGhpcy5vcmRlcn1gKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5waG9uZSkge1xuICAgICAgICBjbGFzc2VzLnB1c2goYG1kYy1sYXlvdXQtZ3JpZF9fY2VsbC0tc3Bhbi0ke3RoaXMucGhvbmV9LXBob25lYClcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudGFibGV0KSB7XG4gICAgICAgIGNsYXNzZXMucHVzaChgbWRjLWxheW91dC1ncmlkX19jZWxsLS1zcGFuLSR7dGhpcy50YWJsZXR9LXRhYmxldGApXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmRlc2t0b3ApIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKGBtZGMtbGF5b3V0LWdyaWRfX2NlbGwtLXNwYW4tJHt0aGlzLmRlc2t0b3B9LWRlc2t0b3BgKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5hbGlnbikge1xuICAgICAgICBjbGFzc2VzLnB1c2goYG1kYy1sYXlvdXQtZ3JpZF9fY2VsbC0tYWxpZ24tJHt0aGlzLmFsaWdufWApXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbGFzc2VzXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1sYXlvdXQtaW5uZXItZ3JpZCBtZGMtbGF5b3V0LWdyaWRfX2lubmVyXCI+XG4gICAgPHNsb3QvPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbGF5b3V0LWlubmVyLWdyaWQnXG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0xheW91dEdyaWQgZnJvbSAnLi9tZGMtbGF5b3V0LWdyaWQudnVlJ1xuaW1wb3J0IG1kY0xheW91dENlbGwgZnJvbSAnLi9tZGMtbGF5b3V0LWNlbGwudnVlJ1xuaW1wb3J0IG1kY0xheW91dElubmVyR3JpZCBmcm9tICcuL21kYy1sYXlvdXQtaW5uZXItZ3JpZC52dWUnXG5cbmV4cG9ydCB7IG1kY0xheW91dEdyaWQsIG1kY0xheW91dENlbGwsIG1kY0xheW91dElubmVyR3JpZCB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNMYXlvdXRHcmlkLFxuICBtZGNMYXlvdXRDZWxsLFxuICBtZGNMYXlvdXRJbm5lckdyaWRcbn0pXG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgQ0xPU0VEX0NMQVNTOiAnbWRjLWxpbmVhci1wcm9ncmVzcy0tY2xvc2VkJyxcbiAgSU5ERVRFUk1JTkFURV9DTEFTUzogJ21kYy1saW5lYXItcHJvZ3Jlc3MtLWluZGV0ZXJtaW5hdGUnLFxuICBSRVZFUlNFRF9DTEFTUzogJ21kYy1saW5lYXItcHJvZ3Jlc3MtLXJldmVyc2VkJyxcbn07XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBQUklNQVJZX0JBUl9TRUxFQ1RPUjogJy5tZGMtbGluZWFyLXByb2dyZXNzX19wcmltYXJ5LWJhcicsXG4gIEJVRkZFUl9TRUxFQ1RPUjogJy5tZGMtbGluZWFyLXByb2dyZXNzX19idWZmZXInLFxufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7TURDRm91bmRhdGlvbn0gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvaW5kZXgnO1xuaW1wb3J0IHt0cmFuc2Zvcm1TdHlsZVByb3BlcnRpZXN9IGZyb20gJ0BtYXRlcmlhbC9hbmltYXRpb24vaW5kZXgnO1xuXG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURDTGluZWFyUHJvZ3Jlc3NGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgZ2V0UHJpbWFyeUJhcjogKCkgPT4gLyogZWw6IEVsZW1lbnQgKi8ge30sXG4gICAgICBnZXRCdWZmZXI6ICgpID0+IC8qIGVsOiBFbGVtZW50ICovIHt9LFxuICAgICAgaGFzQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4gZmFsc2UsXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldFN0eWxlOiAoLyogZWw6IEVsZW1lbnQsIHN0eWxlUHJvcGVydHk6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0xpbmVhclByb2dyZXNzRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmRldGVybWluYXRlXyA9ICF0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuSU5ERVRFUk1JTkFURV9DTEFTUyk7XG4gICAgdGhpcy5yZXZlcnNlXyA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5SRVZFUlNFRF9DTEFTUyk7XG4gICAgdGhpcy5wcm9ncmVzc18gPSAwO1xuICB9XG5cbiAgc2V0RGV0ZXJtaW5hdGUoaXNEZXRlcm1pbmF0ZSkge1xuICAgIHRoaXMuZGV0ZXJtaW5hdGVfID0gaXNEZXRlcm1pbmF0ZTtcbiAgICBpZiAodGhpcy5kZXRlcm1pbmF0ZV8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5JTkRFVEVSTUlOQVRFX0NMQVNTKTtcbiAgICAgIHRoaXMuc2V0U2NhbGVfKHRoaXMuYWRhcHRlcl8uZ2V0UHJpbWFyeUJhcigpLCB0aGlzLnByb2dyZXNzXyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5JTkRFVEVSTUlOQVRFX0NMQVNTKTtcbiAgICAgIHRoaXMuc2V0U2NhbGVfKHRoaXMuYWRhcHRlcl8uZ2V0UHJpbWFyeUJhcigpLCAxKTtcbiAgICAgIHRoaXMuc2V0U2NhbGVfKHRoaXMuYWRhcHRlcl8uZ2V0QnVmZmVyKCksIDEpO1xuICAgIH1cbiAgfVxuXG4gIHNldFByb2dyZXNzKHZhbHVlKSB7XG4gICAgdGhpcy5wcm9ncmVzc18gPSB2YWx1ZTtcbiAgICBpZiAodGhpcy5kZXRlcm1pbmF0ZV8pIHtcbiAgICAgIHRoaXMuc2V0U2NhbGVfKHRoaXMuYWRhcHRlcl8uZ2V0UHJpbWFyeUJhcigpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgc2V0QnVmZmVyKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZGV0ZXJtaW5hdGVfKSB7XG4gICAgICB0aGlzLnNldFNjYWxlXyh0aGlzLmFkYXB0ZXJfLmdldEJ1ZmZlcigpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgc2V0UmV2ZXJzZShpc1JldmVyc2VkKSB7XG4gICAgdGhpcy5yZXZlcnNlXyA9IGlzUmV2ZXJzZWQ7XG4gICAgaWYgKHRoaXMucmV2ZXJzZV8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5SRVZFUlNFRF9DTEFTUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5SRVZFUlNFRF9DTEFTUyk7XG4gICAgfVxuICB9XG5cbiAgb3BlbigpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuQ0xPU0VEX0NMQVNTKTtcbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5DTE9TRURfQ0xBU1MpO1xuICB9XG5cbiAgc2V0U2NhbGVfKGVsLCBzY2FsZVZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWUgPSAnc2NhbGVYKCcgKyBzY2FsZVZhbHVlICsgJyknO1xuICAgIHRyYW5zZm9ybVN0eWxlUHJvcGVydGllcy5mb3JFYWNoKCh0cmFuc2Zvcm1TdHlsZVByb3BlcnR5KSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlKGVsLCB0cmFuc2Zvcm1TdHlsZVByb3BlcnR5LCB2YWx1ZSk7XG4gICAgfSk7XG4gIH1cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgXG4gICAgOnN0eWxlPVwic3R5bGVzXCIgXG4gICAgcm9sZT1cInByb2dyZXNzYmFyXCIgXG4gICAgY2xhc3M9XCJtZGMtbGluZWFyLXByb2dyZXNzXCI+XG4gICAgPGRpdiBjbGFzcz1cIm1kYy1saW5lYXItcHJvZ3Jlc3NfX2J1ZmZlcmluZy1kb3RzXCIvPlxuICAgIDxkaXYgXG4gICAgICByZWY9XCJidWZmZXJcIiBcbiAgICAgIGNsYXNzPVwibWRjLWxpbmVhci1wcm9ncmVzc19fYnVmZmVyXCIvPlxuICAgIDxkaXYgXG4gICAgICByZWY9XCJwcmltYXJ5XCIgXG4gICAgICBjbGFzcz1cIm1kYy1saW5lYXItcHJvZ3Jlc3NfX2JhciBtZGMtbGluZWFyLXByb2dyZXNzX19wcmltYXJ5LWJhclwiPlxuICAgICAgPHNwYW4gY2xhc3M9XCJtZGMtbGluZWFyLXByb2dyZXNzX19iYXItaW5uZXJcIi8+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cIm1kYy1saW5lYXItcHJvZ3Jlc3NfX2JhciBtZGMtbGluZWFyLXByb2dyZXNzX19zZWNvbmRhcnktYmFyXCI+XG4gICAgICA8c3BhbiBjbGFzcz1cIm1kYy1saW5lYXItcHJvZ3Jlc3NfX2Jhci1pbm5lclwiLz5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+ICBcbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDTGluZWFyUHJvZ3Jlc3NGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9saW5lYXItcHJvZ3Jlc3MvZm91bmRhdGlvbidcblxuY29uc3QgUHJvZ3Jlc3NQcm9wVHlwZSA9IHtcbiAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIE51bWJlcih2YWx1ZSkgPj0gMCAmJiBOdW1iZXIodmFsdWUpIDw9IDFcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbGluZWFyLXByb2dyZXNzJyxcbiAgcHJvcHM6IHtcbiAgICBvcGVuOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IHRydWUgfSxcbiAgICBpbmRldGVybWluYXRlOiBCb29sZWFuLFxuICAgIHJldmVyc2U6IEJvb2xlYW4sXG4gICAgYWNjZW50OiBCb29sZWFuLFxuICAgIHByb2dyZXNzOiBQcm9ncmVzc1Byb3BUeXBlLFxuICAgIGJ1ZmZlcjogUHJvZ3Jlc3NQcm9wVHlwZVxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7ICdtZGMtbGluZWFyLXByb2dyZXNzLS1hY2NlbnQnOiB0aGlzLmFjY2VudCB9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBvcGVuKCkge1xuICAgICAgaWYgKHRoaXMub3Blbikge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24ub3BlbigpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24uY2xvc2UoKVxuICAgICAgfVxuICAgIH0sXG4gICAgcHJvZ3Jlc3MoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0UHJvZ3Jlc3MoTnVtYmVyKHRoaXMucHJvZ3Jlc3MpKVxuICAgIH0sXG4gICAgYnVmZmVyKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldEJ1ZmZlcihOdW1iZXIodGhpcy5idWZmZXIpKVxuICAgIH0sXG4gICAgaW5kZXRlcm1pbmF0ZSgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXREZXRlcm1pbmF0ZSghdGhpcy5pbmRldGVybWluYXRlKVxuICAgIH0sXG4gICAgcmV2ZXJzZSgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRSZXZlcnNlKHRoaXMucmV2ZXJzZSlcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ0xpbmVhclByb2dyZXNzRm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgfSxcbiAgICAgIGdldFByaW1hcnlCYXI6ICgpID0+IC8qIGVsOiBFbGVtZW50ICovIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMucHJpbWFyeVxuICAgICAgfSxcbiAgICAgIGdldEJ1ZmZlcjogKCkgPT4gLyogZWw6IEVsZW1lbnQgKi8ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5idWZmZXJcbiAgICAgIH0sXG4gICAgICBoYXNDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSlcbiAgICAgIH0sXG4gICAgICByZW1vdmVDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIHNldFN0eWxlOiAoZWwsIHN0eWxlUHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgICAgIGVsLnN0eWxlW3N0eWxlUHJvcGVydHldID0gdmFsdWVcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcblxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXRSZXZlcnNlKHRoaXMucmV2ZXJzZSlcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0UHJvZ3Jlc3MoTnVtYmVyKHRoaXMucHJvZ3Jlc3MpKVxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXRCdWZmZXIoTnVtYmVyKHRoaXMuYnVmZmVyKSlcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0RGV0ZXJtaW5hdGUoIXRoaXMuaW5kZXRlcm1pbmF0ZSlcbiAgICBpZiAodGhpcy5vcGVuKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24ub3BlbigpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5jbG9zZSgpXG4gICAgfVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNMaW5lYXJQcm9ncmVzcyBmcm9tICcuL21kYy1saW5lYXItcHJvZ3Jlc3MudnVlJ1xuXG5leHBvcnQgeyBtZGNMaW5lYXJQcm9ncmVzcyB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNMaW5lYXJQcm9ncmVzc1xufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPHVsIFxuICAgIDpjbGFzcz1cImNsYXNzZXNcIiBcbiAgICBjbGFzcz1cIm1kYy1saXN0XCI+XG4gICAgPHNsb3QvPlxuICA8L3VsPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1saXN0JyxcbiAgcHJvcHM6IHtcbiAgICBkZW5zZTogQm9vbGVhbixcbiAgICBhdmF0YXJMaXN0OiBCb29sZWFuLFxuICAgIHR3b0xpbmU6IEJvb2xlYW4sXG4gICAgYm9yZGVyZWQ6IEJvb2xlYW4sXG4gICAgaW50ZXJhY3RpdmU6IEJvb2xlYW5cbiAgfSxcbiAgcHJvdmlkZSgpIHtcbiAgICByZXR1cm4geyBtZGNMaXN0OiB0aGlzIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21kYy1saXN0LS1kZW5zZSc6IHRoaXMuZGVuc2UsXG4gICAgICAgICdtZGMtbGlzdC0tYXZhdGFyLWxpc3QnOiB0aGlzLmF2YXRhckxpc3QsXG4gICAgICAgICdtZGMtbGlzdC0tdHdvLWxpbmUnOiB0aGlzLnR3b0xpbmUsXG4gICAgICAgICdtZGMtbGlzdC0tYm9yZGVyZWQnOiB0aGlzLmJvcmRlcmVkLFxuICAgICAgICAnbWRjLWxpc3QtLW5vbi1pbnRlcmFjdGl2ZSc6ICF0aGlzLmludGVyYWN0aXZlXG4gICAgICB9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGxpIFxuICAgIDpjbGFzcz1cIltjbGFzc2VzLCBpdGVtQ2xhc3Nlc11cIlxuICAgIDpzdHlsZT1cInN0eWxlc1wiIFxuICAgIDp0YWJpbmRleD1cImlzSW50ZXJhY3RpdmUgPyAnMCcgOiB1bmRlZmluZWRcIiAgIFxuICAgIGNsYXNzPVwibWRjLWxpc3QtaXRlbVwiXG4gICAgdi1vbj1cImlzSW50ZXJhY3RpdmUgPyAkbGlzdGVuZXJzIDoge31cIj5cblxuICAgIDxzcGFuIFxuICAgICAgdi1pZj1cImhhc1N0YXJ0RGV0YWlsXCIgXG4gICAgICBjbGFzcz1cIm1kYy1saXN0LWl0ZW1fX2dyYXBoaWNcIj5cbiAgICAgIDxzbG90IG5hbWU9XCJzdGFydC1kZXRhaWxcIi8+XG4gICAgPC9zcGFuPlxuXG4gICAgPHNwYW4gXG4gICAgICB2LWlmPVwiaGFzU2Vjb25kYXJ5XCIgXG4gICAgICBjbGFzcz1cIm1kYy1saXN0LWl0ZW1fX3RleHRcIj5cbiAgICAgIDxzbG90Lz5cbiAgICAgIDxzcGFuIGNsYXNzPVwibWRjLWxpc3QtaXRlbV9fc2Vjb25kYXJ5LXRleHRcIj5cbiAgICAgICAgPHNsb3QgbmFtZT1cInNlY29uZGFyeVwiLz5cbiAgICAgIDwvc3Bhbj5cbiAgICA8L3NwYW4+XG4gICAgPHNsb3Qgdi1lbHNlLz5cblxuICAgIDxzcGFuIFxuICAgICAgdi1pZj1cImhhc0VuZERldGFpbFwiIFxuICAgICAgY2xhc3M9XCJtZGMtbGlzdC1pdGVtX19tZXRhXCI+XG4gICAgICA8c2xvdCBuYW1lPVwiZW5kLWRldGFpbFwiLz5cbiAgICA8L3NwYW4+XG5cbiAgPC9saT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBSaXBwbGVCYXNlIH0gZnJvbSAnLi4vcmlwcGxlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbGlzdC1pdGVtJyxcbiAgaW5qZWN0OiBbJ21kY0xpc3QnXSxcbiAgcHJvcHM6IHtcbiAgICBzZWxlY3RlZDogQm9vbGVhbixcbiAgICBhY3RpdmF0ZWQ6IEJvb2xlYW5cbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGl0ZW1DbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21kYy1saXN0LWl0ZW0tLXNlbGVjdGVkJzogdGhpcy5zZWxlY3RlZCxcbiAgICAgICAgJ21kYy1saXN0LWl0ZW0tLWFjdGl2YXRlZCc6IHRoaXMuYWN0aXZhdGVkXG4gICAgICB9XG4gICAgfSxcbiAgICBpc0ludGVyYWN0aXZlKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWRjTGlzdCAmJiB0aGlzLm1kY0xpc3QuaW50ZXJhY3RpdmVcbiAgICB9LFxuICAgIGhhc1NlY29uZGFyeSgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRzbG90c1snc2Vjb25kYXJ5J10gJiYgKHRoaXMubWRjTGlzdCAmJiB0aGlzLm1kY0xpc3QudHdvTGluZSlcbiAgICB9LFxuICAgIGhhc0VuZERldGFpbCgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuJHNsb3RzWydlbmQtZGV0YWlsJ11cbiAgICB9LFxuICAgIGhhc1N0YXJ0RGV0YWlsKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy4kc2xvdHNbJ3N0YXJ0LWRldGFpbCddXG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIGlzSW50ZXJhY3RpdmUodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmFkZFJpcHBsZSgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZVJpcHBsZSgpXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuaXNJbnRlcmFjdGl2ZSAmJiB0aGlzLmFkZFJpcHBsZSgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW1vdmVSaXBwbGUoKVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgYWRkUmlwcGxlKCkge1xuICAgICAgaWYgKCF0aGlzLnJpcHBsZSkge1xuICAgICAgICBsZXQgcmlwcGxlID0gbmV3IFJpcHBsZUJhc2UodGhpcylcbiAgICAgICAgcmlwcGxlLmluaXQoKVxuICAgICAgICB0aGlzLnJpcHBsZSA9IHJpcHBsZVxuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlUmlwcGxlKCkge1xuICAgICAgaWYgKHRoaXMucmlwcGxlKSB7XG4gICAgICAgIGxldCByaXBwbGUgPSB0aGlzLnJpcHBsZVxuICAgICAgICB0aGlzLnJpcHBsZSA9IG51bGxcbiAgICAgICAgcmlwcGxlLmRlc3Ryb3koKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxsaSBcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgXG4gICAgcm9sZT1cInNlcGFyYXRvclwiIFxuICAgIGNsYXNzPVwibWRjLWxpc3QtZGl2aWRlclwiLz5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbGlzdC1kaXZpZGVyJyxcbiAgcHJvcHM6IHtcbiAgICBpbnNldDogQm9vbGVhbixcbiAgICBwYWRkZWQ6IEJvb2xlYW5cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21kYy1saXN0LWRpdmlkZXItLWluc2V0JzogdGhpcy5pbnNldCxcbiAgICAgICAgJ21kYy1saXN0LWRpdmlkZXItLXBhZGRlZCc6IHRoaXMucGFkZGVkXG4gICAgICB9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1saXN0LWdyb3VwXCI+PHNsb3QvPjwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1saXN0LWdyb3VwJ1xufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxoMyBjbGFzcz1cIm1kYy1saXN0LWdyb3VwLWhlYWRlciBtZGMtbGlzdC1ncm91cF9fc3ViaGVhZGVyXCI+PHNsb3QvPjwvaDM+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWxpc3QtZ3JvdXAtaGVhZGVyJ1xufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxociBjbGFzcz1cIm1kYy1saXN0LWdyb3VwLWRpdmlkZXIgbWRjLWxpc3QtZGl2aWRlclwiPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1saXN0LWdyb3VwLWRpdmlkZXInXG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0xpc3QgZnJvbSAnLi9tZGMtbGlzdC52dWUnXG5pbXBvcnQgbWRjTGlzdEl0ZW0gZnJvbSAnLi9tZGMtbGlzdC1pdGVtLnZ1ZSdcbmltcG9ydCBtZGNMaXN0RGl2aWRlciBmcm9tICcuL21kYy1saXN0LWRpdmlkZXIudnVlJ1xuaW1wb3J0IG1kY0xpc3RHcm91cCBmcm9tICcuL21kYy1saXN0LWdyb3VwLnZ1ZSdcbmltcG9ydCBtZGNMaXN0R3JvdXBIZWFkZXIgZnJvbSAnLi9tZGMtbGlzdC1ncm91cC1oZWFkZXIudnVlJ1xuaW1wb3J0IG1kY0xpc3RHcm91cERpdmlkZXIgZnJvbSAnLi9tZGMtbGlzdC1ncm91cC1kaXZpZGVyLnZ1ZSdcblxuZXhwb3J0IHtcbiAgbWRjTGlzdCxcbiAgbWRjTGlzdEl0ZW0sXG4gIG1kY0xpc3REaXZpZGVyLFxuICBtZGNMaXN0R3JvdXAsXG4gIG1kY0xpc3RHcm91cEhlYWRlcixcbiAgbWRjTGlzdEdyb3VwRGl2aWRlclxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjTGlzdCxcbiAgbWRjTGlzdEl0ZW0sXG4gIG1kY0xpc3REaXZpZGVyLFxuICBtZGNMaXN0R3JvdXAsXG4gIG1kY0xpc3RHcm91cEhlYWRlcixcbiAgbWRjTGlzdEdyb3VwRGl2aWRlclxufSlcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgTWVudS4gUHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBtYW5hZ2luZ1xuICogLSBjbGFzc2VzXG4gKiAtIGRvbVxuICogLSBmb2N1c1xuICogLSBwb3NpdGlvblxuICogLSBkaW1lbnNpb25zXG4gKiAtIGV2ZW50IGhhbmRsZXJzXG4gKlxuICogQWRkaXRpb25hbGx5LCBwcm92aWRlcyB0eXBlIGluZm9ybWF0aW9uIGZvciB0aGUgYWRhcHRlciB0byB0aGUgQ2xvc3VyZVxuICogY29tcGlsZXIuXG4gKlxuICogSW1wbGVtZW50IHRoaXMgYWRhcHRlciBmb3IgeW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlIHRvIGRlbGVnYXRlIHVwZGF0ZXMgdG9cbiAqIHRoZSBjb21wb25lbnQgaW4geW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlLiBTZWUgYXJjaGl0ZWN0dXJlIGRvY3VtZW50YXRpb25cbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2NvZGUvYXJjaGl0ZWN0dXJlLm1kXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENNZW51QWRhcHRlciB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaGFzTmVjZXNzYXJ5RG9tKCkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVOYW1lXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldEF0dHJpYnV0ZUZvckV2ZW50VGFyZ2V0KHRhcmdldCwgYXR0cmlidXRlTmFtZSkge31cblxuICAvKiogQHJldHVybiB7eyB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9fSAqL1xuICBnZXRJbm5lckRpbWVuc2lvbnMoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBoYXNBbmNob3IoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHt7d2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIHRvcDogbnVtYmVyLCByaWdodDogbnVtYmVyLCBib3R0b206IG51bWJlciwgbGVmdDogbnVtYmVyfX0gKi9cbiAgZ2V0QW5jaG9yRGltZW5zaW9ucygpIHt9XG5cbiAgLyoqIEByZXR1cm4ge3sgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIgfX0gKi9cbiAgZ2V0V2luZG93RGltZW5zaW9ucygpIHt9XG5cbiAgLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbiAgZ2V0TnVtYmVyT2ZJdGVtcygpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KX0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KX0gaGFuZGxlciAqL1xuICByZWdpc3RlckJvZHlDbGlja0hhbmRsZXIoaGFuZGxlcikge31cblxuICAvKiogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpfSBoYW5kbGVyICovXG4gIGRlcmVnaXN0ZXJCb2R5Q2xpY2tIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRJbmRleEZvckV2ZW50VGFyZ2V0KHRhcmdldCkge31cblxuICAvKiogQHBhcmFtIHt7aW5kZXg6IG51bWJlcn19IGV2dERhdGEgKi9cbiAgbm90aWZ5U2VsZWN0ZWQoZXZ0RGF0YSkge31cblxuICBub3RpZnlDYW5jZWwoKSB7fVxuXG4gIHNhdmVGb2N1cygpIHt9XG5cbiAgcmVzdG9yZUZvY3VzKCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNGb2N1c2VkKCkge31cblxuICBmb2N1cygpIHt9XG5cbiAgLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbiAgZ2V0Rm9jdXNlZEl0ZW1JbmRleCgpIC8qIG51bWJlciAqLyB7fVxuXG4gIC8qKiBAcGFyYW0ge251bWJlcn0gaW5kZXggKi9cbiAgZm9jdXNJdGVtQXRJbmRleChpbmRleCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNSdGwoKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gb3JpZ2luICovXG4gIHNldFRyYW5zZm9ybU9yaWdpbihvcmlnaW4pIHt9XG5cbiAgLyoqIEBwYXJhbSB7e1xuICAqICAgdG9wOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gICogICByaWdodDogKHN0cmluZ3x1bmRlZmluZWQpLFxuICAqICAgYm90dG9tOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gICogICBsZWZ0OiAoc3RyaW5nfHVuZGVmaW5lZClcbiAgKiB9fSBwb3NpdGlvbiAqL1xuICBzZXRQb3NpdGlvbihwb3NpdGlvbikge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGhlaWdodCAqL1xuICBzZXRNYXhIZWlnaHQoaGVpZ2h0KSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRBdHRyRm9yT3B0aW9uQXRJbmRleChpbmRleCwgYXR0ciwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICAgKi9cbiAgcm1BdHRyRm9yT3B0aW9uQXRJbmRleChpbmRleCwgYXR0cikge31cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGFkZENsYXNzRm9yT3B0aW9uQXRJbmRleChpbmRleCwgY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgcm1DbGFzc0Zvck9wdGlvbkF0SW5kZXgoaW5kZXgsIGNsYXNzTmFtZSkge31cbn1cblxuZXhwb3J0IHtNRENNZW51QWRhcHRlcn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBST09UOiAnbWRjLW1lbnUnLFxuICBPUEVOOiAnbWRjLW1lbnUtLW9wZW4nLFxuICBBTklNQVRJTkdfT1BFTjogJ21kYy1tZW51LS1hbmltYXRpbmctb3BlbicsXG4gIEFOSU1BVElOR19DTE9TRUQ6ICdtZGMtbWVudS0tYW5pbWF0aW5nLWNsb3NlZCcsXG4gIFNFTEVDVEVEX0xJU1RfSVRFTTogJ21kYy1saXN0LWl0ZW0tLXNlbGVjdGVkJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgSVRFTVNfU0VMRUNUT1I6ICcubWRjLW1lbnVfX2l0ZW1zJyxcbiAgU0VMRUNURURfRVZFTlQ6ICdNRENNZW51OnNlbGVjdGVkJyxcbiAgQ0FOQ0VMX0VWRU5UOiAnTURDTWVudTpjYW5jZWwnLFxuICBBUklBX0RJU0FCTEVEX0FUVFI6ICdhcmlhLWRpc2FibGVkJyxcbn07XG5cbi8qKiBAZW51bSB7bnVtYmVyfSAqL1xuY29uc3QgbnVtYmVycyA9IHtcbiAgLy8gQW1vdW50IG9mIHRpbWUgdG8gd2FpdCBiZWZvcmUgdHJpZ2dlcmluZyBhIHNlbGVjdGVkIGV2ZW50IG9uIHRoZSBtZW51LiBOb3RlIHRoYXQgdGhpcyB0aW1lXG4gIC8vIHdpbGwgbW9zdCBsaWtlbHkgYmUgYnVtcGVkIHVwIG9uY2UgaW50ZXJhY3RpdmUgbGlzdHMgYXJlIHN1cHBvcnRlZCB0byBhbGxvdyBmb3IgdGhlIHJpcHBsZSB0b1xuICAvLyBhbmltYXRlIGJlZm9yZSBjbG9zaW5nIHRoZSBtZW51XG4gIFNFTEVDVEVEX1RSSUdHRVJfREVMQVk6IDUwLFxuICAvLyBUb3RhbCBkdXJhdGlvbiBvZiBtZW51IG9wZW4gYW5pbWF0aW9uLlxuICBUUkFOU0lUSU9OX09QRU5fRFVSQVRJT046IDEyMCxcbiAgLy8gVG90YWwgZHVyYXRpb24gb2YgbWVudSBjbG9zZSBhbmltYXRpb24uXG4gIFRSQU5TSVRJT05fQ0xPU0VfRFVSQVRJT046IDc1LFxuICAvLyBNYXJnaW4gbGVmdCB0byB0aGUgZWRnZSBvZiB0aGUgdmlld3BvcnQgd2hlbiBtZW51IGlzIGF0IG1heGltdW0gcG9zc2libGUgaGVpZ2h0LlxuICBNQVJHSU5fVE9fRURHRTogMzIsXG4gIC8vIFJhdGlvIG9mIGFuY2hvciB3aWR0aCB0byBtZW51IHdpZHRoIGZvciBzd2l0Y2hpbmcgZnJvbSBjb3JuZXIgcG9zaXRpb25pbmcgdG8gY2VudGVyIHBvc2l0aW9uaW5nLlxuICBBTkNIT1JfVE9fTUVOVV9XSURUSF9SQVRJTzogMC42NyxcbiAgLy8gUmF0aW8gb2YgdmVydGljYWwgb2Zmc2V0IHRvIG1lbnUgaGVpZ2h0IGZvciBzd2l0Y2hpbmcgZnJvbSBjb3JuZXIgdG8gbWlkLXdheSBvcmlnaW4gcG9zaXRpb25pbmcuXG4gIE9GRlNFVF9UT19NRU5VX0hFSUdIVF9SQVRJTzogMC4xLFxufTtcblxuLyoqXG4gKiBFbnVtIGZvciBiaXRzIGluIHRoZSB7QHNlZSBDb3JuZXIpIGJpdG1hcC5cbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmNvbnN0IENvcm5lckJpdCA9IHtcbiAgQk9UVE9NOiAxLFxuICBDRU5URVI6IDIsXG4gIFJJR0hUOiA0LFxuICBGTElQX1JUTDogOCxcbn07XG5cbi8qKlxuICogRW51bSBmb3IgcmVwcmVzZW50aW5nIGFuIGVsZW1lbnQgY29ybmVyIGZvciBwb3NpdGlvbmluZyB0aGUgbWVudS5cbiAqXG4gKiBUaGUgU1RBUlQgY29uc3RhbnRzIG1hcCB0byBMRUZUIGlmIGVsZW1lbnQgZGlyZWN0aW9uYWxpdHkgaXMgbGVmdFxuICogdG8gcmlnaHQgYW5kIFJJR0hUIGlmIHRoZSBkaXJlY3Rpb25hbGl0eSBpcyByaWdodCB0byBsZWZ0LlxuICogTGlrZXdpc2UgRU5EIG1hcHMgdG8gUklHSFQgb3IgTEVGVCBkZXBlbmRpbmcgb24gdGhlIGRpcmVjdGlvbmFsaXR5LlxuICpcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbmNvbnN0IENvcm5lciA9IHtcbiAgVE9QX0xFRlQ6IDAsXG4gIFRPUF9SSUdIVDogQ29ybmVyQml0LlJJR0hULFxuICBCT1RUT01fTEVGVDogQ29ybmVyQml0LkJPVFRPTSxcbiAgQk9UVE9NX1JJR0hUOiBDb3JuZXJCaXQuQk9UVE9NIHwgQ29ybmVyQml0LlJJR0hULFxuICBUT1BfU1RBUlQ6IENvcm5lckJpdC5GTElQX1JUTCxcbiAgVE9QX0VORDogQ29ybmVyQml0LkZMSVBfUlRMIHwgQ29ybmVyQml0LlJJR0hULFxuICBCT1RUT01fU1RBUlQ6IENvcm5lckJpdC5CT1RUT00gfCBDb3JuZXJCaXQuRkxJUF9SVEwsXG4gIEJPVFRPTV9FTkQ6IENvcm5lckJpdC5CT1RUT00gfCBDb3JuZXJCaXQuUklHSFQgfCBDb3JuZXJCaXQuRkxJUF9SVEwsXG59O1xuXG5cbmV4cG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVycywgQ29ybmVyQml0LCBDb3JuZXJ9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgdG9wOiBudW1iZXIsXG4gKiAgIHJpZ2h0OiBudW1iZXIsXG4gKiAgIGJvdHRvbTogbnVtYmVyLFxuICogICBsZWZ0OiBudW1iZXJcbiAqIH19XG4gKi9cbmxldCBBbmNob3JNYXJnaW47XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIHZpZXdwb3J0OiB7IHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH0sXG4gKiAgIHZpZXdwb3J0RGlzdGFuY2U6IHt0b3A6IG51bWJlciwgcmlnaHQ6IG51bWJlciwgYm90dG9tOiBudW1iZXIsIGxlZnQ6IG51bWJlcn0sXG4gKiAgIGFuY2hvckhlaWdodDogbnVtYmVyLFxuICogICBhbmNob3JXaWR0aDogbnVtYmVyLFxuICogICBtZW51SGVpZ2h0OiBudW1iZXIsXG4gKiAgIG1lbnVXaWR0aDogbnVtYmVyLFxuICogfX1cbiAqL1xubGV0IEF1dG9MYXlvdXRNZWFzdXJlbWVudHM7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IHtNRENNZW51QWRhcHRlcn0gZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVycywgQ29ybmVyLCBDb3JuZXJCaXR9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDTWVudUFkYXB0ZXI+fVxuICovXG5jbGFzcyBNRENNZW51Rm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVte2Nzc0NsYXNzZXN9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW17c3RyaW5nc30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bXtudW1iZXJzfSAqL1xuICBzdGF0aWMgZ2V0IG51bWJlcnMoKSB7XG4gICAgcmV0dXJuIG51bWJlcnM7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVte251bWJlcn0gKi9cbiAgc3RhdGljIGdldCBDb3JuZXIoKSB7XG4gICAgcmV0dXJuIENvcm5lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBNRENNZW51QWRhcHRlcn0gZm9yIHR5cGluZyBpbmZvcm1hdGlvbiBvbiBwYXJhbWV0ZXJzIGFuZCByZXR1cm5cbiAgICogdHlwZXMuXG4gICAqIEByZXR1cm4geyFNRENNZW51QWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ01lbnVBZGFwdGVyfSAqLyAoe1xuICAgICAgYWRkQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgaGFzQ2xhc3M6ICgpID0+IGZhbHNlLFxuICAgICAgaGFzTmVjZXNzYXJ5RG9tOiAoKSA9PiBmYWxzZSxcbiAgICAgIGdldEF0dHJpYnV0ZUZvckV2ZW50VGFyZ2V0OiAoKSA9PiB7fSxcbiAgICAgIGdldElubmVyRGltZW5zaW9uczogKCkgPT4gKHt9KSxcbiAgICAgIGhhc0FuY2hvcjogKCkgPT4gZmFsc2UsXG4gICAgICBnZXRBbmNob3JEaW1lbnNpb25zOiAoKSA9PiAoe30pLFxuICAgICAgZ2V0V2luZG93RGltZW5zaW9uczogKCkgPT4gKHt9KSxcbiAgICAgIGdldE51bWJlck9mSXRlbXM6ICgpID0+IDAsXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyQm9keUNsaWNrSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyQm9keUNsaWNrSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBnZXRJbmRleEZvckV2ZW50VGFyZ2V0OiAoKSA9PiAwLFxuICAgICAgbm90aWZ5U2VsZWN0ZWQ6ICgpID0+IHt9LFxuICAgICAgbm90aWZ5Q2FuY2VsOiAoKSA9PiB7fSxcbiAgICAgIHNhdmVGb2N1czogKCkgPT4ge30sXG4gICAgICByZXN0b3JlRm9jdXM6ICgpID0+IHt9LFxuICAgICAgaXNGb2N1c2VkOiAoKSA9PiBmYWxzZSxcbiAgICAgIGZvY3VzOiAoKSA9PiB7fSxcbiAgICAgIGdldEZvY3VzZWRJdGVtSW5kZXg6ICgpID0+IC0xLFxuICAgICAgZm9jdXNJdGVtQXRJbmRleDogKCkgPT4ge30sXG4gICAgICBpc1J0bDogKCkgPT4gZmFsc2UsXG4gICAgICBzZXRUcmFuc2Zvcm1PcmlnaW46ICgpID0+IHt9LFxuICAgICAgc2V0UG9zaXRpb246ICgpID0+IHt9LFxuICAgICAgc2V0TWF4SGVpZ2h0OiAoKSA9PiB7fSxcbiAgICAgIHNldEF0dHJGb3JPcHRpb25BdEluZGV4OiAoKSA9PiB7fSxcbiAgICAgIHJtQXR0ckZvck9wdGlvbkF0SW5kZXg6ICgpID0+IHt9LFxuICAgICAgYWRkQ2xhc3NGb3JPcHRpb25BdEluZGV4OiAoKSA9PiB7fSxcbiAgICAgIHJtQ2xhc3NGb3JPcHRpb25BdEluZGV4OiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0geyFNRENNZW51QWRhcHRlcn0gYWRhcHRlciAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENNZW51Rm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQpfSAqL1xuICAgIHRoaXMuY2xpY2tIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlUG9zc2libGVTZWxlY3RlZF8oZXZ0KTtcbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCl9ICovXG4gICAgdGhpcy5rZXlkb3duSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZUtleWJvYXJkRG93bl8oZXZ0KTtcbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCl9ICovXG4gICAgdGhpcy5rZXl1cEhhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVLZXlib2FyZFVwXyhldnQpO1xuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KX0gKi9cbiAgICB0aGlzLmRvY3VtZW50Q2xpY2tIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlRG9jdW1lbnRDbGlja18oZXZ0KTtcbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5pc09wZW5fID0gZmFsc2U7XG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5vcGVuQW5pbWF0aW9uRW5kVGltZXJJZF8gPSAwO1xuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuY2xvc2VBbmltYXRpb25FbmRUaW1lcklkXyA9IDA7XG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5zZWxlY3RlZFRyaWdnZXJUaW1lcklkXyA9IDA7XG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5hbmltYXRpb25SZXF1ZXN0SWRfID0gMDtcbiAgICAvKiogQHByaXZhdGUgeyF7IHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH19ICovXG4gICAgdGhpcy5kaW1lbnNpb25zXztcbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLml0ZW1IZWlnaHRfO1xuICAgIC8qKiBAcHJpdmF0ZSB7Q29ybmVyfSAqL1xuICAgIHRoaXMuYW5jaG9yQ29ybmVyXyA9IENvcm5lci5UT1BfU1RBUlQ7XG4gICAgLyoqIEBwcml2YXRlIHtBbmNob3JNYXJnaW59ICovXG4gICAgdGhpcy5hbmNob3JNYXJnaW5fID0ge3RvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMH07XG4gICAgLyoqIEBwcml2YXRlIHs/QXV0b0xheW91dE1lYXN1cmVtZW50c30gKi9cbiAgICB0aGlzLm1lYXN1cmVzXyA9IG51bGw7XG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5zZWxlY3RlZEluZGV4XyA9IC0xO1xuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLnJlbWVtYmVyU2VsZWN0aW9uXyA9IGZhbHNlO1xuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLnF1aWNrT3Blbl8gPSBmYWxzZTtcblxuICAgIC8vIEEga2V5dXAgZXZlbnQgb24gdGhlIG1lbnUgbmVlZHMgdG8gaGF2ZSBhIGNvcnJlc3BvbmRpbmcga2V5ZG93blxuICAgIC8vIGV2ZW50IG9uIHRoZSBtZW51LiBJZiB0aGUgdXNlciBvcGVucyB0aGUgbWVudSB3aXRoIGEga2V5ZG93biBldmVudCBvbiBhXG4gICAgLy8gYnV0dG9uLCB0aGUgbWVudSB3aWxsIG9ubHkgZ2V0IHRoZSBrZXkgdXAgZXZlbnQgY2F1c2luZyBidWdneSBiZWhhdmlvciB3aXRoIHNlbGVjdGVkIGVsZW1lbnRzLlxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmtleURvd25XaXRoaW5NZW51XyA9IGZhbHNlO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBjb25zdCB7Uk9PVCwgT1BFTn0gPSBNRENNZW51Rm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuXG4gICAgaWYgKCF0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKFJPT1QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Uk9PVH0gY2xhc3MgcmVxdWlyZWQgaW4gcm9vdCBlbGVtZW50LmApO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5hZGFwdGVyXy5oYXNOZWNlc3NhcnlEb20oKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXF1aXJlZCBET00gbm9kZXMgbWlzc2luZyBpbiAke1JPT1R9IGNvbXBvbmVudC5gKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhPUEVOKSkge1xuICAgICAgdGhpcy5pc09wZW5fID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5dXAnLCB0aGlzLmtleXVwSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleWRvd24nLCB0aGlzLmtleWRvd25IYW5kbGVyXyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnNlbGVjdGVkVHJpZ2dlclRpbWVySWRfKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5vcGVuQW5pbWF0aW9uRW5kVGltZXJJZF8pO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmNsb3NlQW5pbWF0aW9uRW5kVGltZXJJZF8pO1xuICAgIC8vIENhbmNlbCBhbnkgY3VycmVudGx5IHJ1bm5pbmcgYW5pbWF0aW9ucy5cbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvblJlcXVlc3RJZF8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmNsaWNrSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5dXAnLCB0aGlzLmtleXVwSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJCb2R5Q2xpY2tIYW5kbGVyKHRoaXMuZG9jdW1lbnRDbGlja0hhbmRsZXJfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFDb3JuZXJ9IGNvcm5lciBEZWZhdWx0IGFuY2hvciBjb3JuZXIgYWxpZ25tZW50IG9mIHRvcC1sZWZ0IG1lbnUgY29ybmVyLlxuICAgKi9cbiAgc2V0QW5jaG9yQ29ybmVyKGNvcm5lcikge1xuICAgIHRoaXMuYW5jaG9yQ29ybmVyXyA9IGNvcm5lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFBbmNob3JNYXJnaW59IG1hcmdpbiA0LXBsZXQgb2YgbWFyZ2lucyBmcm9tIGFuY2hvci5cbiAgICovXG4gIHNldEFuY2hvck1hcmdpbihtYXJnaW4pIHtcbiAgICB0aGlzLmFuY2hvck1hcmdpbl8udG9wID0gdHlwZW9mIG1hcmdpbi50b3AgPT09ICdudW1iZXInID8gbWFyZ2luLnRvcCA6IDA7XG4gICAgdGhpcy5hbmNob3JNYXJnaW5fLnJpZ2h0ID0gdHlwZW9mIG1hcmdpbi5yaWdodCA9PT0gJ251bWJlcicgPyBtYXJnaW4ucmlnaHQgOiAwO1xuICAgIHRoaXMuYW5jaG9yTWFyZ2luXy5ib3R0b20gPSB0eXBlb2YgbWFyZ2luLmJvdHRvbSA9PT0gJ251bWJlcicgPyBtYXJnaW4uYm90dG9tIDogMDtcbiAgICB0aGlzLmFuY2hvck1hcmdpbl8ubGVmdCA9IHR5cGVvZiBtYXJnaW4ubGVmdCA9PT0gJ251bWJlcicgPyBtYXJnaW4ubGVmdCA6IDA7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSByZW1lbWJlclNlbGVjdGlvbiAqL1xuICBzZXRSZW1lbWJlclNlbGVjdGlvbihyZW1lbWJlclNlbGVjdGlvbikge1xuICAgIHRoaXMucmVtZW1iZXJTZWxlY3Rpb25fID0gcmVtZW1iZXJTZWxlY3Rpb247XG4gICAgdGhpcy5zZXRTZWxlY3RlZEluZGV4KC0xKTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge2Jvb2xlYW59IHF1aWNrT3BlbiAqL1xuICBzZXRRdWlja09wZW4ocXVpY2tPcGVuKSB7XG4gICAgdGhpcy5xdWlja09wZW5fID0gcXVpY2tPcGVuO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7P251bWJlcn0gZm9jdXNJbmRleFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZm9jdXNPbk9wZW5fKGZvY3VzSW5kZXgpIHtcbiAgICBpZiAoZm9jdXNJbmRleCA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgdGhpcyBpbnN0YW5jZSBvZiBNRENNZW51IHJlbWVtYmVycyBzZWxlY3Rpb25zLCBhbmQgdGhlIHVzZXIgaGFzXG4gICAgICAvLyBtYWRlIGEgc2VsZWN0aW9uLCB0aGVuIGZvY3VzIHRoZSBsYXN0IHNlbGVjdGVkIGl0ZW1cbiAgICAgIGlmICh0aGlzLnJlbWVtYmVyU2VsZWN0aW9uXyAmJiB0aGlzLnNlbGVjdGVkSW5kZXhfID49IDApIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5mb2N1c0l0ZW1BdEluZGV4KHRoaXMuc2VsZWN0ZWRJbmRleF8pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYWRhcHRlcl8uZm9jdXMoKTtcbiAgICAgIC8vIElmIHRoYXQgZG9lc24ndCB3b3JrLCBmb2N1cyBmaXJzdCBpdGVtIGluc3RlYWQuXG4gICAgICBpZiAoIXRoaXMuYWRhcHRlcl8uaXNGb2N1c2VkKCkpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5mb2N1c0l0ZW1BdEluZGV4KDApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmZvY3VzSXRlbUF0SW5kZXgoZm9jdXNJbmRleCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBjbGlja3MgYW5kIGNhbmNlbCB0aGUgbWVudSBpZiBub3QgYSBjaGlsZCBsaXN0LWl0ZW1cbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlRG9jdW1lbnRDbGlja18oZXZ0KSB7XG4gICAgbGV0IGVsID0gZXZ0LnRhcmdldDtcblxuICAgIHdoaWxlIChlbCAmJiBlbCAhPT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBpZiAodGhpcy5hZGFwdGVyXy5nZXRJbmRleEZvckV2ZW50VGFyZ2V0KGVsKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWwgPSBlbC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2FuY2VsKCk7XG4gICAgdGhpcy5jbG9zZShldnQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUga2V5cyB0aGF0IHdlIHdhbnQgdG8gcmVwZWF0IG9uIGhvbGQgKHRhYiBhbmQgYXJyb3dzKS5cbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlS2V5Ym9hcmREb3duXyhldnQpIHtcbiAgICAvLyBEbyBub3RoaW5nIGlmIEFsdCwgQ3RybCBvciBNZXRhIGFyZSBwcmVzc2VkLlxuICAgIGlmIChldnQuYWx0S2V5IHx8IGV2dC5jdHJsS2V5IHx8IGV2dC5tZXRhS2V5KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCB7a2V5Q29kZSwga2V5LCBzaGlmdEtleX0gPSBldnQ7XG4gICAgY29uc3QgaXNUYWIgPSBrZXkgPT09ICdUYWInIHx8IGtleUNvZGUgPT09IDk7XG4gICAgY29uc3QgaXNBcnJvd1VwID0ga2V5ID09PSAnQXJyb3dVcCcgfHwga2V5Q29kZSA9PT0gMzg7XG4gICAgY29uc3QgaXNBcnJvd0Rvd24gPSBrZXkgPT09ICdBcnJvd0Rvd24nIHx8IGtleUNvZGUgPT09IDQwO1xuICAgIGNvbnN0IGlzU3BhY2UgPSBrZXkgPT09ICdTcGFjZScgfHwga2V5Q29kZSA9PT0gMzI7XG4gICAgY29uc3QgaXNFbnRlciA9IGtleSA9PT0gJ0VudGVyJyB8fCBrZXlDb2RlID09PSAxMztcbiAgICAvLyBUaGUgbWVudSBuZWVkcyB0byBrbm93IGlmIHRoZSBrZXlkb3duIGV2ZW50IHdhcyB0cmlnZ2VyZWQgb24gdGhlIG1lbnVcbiAgICB0aGlzLmtleURvd25XaXRoaW5NZW51XyA9IGlzRW50ZXIgfHwgaXNTcGFjZTtcblxuICAgIGNvbnN0IGZvY3VzZWRJdGVtSW5kZXggPSB0aGlzLmFkYXB0ZXJfLmdldEZvY3VzZWRJdGVtSW5kZXgoKTtcbiAgICBjb25zdCBsYXN0SXRlbUluZGV4ID0gdGhpcy5hZGFwdGVyXy5nZXROdW1iZXJPZkl0ZW1zKCkgLSAxO1xuXG4gICAgaWYgKHNoaWZ0S2V5ICYmIGlzVGFiICYmIGZvY3VzZWRJdGVtSW5kZXggPT09IDApIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZm9jdXNJdGVtQXRJbmRleChsYXN0SXRlbUluZGV4KTtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghc2hpZnRLZXkgJiYgaXNUYWIgJiYgZm9jdXNlZEl0ZW1JbmRleCA9PT0gbGFzdEl0ZW1JbmRleCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5mb2N1c0l0ZW1BdEluZGV4KDApO1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIEFycm93e1VwLERvd259IGFuZCBzcGFjZSBkbyBub3QgY2F1c2UgaW5hZHZlcnRlbnQgc2Nyb2xsaW5nXG4gICAgaWYgKGlzQXJyb3dVcCB8fCBpc0Fycm93RG93biB8fCBpc1NwYWNlKSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJvd1VwKSB7XG4gICAgICBpZiAoZm9jdXNlZEl0ZW1JbmRleCA9PT0gMCB8fCB0aGlzLmFkYXB0ZXJfLmlzRm9jdXNlZCgpKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZm9jdXNJdGVtQXRJbmRleChsYXN0SXRlbUluZGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZm9jdXNJdGVtQXRJbmRleChmb2N1c2VkSXRlbUluZGV4IC0gMSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0Fycm93RG93bikge1xuICAgICAgaWYgKGZvY3VzZWRJdGVtSW5kZXggPT09IGxhc3RJdGVtSW5kZXggfHwgdGhpcy5hZGFwdGVyXy5pc0ZvY3VzZWQoKSkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmZvY3VzSXRlbUF0SW5kZXgoMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmZvY3VzSXRlbUF0SW5kZXgoZm9jdXNlZEl0ZW1JbmRleCArIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBrZXlzIHRoYXQgd2UgZG9uJ3Qgd2FudCB0byByZXBlYXQgb24gaG9sZCAoRW50ZXIsIFNwYWNlLCBFc2NhcGUpLlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVLZXlib2FyZFVwXyhldnQpIHtcbiAgICAvLyBEbyBub3RoaW5nIGlmIEFsdCwgQ3RybCBvciBNZXRhIGFyZSBwcmVzc2VkLlxuICAgIGlmIChldnQuYWx0S2V5IHx8IGV2dC5jdHJsS2V5IHx8IGV2dC5tZXRhS2V5KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCB7a2V5Q29kZSwga2V5fSA9IGV2dDtcbiAgICBjb25zdCBpc0VudGVyID0ga2V5ID09PSAnRW50ZXInIHx8IGtleUNvZGUgPT09IDEzO1xuICAgIGNvbnN0IGlzU3BhY2UgPSBrZXkgPT09ICdTcGFjZScgfHwga2V5Q29kZSA9PT0gMzI7XG4gICAgY29uc3QgaXNFc2NhcGUgPSBrZXkgPT09ICdFc2NhcGUnIHx8IGtleUNvZGUgPT09IDI3O1xuXG4gICAgaWYgKGlzRW50ZXIgfHwgaXNTcGFjZSkge1xuICAgICAgLy8gSWYgdGhlIGtleWRvd24gZXZlbnQgZGlkbid0IG9jY3VyIG9uIHRoZSBtZW51LCB0aGVuIGl0IHNob3VsZFxuICAgICAgLy8gZGlzcmVnYXJkIHRoZSBwb3NzaWJsZSBzZWxlY3RlZCBldmVudC5cbiAgICAgIGlmICh0aGlzLmtleURvd25XaXRoaW5NZW51Xykge1xuICAgICAgICB0aGlzLmhhbmRsZVBvc3NpYmxlU2VsZWN0ZWRfKGV2dCk7XG4gICAgICB9XG4gICAgICB0aGlzLmtleURvd25XaXRoaW5NZW51XyA9IGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChpc0VzY2FwZSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlDYW5jZWwoKTtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVQb3NzaWJsZVNlbGVjdGVkXyhldnQpIHtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5nZXRBdHRyaWJ1dGVGb3JFdmVudFRhcmdldChldnQudGFyZ2V0LCBzdHJpbmdzLkFSSUFfRElTQUJMRURfQVRUUikgPT09ICd0cnVlJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRJbmRleCA9IHRoaXMuYWRhcHRlcl8uZ2V0SW5kZXhGb3JFdmVudFRhcmdldChldnQudGFyZ2V0KTtcbiAgICBpZiAodGFyZ2V0SW5kZXggPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIERlYm91bmNlIG11bHRpcGxlIHNlbGVjdGlvbnNcbiAgICBpZiAodGhpcy5zZWxlY3RlZFRyaWdnZXJUaW1lcklkXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNlbGVjdGVkVHJpZ2dlclRpbWVySWRfID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLnNlbGVjdGVkVHJpZ2dlclRpbWVySWRfID0gMDtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIGlmICh0aGlzLnJlbWVtYmVyU2VsZWN0aW9uXykge1xuICAgICAgICB0aGlzLnNldFNlbGVjdGVkSW5kZXgodGFyZ2V0SW5kZXgpO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlTZWxlY3RlZCh7aW5kZXg6IHRhcmdldEluZGV4fSk7XG4gICAgfSwgbnVtYmVycy5TRUxFQ1RFRF9UUklHR0VSX0RFTEFZKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBdXRvTGF5b3V0TWVhc3VyZW1lbnRzfSBNZWFzdXJlbWVudHMgdXNlZCB0byBwb3NpdGlvbiBtZW51IHBvcHVwLlxuICAgKi9cbiAgZ2V0QXV0b0xheW91dE1lYXN1cmVtZW50c18oKSB7XG4gICAgY29uc3QgYW5jaG9yUmVjdCA9IHRoaXMuYWRhcHRlcl8uZ2V0QW5jaG9yRGltZW5zaW9ucygpO1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gdGhpcy5hZGFwdGVyXy5nZXRXaW5kb3dEaW1lbnNpb25zKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgICAgdmlld3BvcnREaXN0YW5jZToge1xuICAgICAgICB0b3A6IGFuY2hvclJlY3QudG9wLFxuICAgICAgICByaWdodDogdmlld3BvcnQud2lkdGggLSBhbmNob3JSZWN0LnJpZ2h0LFxuICAgICAgICBsZWZ0OiBhbmNob3JSZWN0LmxlZnQsXG4gICAgICAgIGJvdHRvbTogdmlld3BvcnQuaGVpZ2h0IC0gYW5jaG9yUmVjdC5ib3R0b20sXG4gICAgICB9LFxuICAgICAgYW5jaG9ySGVpZ2h0OiBhbmNob3JSZWN0LmhlaWdodCxcbiAgICAgIGFuY2hvcldpZHRoOiBhbmNob3JSZWN0LndpZHRoLFxuICAgICAgbWVudUhlaWdodDogdGhpcy5kaW1lbnNpb25zXy5oZWlnaHQsXG4gICAgICBtZW51V2lkdGg6IHRoaXMuZGltZW5zaW9uc18ud2lkdGgsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgY29ybmVyIG9mIHRoZSBhbmNob3IgZnJvbSB3aGljaCB0byBhbmltYXRlIGFuZCBwb3NpdGlvbiB0aGUgbWVudS5cbiAgICogQHJldHVybiB7Q29ybmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0T3JpZ2luQ29ybmVyXygpIHtcbiAgICAvLyBEZWZhdWx0czogb3BlbiBmcm9tIHRoZSB0b3AgbGVmdC5cbiAgICBsZXQgY29ybmVyID0gQ29ybmVyLlRPUF9MRUZUO1xuXG4gICAgY29uc3Qge3ZpZXdwb3J0RGlzdGFuY2UsIGFuY2hvckhlaWdodCwgYW5jaG9yV2lkdGgsIG1lbnVIZWlnaHQsIG1lbnVXaWR0aH0gPSB0aGlzLm1lYXN1cmVzXztcbiAgICBjb25zdCBpc0JvdHRvbUFsaWduZWQgPSBCb29sZWFuKHRoaXMuYW5jaG9yQ29ybmVyXyAmIENvcm5lckJpdC5CT1RUT00pO1xuICAgIGNvbnN0IGF2YWlsYWJsZVRvcCA9IGlzQm90dG9tQWxpZ25lZCA/IHZpZXdwb3J0RGlzdGFuY2UudG9wICsgYW5jaG9ySGVpZ2h0ICsgdGhpcy5hbmNob3JNYXJnaW5fLmJvdHRvbVxuICAgICAgOiB2aWV3cG9ydERpc3RhbmNlLnRvcCArIHRoaXMuYW5jaG9yTWFyZ2luXy50b3A7XG4gICAgY29uc3QgYXZhaWxhYmxlQm90dG9tID0gaXNCb3R0b21BbGlnbmVkID8gdmlld3BvcnREaXN0YW5jZS5ib3R0b20gLSB0aGlzLmFuY2hvck1hcmdpbl8uYm90dG9tXG4gICAgICA6IHZpZXdwb3J0RGlzdGFuY2UuYm90dG9tICsgYW5jaG9ySGVpZ2h0IC0gdGhpcy5hbmNob3JNYXJnaW5fLnRvcDtcblxuICAgIGNvbnN0IHRvcE92ZXJmbG93ID0gbWVudUhlaWdodCAtIGF2YWlsYWJsZVRvcDtcbiAgICBjb25zdCBib3R0b21PdmVyZmxvdyA9IG1lbnVIZWlnaHQgLSBhdmFpbGFibGVCb3R0b207XG4gICAgaWYgKGJvdHRvbU92ZXJmbG93ID4gMCAmJiB0b3BPdmVyZmxvdyA8IGJvdHRvbU92ZXJmbG93KSB7XG4gICAgICBjb3JuZXIgfD0gQ29ybmVyQml0LkJPVFRPTTtcbiAgICB9XG5cbiAgICBjb25zdCBpc1J0bCA9IHRoaXMuYWRhcHRlcl8uaXNSdGwoKTtcbiAgICBjb25zdCBpc0ZsaXBSdGwgPSBCb29sZWFuKHRoaXMuYW5jaG9yQ29ybmVyXyAmIENvcm5lckJpdC5GTElQX1JUTCk7XG4gICAgY29uc3QgYXZvaWRIb3Jpem9udGFsT3ZlcmxhcCA9IEJvb2xlYW4odGhpcy5hbmNob3JDb3JuZXJfICYgQ29ybmVyQml0LlJJR0hUKTtcbiAgICBjb25zdCBpc0FsaWduZWRSaWdodCA9IChhdm9pZEhvcml6b250YWxPdmVybGFwICYmICFpc1J0bCkgfHxcbiAgICAgICghYXZvaWRIb3Jpem9udGFsT3ZlcmxhcCAmJiBpc0ZsaXBSdGwgJiYgaXNSdGwpO1xuICAgIGNvbnN0IGF2YWlsYWJsZUxlZnQgPSBpc0FsaWduZWRSaWdodCA/IHZpZXdwb3J0RGlzdGFuY2UubGVmdCArIGFuY2hvcldpZHRoICsgdGhpcy5hbmNob3JNYXJnaW5fLnJpZ2h0IDpcbiAgICAgIHZpZXdwb3J0RGlzdGFuY2UubGVmdCArIHRoaXMuYW5jaG9yTWFyZ2luXy5sZWZ0O1xuICAgIGNvbnN0IGF2YWlsYWJsZVJpZ2h0ID0gaXNBbGlnbmVkUmlnaHQgPyB2aWV3cG9ydERpc3RhbmNlLnJpZ2h0IC0gdGhpcy5hbmNob3JNYXJnaW5fLnJpZ2h0IDpcbiAgICAgIHZpZXdwb3J0RGlzdGFuY2UucmlnaHQgKyBhbmNob3JXaWR0aCAtIHRoaXMuYW5jaG9yTWFyZ2luXy5sZWZ0O1xuXG4gICAgY29uc3QgbGVmdE92ZXJmbG93ID0gbWVudVdpZHRoIC0gYXZhaWxhYmxlTGVmdDtcbiAgICBjb25zdCByaWdodE92ZXJmbG93ID0gbWVudVdpZHRoIC0gYXZhaWxhYmxlUmlnaHQ7XG5cbiAgICBpZiAoKGxlZnRPdmVyZmxvdyA8IDAgJiYgaXNBbGlnbmVkUmlnaHQgJiYgaXNSdGwpIHx8XG4gICAgICAgIChhdm9pZEhvcml6b250YWxPdmVybGFwICYmICFpc0FsaWduZWRSaWdodCAmJiBsZWZ0T3ZlcmZsb3cgPCAwKSB8fFxuICAgICAgICAocmlnaHRPdmVyZmxvdyA+IDAgJiYgbGVmdE92ZXJmbG93IDwgcmlnaHRPdmVyZmxvdykpIHtcbiAgICAgIGNvcm5lciB8PSBDb3JuZXJCaXQuUklHSFQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvcm5lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Nvcm5lcn0gY29ybmVyIE9yaWdpbiBjb3JuZXIgb2YgdGhlIG1lbnUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gSG9yaXpvbnRhbCBvZmZzZXQgb2YgbWVudSBvcmlnaW4gY29ybmVyIGZyb20gY29ycmVzcG9uZGluZyBhbmNob3IgY29ybmVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0SG9yaXpvbnRhbE9yaWdpbk9mZnNldF8oY29ybmVyKSB7XG4gICAgY29uc3Qge2FuY2hvcldpZHRofSA9IHRoaXMubWVhc3VyZXNfO1xuICAgIGNvbnN0IGlzUmlnaHRBbGlnbmVkID0gQm9vbGVhbihjb3JuZXIgJiBDb3JuZXJCaXQuUklHSFQpO1xuICAgIGNvbnN0IGF2b2lkSG9yaXpvbnRhbE92ZXJsYXAgPSBCb29sZWFuKHRoaXMuYW5jaG9yQ29ybmVyXyAmIENvcm5lckJpdC5SSUdIVCk7XG4gICAgbGV0IHggPSAwO1xuICAgIGlmIChpc1JpZ2h0QWxpZ25lZCkge1xuICAgICAgY29uc3QgcmlnaHRPZmZzZXQgPSBhdm9pZEhvcml6b250YWxPdmVybGFwID8gYW5jaG9yV2lkdGggLSB0aGlzLmFuY2hvck1hcmdpbl8ubGVmdCA6IHRoaXMuYW5jaG9yTWFyZ2luXy5yaWdodDtcbiAgICAgIHggPSByaWdodE9mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGVmdE9mZnNldCA9IGF2b2lkSG9yaXpvbnRhbE92ZXJsYXAgPyBhbmNob3JXaWR0aCAtIHRoaXMuYW5jaG9yTWFyZ2luXy5yaWdodCA6IHRoaXMuYW5jaG9yTWFyZ2luXy5sZWZ0O1xuICAgICAgeCA9IGxlZnRPZmZzZXQ7XG4gICAgfVxuICAgIHJldHVybiB4O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29ybmVyfSBjb3JuZXIgT3JpZ2luIGNvcm5lciBvZiB0aGUgbWVudS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBWZXJ0aWNhbCBvZmZzZXQgb2YgbWVudSBvcmlnaW4gY29ybmVyIGZyb20gY29ycmVzcG9uZGluZyBhbmNob3IgY29ybmVyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0VmVydGljYWxPcmlnaW5PZmZzZXRfKGNvcm5lcikge1xuICAgIGNvbnN0IHt2aWV3cG9ydCwgdmlld3BvcnREaXN0YW5jZSwgYW5jaG9ySGVpZ2h0LCBtZW51SGVpZ2h0fSA9IHRoaXMubWVhc3VyZXNfO1xuICAgIGNvbnN0IGlzQm90dG9tQWxpZ25lZCA9IEJvb2xlYW4oY29ybmVyICYgQ29ybmVyQml0LkJPVFRPTSk7XG4gICAgY29uc3Qge01BUkdJTl9UT19FREdFfSA9IE1EQ01lbnVGb3VuZGF0aW9uLm51bWJlcnM7XG4gICAgY29uc3QgYXZvaWRWZXJ0aWNhbE92ZXJsYXAgPSBCb29sZWFuKHRoaXMuYW5jaG9yQ29ybmVyXyAmIENvcm5lckJpdC5CT1RUT00pO1xuICAgIGNvbnN0IGNhbk92ZXJsYXBWZXJ0aWNhbGx5ID0gIWF2b2lkVmVydGljYWxPdmVybGFwO1xuICAgIGxldCB5ID0gMDtcblxuICAgIGlmIChpc0JvdHRvbUFsaWduZWQpIHtcbiAgICAgIHkgPSBhdm9pZFZlcnRpY2FsT3ZlcmxhcCA/IGFuY2hvckhlaWdodCAtIHRoaXMuYW5jaG9yTWFyZ2luXy50b3AgOiAtdGhpcy5hbmNob3JNYXJnaW5fLmJvdHRvbTtcbiAgICAgIC8vIGFkanVzdCBmb3Igd2hlbiBtZW51IGNhbiBvdmVybGFwIGFuY2hvciwgYnV0IHRvbyB0YWxsIHRvIGJlIGFsaWduZWQgdG8gYm90dG9tXG4gICAgICAvLyBhbmNob3IgY29ybmVyLiBCb3R0b20gbWFyZ2luIGlzIGlnbm9yZWQgaW4gc3VjaCBjYXNlcy5cbiAgICAgIGlmIChjYW5PdmVybGFwVmVydGljYWxseSAmJiBtZW51SGVpZ2h0ID4gdmlld3BvcnREaXN0YW5jZS50b3AgKyBhbmNob3JIZWlnaHQpIHtcbiAgICAgICAgeSA9IC0oTWF0aC5taW4obWVudUhlaWdodCwgdmlld3BvcnQuaGVpZ2h0IC0gTUFSR0lOX1RPX0VER0UpIC0gKHZpZXdwb3J0RGlzdGFuY2UudG9wICsgYW5jaG9ySGVpZ2h0KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgPSBhdm9pZFZlcnRpY2FsT3ZlcmxhcCA/IChhbmNob3JIZWlnaHQgKyB0aGlzLmFuY2hvck1hcmdpbl8uYm90dG9tKSA6IHRoaXMuYW5jaG9yTWFyZ2luXy50b3A7XG4gICAgICAvLyBhZGp1c3QgZm9yIHdoZW4gbWVudSBjYW4gb3ZlcmxhcCBhbmNob3IsIGJ1dCB0b28gdGFsbCB0byBiZSBhbGlnbmVkIHRvIHRvcFxuICAgICAgLy8gYW5jaG9yIGNvcm5lcnMuIFRvcCBtYXJnaW4gaXMgaWdub3JlZCBpbiB0aGF0IGNhc2UuXG4gICAgICBpZiAoY2FuT3ZlcmxhcFZlcnRpY2FsbHkgJiYgbWVudUhlaWdodCA+IHZpZXdwb3J0RGlzdGFuY2UuYm90dG9tICsgYW5jaG9ySGVpZ2h0KSB7XG4gICAgICAgIHkgPSAtKE1hdGgubWluKG1lbnVIZWlnaHQsIHZpZXdwb3J0LmhlaWdodCAtIE1BUkdJTl9UT19FREdFKSAtICh2aWV3cG9ydERpc3RhbmNlLmJvdHRvbSArIGFuY2hvckhlaWdodCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Nvcm5lcn0gY29ybmVyIE9yaWdpbiBjb3JuZXIgb2YgdGhlIG1lbnUuXG4gICAqIEByZXR1cm4ge251bWJlcn0gTWF4aW11bSBoZWlnaHQgb2YgdGhlIG1lbnUsIGJhc2VkIG9uIGF2YWlsYWJsZSBzcGFjZS4gMCBpbmRpY2F0ZXMgc2hvdWxkIG5vdCBiZSBzZXQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRNZW51TWF4SGVpZ2h0Xyhjb3JuZXIpIHtcbiAgICBsZXQgbWF4SGVpZ2h0ID0gMDtcbiAgICBjb25zdCB7dmlld3BvcnREaXN0YW5jZX0gPSB0aGlzLm1lYXN1cmVzXztcbiAgICBjb25zdCBpc0JvdHRvbUFsaWduZWQgPSBCb29sZWFuKGNvcm5lciAmIENvcm5lckJpdC5CT1RUT00pO1xuXG4gICAgLy8gV2hlbiBtYXhpbXVtIGhlaWdodCBpcyBub3Qgc3BlY2lmaWVkLCBpdCBpcyBoYW5kbGVkIGZyb20gY3NzLlxuICAgIGlmICh0aGlzLmFuY2hvckNvcm5lcl8gJiBDb3JuZXJCaXQuQk9UVE9NKSB7XG4gICAgICBpZiAoaXNCb3R0b21BbGlnbmVkKSB7XG4gICAgICAgIG1heEhlaWdodCA9IHZpZXdwb3J0RGlzdGFuY2UudG9wICsgdGhpcy5hbmNob3JNYXJnaW5fLnRvcDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1heEhlaWdodCA9IHZpZXdwb3J0RGlzdGFuY2UuYm90dG9tIC0gdGhpcy5hbmNob3JNYXJnaW5fLmJvdHRvbTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWF4SGVpZ2h0O1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGF1dG9Qb3NpdGlvbl8oKSB7XG4gICAgaWYgKCF0aGlzLmFkYXB0ZXJfLmhhc0FuY2hvcigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBtZWFzdXJlbWVudHMgZm9yIGF1dG9wb3NpdGlvbiBtZXRob2RzIHJldXNlLlxuICAgIHRoaXMubWVhc3VyZXNfID0gdGhpcy5nZXRBdXRvTGF5b3V0TWVhc3VyZW1lbnRzXygpO1xuXG4gICAgY29uc3QgY29ybmVyID0gdGhpcy5nZXRPcmlnaW5Db3JuZXJfKCk7XG4gICAgY29uc3QgbWF4TWVudUhlaWdodCA9IHRoaXMuZ2V0TWVudU1heEhlaWdodF8oY29ybmVyKTtcbiAgICBsZXQgdmVydGljYWxBbGlnbm1lbnQgPSAoY29ybmVyICYgQ29ybmVyQml0LkJPVFRPTSkgPyAnYm90dG9tJyA6ICd0b3AnO1xuICAgIGxldCBob3Jpem9udGFsQWxpZ25tZW50ID0gKGNvcm5lciAmIENvcm5lckJpdC5SSUdIVCkgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgIGNvbnN0IGhvcml6b250YWxPZmZzZXQgPSB0aGlzLmdldEhvcml6b250YWxPcmlnaW5PZmZzZXRfKGNvcm5lcik7XG4gICAgY29uc3QgdmVydGljYWxPZmZzZXQgPSB0aGlzLmdldFZlcnRpY2FsT3JpZ2luT2Zmc2V0Xyhjb3JuZXIpO1xuICAgIGNvbnN0IHBvc2l0aW9uID0ge1xuICAgICAgW2hvcml6b250YWxBbGlnbm1lbnRdOiBob3Jpem9udGFsT2Zmc2V0ID8gaG9yaXpvbnRhbE9mZnNldCArICdweCcgOiAnMCcsXG4gICAgICBbdmVydGljYWxBbGlnbm1lbnRdOiB2ZXJ0aWNhbE9mZnNldCA/IHZlcnRpY2FsT2Zmc2V0ICsgJ3B4JyA6ICcwJyxcbiAgICB9O1xuICAgIGNvbnN0IHthbmNob3JXaWR0aCwgbWVudUhlaWdodCwgbWVudVdpZHRofSA9IHRoaXMubWVhc3VyZXNfO1xuICAgIC8vIENlbnRlciBhbGlnbiB3aGVuIGFuY2hvciB3aWR0aCBpcyBjb21wYXJhYmxlIG9yIGdyZWF0ZXIgdGhhbiBtZW51LCBvdGhlcndpc2Uga2VlcCBjb3JuZXIuXG4gICAgaWYgKGFuY2hvcldpZHRoIC8gbWVudVdpZHRoID4gbnVtYmVycy5BTkNIT1JfVE9fTUVOVV9XSURUSF9SQVRJTykge1xuICAgICAgaG9yaXpvbnRhbEFsaWdubWVudCA9ICdjZW50ZXInO1xuICAgIH1cblxuICAgIC8vIEFkanVzdCB2ZXJ0aWNhbCBvcmlnaW4gd2hlbiBtZW51IGlzIHBvc2l0aW9uZWQgd2l0aCBzaWduaWZpY2FudCBvZmZzZXQgZnJvbSBhbmNob3IuIFRoaXMgaXMgZG9uZSBzbyB0aGF0XG4gICAgLy8gc2NhbGUgYW5pbWF0aW9uIGlzIFwiYW5jaG9yZWRcIiBvbiB0aGUgYW5jaG9yLlxuICAgIGlmICghKHRoaXMuYW5jaG9yQ29ybmVyXyAmIENvcm5lckJpdC5CT1RUT00pICYmXG4gICAgICAgIE1hdGguYWJzKHZlcnRpY2FsT2Zmc2V0IC8gbWVudUhlaWdodCkgPiBudW1iZXJzLk9GRlNFVF9UT19NRU5VX0hFSUdIVF9SQVRJTykge1xuICAgICAgY29uc3QgdmVydGljYWxPZmZzZXRQZXJjZW50ID0gTWF0aC5hYnModmVydGljYWxPZmZzZXQgLyBtZW51SGVpZ2h0KSAqIDEwMDtcbiAgICAgIGNvbnN0IG9yaWdpblBlcmNlbnQgPSAoY29ybmVyICYgQ29ybmVyQml0LkJPVFRPTSkgPyAxMDAgLSB2ZXJ0aWNhbE9mZnNldFBlcmNlbnQgOiB2ZXJ0aWNhbE9mZnNldFBlcmNlbnQ7XG4gICAgICB2ZXJ0aWNhbEFsaWdubWVudCA9IE1hdGgucm91bmQob3JpZ2luUGVyY2VudCAqIDEwMCkgLyAxMDAgKyAnJSc7XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy5zZXRUcmFuc2Zvcm1PcmlnaW4oYCR7aG9yaXpvbnRhbEFsaWdubWVudH0gJHt2ZXJ0aWNhbEFsaWdubWVudH1gKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldE1heEhlaWdodChtYXhNZW51SGVpZ2h0ID8gbWF4TWVudUhlaWdodCArICdweCcgOiAnJyk7XG5cbiAgICAvLyBDbGVhciBtZWFzdXJlcyBhZnRlciBwb3NpdGlvbmluZyBpcyBjb21wbGV0ZS5cbiAgICB0aGlzLm1lYXN1cmVzXyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogT3BlbiB0aGUgbWVudS5cbiAgICogQHBhcmFtIHt7Zm9jdXNJbmRleDogP251bWJlcn09fSBvcHRpb25zXG4gICAqL1xuICBvcGVuKHtmb2N1c0luZGV4ID0gbnVsbH0gPSB7fSkge1xuICAgIHRoaXMuYWRhcHRlcl8uc2F2ZUZvY3VzKCk7XG5cbiAgICBpZiAoIXRoaXMucXVpY2tPcGVuXykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENNZW51Rm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOSU1BVElOR19PUEVOKTtcbiAgICB9XG5cbiAgICB0aGlzLmFuaW1hdGlvblJlcXVlc3RJZF8gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5kaW1lbnNpb25zXyA9IHRoaXMuYWRhcHRlcl8uZ2V0SW5uZXJEaW1lbnNpb25zKCk7XG4gICAgICB0aGlzLmF1dG9Qb3NpdGlvbl8oKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDTWVudUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5PUEVOKTtcbiAgICAgIHRoaXMuZm9jdXNPbk9wZW5fKGZvY3VzSW5kZXgpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckJvZHlDbGlja0hhbmRsZXIodGhpcy5kb2N1bWVudENsaWNrSGFuZGxlcl8pO1xuICAgICAgaWYgKCF0aGlzLnF1aWNrT3Blbl8pIHtcbiAgICAgICAgdGhpcy5vcGVuQW5pbWF0aW9uRW5kVGltZXJJZF8gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLm9wZW5BbmltYXRpb25FbmRUaW1lcklkXyA9IDA7XG4gICAgICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENNZW51Rm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOSU1BVElOR19PUEVOKTtcbiAgICAgICAgfSwgbnVtYmVycy5UUkFOU0lUSU9OX09QRU5fRFVSQVRJT04pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuaXNPcGVuXyA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBtZW51LlxuICAgKiBAcGFyYW0ge0V2ZW50PX0gZXZ0XG4gICAqL1xuICBjbG9zZShldnQgPSBudWxsKSB7XG4gICAgY29uc3QgdGFyZ2V0SXNEaXNhYmxlZCA9IGV2dCA/XG4gICAgICB0aGlzLmFkYXB0ZXJfLmdldEF0dHJpYnV0ZUZvckV2ZW50VGFyZ2V0KGV2dC50YXJnZXQsIHN0cmluZ3MuQVJJQV9ESVNBQkxFRF9BVFRSKSA9PT0gJ3RydWUnIDpcbiAgICAgIGZhbHNlO1xuXG4gICAgaWYgKHRhcmdldElzRGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJCb2R5Q2xpY2tIYW5kbGVyKHRoaXMuZG9jdW1lbnRDbGlja0hhbmRsZXJfKTtcblxuICAgIGlmICghdGhpcy5xdWlja09wZW5fKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ01lbnVGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQU5JTUFUSU5HX0NMT1NFRCk7XG4gICAgfVxuXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDTWVudUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5PUEVOKTtcbiAgICAgIGlmICghdGhpcy5xdWlja09wZW5fKSB7XG4gICAgICAgIHRoaXMuY2xvc2VBbmltYXRpb25FbmRUaW1lcklkXyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuY2xvc2VBbmltYXRpb25FbmRUaW1lcklkXyA9IDA7XG4gICAgICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENNZW51Rm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOSU1BVElOR19DTE9TRUQpO1xuICAgICAgICB9LCBudW1iZXJzLlRSQU5TSVRJT05fQ0xPU0VfRFVSQVRJT04pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuaXNPcGVuXyA9IGZhbHNlO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVzdG9yZUZvY3VzKCk7XG4gIH1cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLmlzT3Blbl87XG4gIH1cblxuICAvKiogQHJldHVybiB7bnVtYmVyfSAqL1xuICBnZXRTZWxlY3RlZEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLnNlbGVjdGVkSW5kZXhfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBvZiB0aGUgaXRlbSB0byBzZXQgYXMgc2VsZWN0ZWQuXG4gICAqL1xuICBzZXRTZWxlY3RlZEluZGV4KGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID09PSB0aGlzLnNlbGVjdGVkSW5kZXhfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcHJldlNlbGVjdGVkSW5kZXggPSB0aGlzLnNlbGVjdGVkSW5kZXhfO1xuICAgIGlmIChwcmV2U2VsZWN0ZWRJbmRleCA+PSAwKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJtQXR0ckZvck9wdGlvbkF0SW5kZXgocHJldlNlbGVjdGVkSW5kZXgsICdhcmlhLXNlbGVjdGVkJyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJtQ2xhc3NGb3JPcHRpb25BdEluZGV4KHByZXZTZWxlY3RlZEluZGV4LCBjc3NDbGFzc2VzLlNFTEVDVEVEX0xJU1RfSVRFTSk7XG4gICAgfVxuXG4gICAgdGhpcy5zZWxlY3RlZEluZGV4XyA9IGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLmFkYXB0ZXJfLmdldE51bWJlck9mSXRlbXMoKSA/IGluZGV4IDogLTE7XG4gICAgaWYgKHRoaXMuc2VsZWN0ZWRJbmRleF8gPj0gMCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyRm9yT3B0aW9uQXRJbmRleCh0aGlzLnNlbGVjdGVkSW5kZXhfLCAnYXJpYS1zZWxlY3RlZCcsICd0cnVlJyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzRm9yT3B0aW9uQXRJbmRleCh0aGlzLnNlbGVjdGVkSW5kZXhfLCBjc3NDbGFzc2VzLlNFTEVDVEVEX0xJU1RfSVRFTSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCB7TURDTWVudUZvdW5kYXRpb24sIEFuY2hvck1hcmdpbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQHR5cGUge3N0cmluZ3x1bmRlZmluZWR9ICovXG5sZXQgc3RvcmVkVHJhbnNmb3JtUHJvcGVydHlOYW1lXztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBjb3JyZWN0IHRyYW5zZm9ybSBwcm9wZXJ0eSB0byB1c2Ugb24gdGhlIGN1cnJlbnQgYnJvd3Nlci5cbiAqIEBwYXJhbSB7IVdpbmRvd30gZ2xvYmFsT2JqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBmb3JjZVJlZnJlc2hcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtUHJvcGVydHlOYW1lKGdsb2JhbE9iaiwgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgaWYgKHN0b3JlZFRyYW5zZm9ybVByb3BlcnR5TmFtZV8gPT09IHVuZGVmaW5lZCB8fCBmb3JjZVJlZnJlc2gpIHtcbiAgICBjb25zdCBlbCA9IGdsb2JhbE9iai5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb25zdCB0cmFuc2Zvcm1Qcm9wZXJ0eU5hbWUgPSAoJ3RyYW5zZm9ybScgaW4gZWwuc3R5bGUgPyAndHJhbnNmb3JtJyA6ICd3ZWJraXRUcmFuc2Zvcm0nKTtcbiAgICBzdG9yZWRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWVfID0gdHJhbnNmb3JtUHJvcGVydHlOYW1lO1xuICB9XG5cbiAgcmV0dXJuIHN0b3JlZFRyYW5zZm9ybVByb3BlcnR5TmFtZV87XG59XG5cbi8qKlxuICogQ2xhbXBzIGEgdmFsdWUgYmV0d2VlbiB0aGUgbWluaW11bSBhbmQgdGhlIG1heGltdW0sIHJldHVybmluZyB0aGUgY2xhbXBlZCB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICogQHBhcmFtIHtudW1iZXJ9IG1heFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBjbGFtcCh2YWx1ZSwgbWluID0gMCwgbWF4ID0gMSkge1xuICByZXR1cm4gTWF0aC5taW4obWF4LCBNYXRoLm1heChtaW4sIHZhbHVlKSk7XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlYXNpbmcgdmFsdWUgdG8gYXBwbHkgYXQgdGltZSB0LCBmb3IgYSBnaXZlbiBjdWJpYyBiZXppZXIgY3VydmUuXG4gKiBDb250cm9sIHBvaW50cyBQMCBhbmQgUDMgYXJlIGFzc3VtZWQgdG8gYmUgKDAsMCkgYW5kICgxLDEpLCByZXNwZWN0aXZlbHkuXG4gKiBQYXJhbWV0ZXJzIGFyZSBhcyBmb2xsb3dzOlxuICogLSB0aW1lOiBUaGUgY3VycmVudCB0aW1lIGluIHRoZSBhbmltYXRpb24sIHNjYWxlZCBiZXR3ZWVuIDAgYW5kIDEuXG4gKiAtIHgxOiBUaGUgeCB2YWx1ZSBvZiBjb250cm9sIHBvaW50IFAxLlxuICogLSB5MTogVGhlIHkgdmFsdWUgb2YgY29udHJvbCBwb2ludCBQMS5cbiAqIC0geDI6IFRoZSB4IHZhbHVlIG9mIGNvbnRyb2wgcG9pbnQgUDIuXG4gKiAtIHkyOiBUaGUgeSB2YWx1ZSBvZiBjb250cm9sIHBvaW50IFAyLlxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gKiBAcGFyYW0ge251bWJlcn0geDJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBiZXppZXJQcm9ncmVzcyh0aW1lLCB4MSwgeTEsIHgyLCB5Mikge1xuICByZXR1cm4gZ2V0QmV6aWVyQ29vcmRpbmF0ZV8oc29sdmVQb3NpdGlvbkZyb21YVmFsdWVfKHRpbWUsIHgxLCB4MiksIHkxLCB5Mik7XG59XG5cbi8qKlxuICogQ29tcHV0ZSBhIHNpbmdsZSBjb29yZGluYXRlIGF0IGEgcG9zaXRpb24gcG9pbnQgYmV0d2VlbiAwIGFuZCAxLlxuICogYzEgYW5kIGMyIGFyZSB0aGUgbWF0Y2hpbmcgY29vcmRpbmF0ZSBvbiBjb250cm9sIHBvaW50cyBQMSBhbmQgUDIsIHJlc3BlY3RpdmVseS5cbiAqIENvbnRyb2wgcG9pbnRzIFAwIGFuZCBQMyBhcmUgYXNzdW1lZCB0byBiZSAoMCwwKSBhbmQgKDEsMSksIHJlc3BlY3RpdmVseS5cbiAqIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtbGlicmFyeS9ibG9iL21hc3Rlci9jbG9zdXJlL2dvb2cvbWF0aC9iZXppZXIuanMuXG4gKiBAcGFyYW0ge251bWJlcn0gdFxuICogQHBhcmFtIHtudW1iZXJ9IGMxXG4gKiBAcGFyYW0ge251bWJlcn0gYzJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0QmV6aWVyQ29vcmRpbmF0ZV8odCwgYzEsIGMyKSB7XG4gIC8vIFNwZWNpYWwgY2FzZSBzdGFydCBhbmQgZW5kLlxuICBpZiAodCA9PT0gMCB8fCB0ID09PSAxKSB7XG4gICAgcmV0dXJuIHQ7XG4gIH1cblxuICAvLyBTdGVwIG9uZSAtIGZyb20gNCBwb2ludHMgdG8gM1xuICBsZXQgaWMwID0gdCAqIGMxO1xuICBsZXQgaWMxID0gYzEgKyB0ICogKGMyIC0gYzEpO1xuICBjb25zdCBpYzIgPSBjMiArIHQgKiAoMSAtIGMyKTtcblxuICAvLyBTdGVwIHR3byAtIGZyb20gMyBwb2ludHMgdG8gMlxuICBpYzAgKz0gdCAqIChpYzEgLSBpYzApO1xuICBpYzEgKz0gdCAqIChpYzIgLSBpYzEpO1xuXG4gIC8vIEZpbmFsIHN0ZXAgLSBsYXN0IHBvaW50XG4gIHJldHVybiBpYzAgKyB0ICogKGljMSAtIGljMCk7XG59XG5cbi8qKlxuICogUHJvamVjdCBhIHBvaW50IG9udG8gdGhlIEJlemllciBjdXJ2ZSwgZnJvbSBhIGdpdmVuIFguIENhbGN1bGF0ZXMgdGhlIHBvc2l0aW9uIHQgYWxvbmcgdGhlIGN1cnZlLlxuICogQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9nb29nbGUvY2xvc3VyZS1saWJyYXJ5L2Jsb2IvbWFzdGVyL2Nsb3N1cmUvZ29vZy9tYXRoL2Jlemllci5qcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSB4VmFsXG4gKiBAcGFyYW0ge251bWJlcn0geDFcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBzb2x2ZVBvc2l0aW9uRnJvbVhWYWx1ZV8oeFZhbCwgeDEsIHgyKSB7XG4gIGNvbnN0IEVQU0lMT04gPSAxZS02O1xuICBjb25zdCBNQVhfSVRFUkFUSU9OUyA9IDg7XG5cbiAgaWYgKHhWYWwgPD0gMCkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2UgaWYgKHhWYWwgPj0gMSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLy8gSW5pdGlhbCBlc3RpbWF0ZSBvZiB0IHVzaW5nIGxpbmVhciBpbnRlcnBvbGF0aW9uLlxuICBsZXQgdCA9IHhWYWw7XG5cbiAgLy8gVHJ5IGdyYWRpZW50IGRlc2NlbnQgdG8gc29sdmUgZm9yIHQuIElmIGl0IHdvcmtzLCBpdCBpcyB2ZXJ5IGZhc3QuXG4gIGxldCB0TWluID0gMDtcbiAgbGV0IHRNYXggPSAxO1xuICBsZXQgdmFsdWUgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IE1BWF9JVEVSQVRJT05TOyBpKyspIHtcbiAgICB2YWx1ZSA9IGdldEJlemllckNvb3JkaW5hdGVfKHQsIHgxLCB4Mik7XG4gICAgY29uc3QgZGVyaXZhdGl2ZSA9IChnZXRCZXppZXJDb29yZGluYXRlXyh0ICsgRVBTSUxPTiwgeDEsIHgyKSAtIHZhbHVlKSAvIEVQU0lMT047XG4gICAgaWYgKE1hdGguYWJzKHZhbHVlIC0geFZhbCkgPCBFUFNJTE9OKSB7XG4gICAgICByZXR1cm4gdDtcbiAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGRlcml2YXRpdmUpIDwgRVBTSUxPTikge1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2YWx1ZSA8IHhWYWwpIHtcbiAgICAgICAgdE1pbiA9IHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0TWF4ID0gdDtcbiAgICAgIH1cbiAgICAgIHQgLT0gKHZhbHVlIC0geFZhbCkgLyBkZXJpdmF0aXZlO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHRoZSBncmFkaWVudCBkZXNjZW50IGdvdCBzdHVjayBpbiBhIGxvY2FsIG1pbmltdW0sIGUuZy4gYmVjYXVzZVxuICAvLyB0aGUgZGVyaXZhdGl2ZSB3YXMgY2xvc2UgdG8gMCwgdXNlIGEgRGljaG90b215IHJlZmluZW1lbnQgaW5zdGVhZC5cbiAgLy8gV2UgbGltaXQgdGhlIG51bWJlciBvZiBpbnRlcmF0aW9ucyB0byA4LlxuICBmb3IgKGxldCBpID0gMDsgTWF0aC5hYnModmFsdWUgLSB4VmFsKSA+IEVQU0lMT04gJiYgaSA8IE1BWF9JVEVSQVRJT05TOyBpKyspIHtcbiAgICBpZiAodmFsdWUgPCB4VmFsKSB7XG4gICAgICB0TWluID0gdDtcbiAgICAgIHQgPSAodCArIHRNYXgpIC8gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgdE1heCA9IHQ7XG4gICAgICB0ID0gKHQgKyB0TWluKSAvIDI7XG4gICAgfVxuICAgIHZhbHVlID0gZ2V0QmV6aWVyQ29vcmRpbmF0ZV8odCwgeDEsIHgyKTtcbiAgfVxuICByZXR1cm4gdDtcbn1cblxuZXhwb3J0IHtnZXRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWUsIGNsYW1wLCBiZXppZXJQcm9ncmVzc307XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgXG4gICAgcmVmPVwicm9vdFwiIFxuICAgIDpjbGFzcz1cImNsYXNzZXNcIiBcbiAgICA6c3R5bGU9XCJzdHlsZXNcIiBcbiAgICBjbGFzcz1cIm1kYy1tZW51IG1kYy1zaW1wbGUtbWVudVwiIFxuICAgIHRhYmluZGV4PVwiLTFcIj5cbiAgICA8dWwgXG4gICAgICByZWY9XCJpdGVtc1wiIFxuICAgICAgY2xhc3M9XCJtZGMtc2ltcGxlLW1lbnVfX2l0ZW1zIG1kYy1saXN0XCIgXG4gICAgICByb2xlPVwibWVudVwiIFxuICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCI+XG4gICAgICA8c2xvdC8+XG4gICAgPC91bD5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgTURDTWVudUZvdW5kYXRpb24gfSBmcm9tICdAbWF0ZXJpYWwvbWVudS9mb3VuZGF0aW9uJ1xuaW1wb3J0IHsgZ2V0VHJhbnNmb3JtUHJvcGVydHlOYW1lIH0gZnJvbSAnQG1hdGVyaWFsL21lbnUvdXRpbCdcbmltcG9ydCB7IGVtaXRDdXN0b21FdmVudCB9IGZyb20gJy4uL2Jhc2UnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1tZW51JyxcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAnb3BlbicsXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgb3BlbjogW0Jvb2xlYW4sIE9iamVjdF0sXG4gICAgJ3F1aWNrLW9wZW4nOiBCb29sZWFuLFxuICAgICdhbmNob3ItY29ybmVyJzogW1N0cmluZywgTnVtYmVyXSxcbiAgICAnYW5jaG9yLW1hcmdpbic6IE9iamVjdFxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7fSxcbiAgICAgIHN0eWxlczoge30sXG4gICAgICBpdGVtczogW11cbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgb3BlbjogJ29uT3Blbl8nLFxuICAgIHF1aWNrT3Blbihudikge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldFF1aWNrT3BlbihudilcbiAgICB9LFxuICAgIGFuY2hvckNvcm5lcihudikge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldEFuY2hvckNvcm5lcihOdW1iZXIobnYpKVxuICAgIH0sXG4gICAgYW5jaG9yTWFyZ2luKG52KSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0QW5jaG9yTWFyZ2luKG52KVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICBjb25zdCByZWZyZXNoSXRlbXMgPSAoKSA9PiB7XG4gICAgICB0aGlzLml0ZW1zID0gW10uc2xpY2UuY2FsbChcbiAgICAgICAgdGhpcy4kcmVmcy5pdGVtcy5xdWVyeVNlbGVjdG9yQWxsKCcubWRjLWxpc3QtaXRlbVtyb2xlXScpXG4gICAgICApXG4gICAgICB0aGlzLiRlbWl0KCd1cGRhdGUnKVxuICAgIH1cbiAgICB0aGlzLnNsb3RPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHJlZnJlc2hJdGVtcygpKVxuICAgIHRoaXMuc2xvdE9ic2VydmVyLm9ic2VydmUodGhpcy4kZWwsIHtcbiAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgIHN1YnRyZWU6IHRydWVcbiAgICB9KVxuXG4gICAgdGhpcy5fcHJldmlvdXNGb2N1cyA9IHVuZGVmaW5lZFxuXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ01lbnVGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKSxcbiAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kcmVmcy5yb290LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpLFxuICAgICAgaGFzTmVjZXNzYXJ5RG9tOiAoKSA9PiBCb29sZWFuKHRoaXMuJHJlZnMuaXRlbXMpLFxuICAgICAgZ2V0QXR0cmlidXRlRm9yRXZlbnRUYXJnZXQ6ICh0YXJnZXQsIGF0dHJpYnV0ZU5hbWUpID0+XG4gICAgICAgIHRhcmdldC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSksXG4gICAgICBnZXRJbm5lckRpbWVuc2lvbnM6ICgpID0+ICh7XG4gICAgICAgIHdpZHRoOiB0aGlzLiRyZWZzLml0ZW1zLm9mZnNldFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuJHJlZnMuaXRlbXMub2Zmc2V0SGVpZ2h0XG4gICAgICB9KSxcbiAgICAgIGhhc0FuY2hvcjogKCkgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5yb290LnBhcmVudEVsZW1lbnQgJiZcbiAgICAgICAgdGhpcy4kcmVmcy5yb290LnBhcmVudEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdtZGMtbWVudS1hbmNob3InKSxcbiAgICAgIGdldEFuY2hvckRpbWVuc2lvbnM6ICgpID0+XG4gICAgICAgIHRoaXMuJHJlZnMucm9vdC5wYXJlbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgZ2V0V2luZG93RGltZW5zaW9uczogKCkgPT4gKHtcbiAgICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodFxuICAgICAgfSksXG4gICAgICBnZXROdW1iZXJPZkl0ZW1zOiAoKSA9PiB0aGlzLml0ZW1zLmxlbmd0aCxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5yb290LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciksXG4gICAgICByZWdpc3RlckJvZHlDbGlja0hhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlckJvZHlDbGlja0hhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZXIpLFxuICAgICAgZ2V0SW5kZXhGb3JFdmVudFRhcmdldDogdGFyZ2V0ID0+IHRoaXMuaXRlbXMuaW5kZXhPZih0YXJnZXQpLFxuICAgICAgbm90aWZ5U2VsZWN0ZWQ6IGV2dERhdGEgPT4ge1xuICAgICAgICBjb25zdCBldnQgPSB7XG4gICAgICAgICAgaW5kZXg6IGV2dERhdGEuaW5kZXgsXG4gICAgICAgICAgaXRlbTogdGhpcy5pdGVtc1tldnREYXRhLmluZGV4XVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGZhbHNlKVxuICAgICAgICB0aGlzLiRlbWl0KCdzZWxlY3QnLCBldnQpXG4gICAgICAgIGVtaXRDdXN0b21FdmVudCh0aGlzLiRlbCwgTURDTWVudUZvdW5kYXRpb24uc3RyaW5ncy5TRUxFQ1RFRF9FVkVOVCwgZXZ0KVxuICAgICAgfSxcbiAgICAgIG5vdGlmeUNhbmNlbDogKCkgPT4ge1xuICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBmYWxzZSlcbiAgICAgICAgdGhpcy4kZW1pdCgnY2FuY2VsJylcbiAgICAgICAgZW1pdEN1c3RvbUV2ZW50KHRoaXMuJGVsLCBNRENNZW51Rm91bmRhdGlvbi5zdHJpbmdzLkNBTkNFTF9FVkVOVCwge30pXG4gICAgICB9LFxuICAgICAgc2F2ZUZvY3VzOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzRm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50XG4gICAgICB9LFxuICAgICAgcmVzdG9yZUZvY3VzOiAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9wcmV2aW91c0ZvY3VzKSB7XG4gICAgICAgICAgdGhpcy5fcHJldmlvdXNGb2N1cy5mb2N1cygpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpc0ZvY3VzZWQ6ICgpID0+IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuJHJlZnMucm9vdCxcbiAgICAgIGZvY3VzOiAoKSA9PiB0aGlzLiRyZWZzLnJvb3QuZm9jdXMoKSxcbiAgICAgIGdldEZvY3VzZWRJdGVtSW5kZXg6ICgpID0+IHRoaXMuaXRlbXMuaW5kZXhPZihkb2N1bWVudC5hY3RpdmVFbGVtZW50KSxcbiAgICAgIGZvY3VzSXRlbUF0SW5kZXg6IGluZGV4ID0+IHRoaXMuaXRlbXNbaW5kZXhdLmZvY3VzKCksXG4gICAgICBpc1J0bDogKCkgPT5cbiAgICAgICAgZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRyZWZzLnJvb3QpLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpID09PVxuICAgICAgICAncnRsJyxcbiAgICAgIHNldFRyYW5zZm9ybU9yaWdpbjogb3JpZ2luID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KFxuICAgICAgICAgIHRoaXMuc3R5bGVzLFxuICAgICAgICAgIGAke2dldFRyYW5zZm9ybVByb3BlcnR5TmFtZSh3aW5kb3cpfS1vcmlnaW5gLFxuICAgICAgICAgIG9yaWdpblxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgc2V0UG9zaXRpb246IHBvc2l0aW9uID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuc3R5bGVzLCAnbGVmdCcsIHBvc2l0aW9uLmxlZnQpXG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnN0eWxlcywgJ3JpZ2h0JywgcG9zaXRpb24ucmlnaHQpXG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnN0eWxlcywgJ3RvcCcsIHBvc2l0aW9uLnRvcClcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuc3R5bGVzLCAnYm90dG9tJywgcG9zaXRpb24uYm90dG9tKVxuICAgICAgfSxcbiAgICAgIHNldE1heEhlaWdodDogaGVpZ2h0ID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuc3R5bGVzLCAnbWF4LWhlaWdodCcsIGhlaWdodClcbiAgICAgIH0sXG4gICAgICBzZXRBdHRyRm9yT3B0aW9uQXRJbmRleDogKGluZGV4LCBhdHRyLCB2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLml0ZW1zW2luZGV4XS5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpXG4gICAgICB9LFxuICAgICAgcm1BdHRyRm9yT3B0aW9uQXRJbmRleDogKGluZGV4LCBhdHRyKSA9PiB7XG4gICAgICAgIHRoaXMuaXRlbXNbaW5kZXhdLnJlbW92ZUF0dHJpYnV0ZShhdHRyKVxuICAgICAgfSxcbiAgICAgIGFkZENsYXNzRm9yT3B0aW9uQXRJbmRleDogKGluZGV4LCBjbGFzc05hbWUpID0+IHtcbiAgICAgICAgdGhpcy5pdGVtc1tpbmRleF0uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgcm1DbGFzc0Zvck9wdGlvbkF0SW5kZXg6IChpbmRleCwgY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgIHRoaXMuaXRlbXNbaW5kZXhdLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZWZyZXNoSXRlbXMoKVxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgICBpZiAodGhpcy5hbmNob3JDb3JuZXIgIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldEFuY2hvckNvcm5lcihOdW1iZXIodGhpcy5hbmNob3JDb3JuZXIpKVxuICAgIH1cbiAgICBpZiAodGhpcy5hbmNob3JNYXJnaW4gIT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldEFuY2hvck1hcmdpbih0aGlzLmFuY2hvck1hcmdpbilcbiAgICB9XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5fcHJldmlvdXNGb2N1cyA9IG51bGxcbiAgICB0aGlzLnNsb3RPYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIG9uT3Blbl8odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24ub3Blbih0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnID8gdmFsdWUgOiB2b2lkIDApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24uY2xvc2UoKVxuICAgICAgfVxuICAgIH0sXG4gICAgc2hvdyhvcHRpb25zKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24ub3BlbihvcHRpb25zKVxuICAgIH0sXG4gICAgaGlkZSgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5jbG9zZSgpXG4gICAgfSxcbiAgICBpc09wZW4oKSB7XG4gICAgICByZXR1cm4gdGhpcy5mb3VuZGF0aW9uID8gdGhpcy5mb3VuZGF0aW9uLmlzT3BlbigpIDogZmFsc2VcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8bGkgXG4gICAgOnRhYmluZGV4PVwiZGlzYWJsZWQ/Jy0xJzonMCdcIiBcbiAgICA6YXJpYS1kaXNhYmxlZD1cImRpc2FibGVkXCIgXG4gICAgY2xhc3M9XCJtZGMtbWVudS1pdGVtIG1kYy1saXN0LWl0ZW1cIlxuICAgIHJvbGU9XCJtZW51aXRlbVwiXG4gID5cbiAgICA8c2xvdC8+XG4gIDwvbGk+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLW1lbnUtaXRlbScsXG4gIHByb3BzOiB7XG4gICAgZGlzYWJsZWQ6IEJvb2xlYW5cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxsaSBcbiAgICByb2xlPVwic2VwYXJhdG9yXCIgXG4gICAgY2xhc3M9XCJtZGMtbWVudS1kaXZpZGVyIG1kYy1saXN0LWRpdmlkZXJcIi8+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLW1lbnUtZGl2aWRlcidcbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwibWRjLW1lbnUtYW5jaG9yXCI+XG4gICAgPHNsb3QvPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbWVudS1hbmNob3InXG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY01lbnUgZnJvbSAnLi9tZGMtbWVudS52dWUnXG5pbXBvcnQgbWRjTWVudUl0ZW0gZnJvbSAnLi9tZGMtbWVudS1pdGVtLnZ1ZSdcbmltcG9ydCBtZGNNZW51RGl2aWRlciBmcm9tICcuL21kYy1tZW51LWRpdmlkZXIudnVlJ1xuaW1wb3J0IG1kY01lbnVBbmNob3IgZnJvbSAnLi9tZGMtbWVudS1hbmNob3IudnVlJ1xuXG5leHBvcnQgeyBtZGNNZW51LCBtZGNNZW51SXRlbSwgbWRjTWVudURpdmlkZXIsIG1kY01lbnVBbmNob3IgfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjTWVudSxcbiAgbWRjTWVudUl0ZW0sXG4gIG1kY01lbnVEaXZpZGVyLFxuICBtZGNNZW51QW5jaG9yXG59KVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZX0gZnJvbSAnQG1hdGVyaWFsL3NlbGVjdGlvbi1jb250cm9sL2luZGV4JztcblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFJhZGlvLiBQcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIG1hbmFnaW5nXG4gKiAtIGNsYXNzZXNcbiAqIC0gZG9tXG4gKlxuICogQWRkaXRpb25hbGx5LCBwcm92aWRlcyB0eXBlIGluZm9ybWF0aW9uIGZvciB0aGUgYWRhcHRlciB0byB0aGUgQ2xvc3VyZVxuICogY29tcGlsZXIuXG4gKlxuICogSW1wbGVtZW50IHRoaXMgYWRhcHRlciBmb3IgeW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlIHRvIGRlbGVnYXRlIHVwZGF0ZXMgdG9cbiAqIHRoZSBjb21wb25lbnQgaW4geW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlLiBTZWUgYXJjaGl0ZWN0dXJlIGRvY3VtZW50YXRpb25cbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2NvZGUvYXJjaGl0ZWN0dXJlLm1kXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENSYWRpb0FkYXB0ZXIge1xuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHshTURDU2VsZWN0aW9uQ29udHJvbFN0YXRlfSAqL1xuICBnZXROYXRpdmVDb250cm9sKCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDUmFkaW9BZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgTkFUSVZFX0NPTlRST0xfU0VMRUNUT1I6ICcubWRjLXJhZGlvX19uYXRpdmUtY29udHJvbCcsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIFJPT1Q6ICdtZGMtcmFkaW8nLFxuICBESVNBQkxFRDogJ21kYy1yYWRpby0tZGlzYWJsZWQnLFxufTtcblxuZXhwb3J0IHtzdHJpbmdzLCBjc3NDbGFzc2VzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZX0gZnJvbSAnQG1hdGVyaWFsL3NlbGVjdGlvbi1jb250cm9sL2luZGV4JztcbmltcG9ydCBNRENSYWRpb0FkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENSYWRpb0FkYXB0ZXI+fVxuICovXG5jbGFzcyBNRENSYWRpb0ZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7Y3NzQ2xhc3Nlc30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nc30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4geyFNRENSYWRpb0FkYXB0ZXJ9ICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1JhZGlvQWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBnZXROYXRpdmVDb250cm9sOiAoKSA9PiAvKiAhTURDU2VsZWN0aW9uQ29udHJvbFN0YXRlICovIHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzQ2hlY2tlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVDb250cm9sXygpLmNoZWNrZWQ7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBjaGVja2VkICovXG4gIHNldENoZWNrZWQoY2hlY2tlZCkge1xuICAgIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS5jaGVja2VkID0gY2hlY2tlZDtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc0Rpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkuZGlzYWJsZWQ7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZCAqL1xuICBzZXREaXNhYmxlZChkaXNhYmxlZCkge1xuICAgIGNvbnN0IHtESVNBQkxFRH0gPSBNRENSYWRpb0ZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICB0aGlzLmdldE5hdGl2ZUNvbnRyb2xfKCkuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoRElTQUJMRUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKERJU0FCTEVEKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHJldHVybiB7P3N0cmluZ30gKi9cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TmF0aXZlQ29udHJvbF8oKS52YWx1ZTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlICovXG4gIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5nZXROYXRpdmVDb250cm9sXygpLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IU1EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldE5hdGl2ZUNvbnRyb2xfKCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmdldE5hdGl2ZUNvbnRyb2woKSB8fCB7XG4gICAgICBjaGVja2VkOiBmYWxzZSxcbiAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDUmFkaW9Gb3VuZGF0aW9uO1xuIiwiPHRlbXBsYXRlPlxuICA8ZGl2XG4gICAgOmNsYXNzPVwiZm9ybUZpZWxkQ2xhc3Nlc1wiXG4gICAgY2xhc3M9XCJtZGMtcmFkaW8td3JhcHBlclwiPlxuICAgIDxkaXZcbiAgICAgIHJlZj1cInJvb3RcIlxuICAgICAgOmNsYXNzPVwiY2xhc3Nlc1wiXG4gICAgICA6c3R5bGU9XCJzdHlsZXNcIlxuICAgICAgY2xhc3M9XCJtZGMtcmFkaW9cIj5cbiAgICAgIDxpbnB1dFxuICAgICAgICByZWY9XCJjb250cm9sXCJcbiAgICAgICAgOmlkPVwidm1hX3VpZF9cIlxuICAgICAgICA6bmFtZT1cIm5hbWVcIlxuICAgICAgICB0eXBlPVwicmFkaW9cIlxuICAgICAgICBjbGFzcz1cIm1kYy1yYWRpb19fbmF0aXZlLWNvbnRyb2xcIlxuICAgICAgICBAY2hhbmdlPVwic3luY1wiPlxuXG4gICAgICA8ZGl2XG4gICAgICAgIGNsYXNzPVwibWRjLXJhZGlvX19iYWNrZ3JvdW5kXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJtZGMtcmFkaW9fX291dGVyLWNpcmNsZVwiLz5cbiAgICAgICAgPGRpdiBjbGFzcz1cIm1kYy1yYWRpb19faW5uZXItY2lyY2xlXCIvPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGxhYmVsXG4gICAgICByZWY9XCJsYWJlbFwiXG4gICAgICA6Zm9yPVwidm1hX3VpZF9cIj48c2xvdD57eyBsYWJlbCB9fTwvc2xvdD48L2xhYmVsPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDUmFkaW9Gb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9yYWRpby9mb3VuZGF0aW9uJ1xuaW1wb3J0IE1EQ0Zvcm1GaWVsZEZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Zvcm0tZmllbGQvZm91bmRhdGlvbidcbmltcG9ydCB7IERpc3BhdGNoRm9jdXNNaXhpbiwgVk1BVW5pcXVlSWRNaXhpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgeyBSaXBwbGVCYXNlIH0gZnJvbSAnLi4vcmlwcGxlJ1xuaW1wb3J0IHsgYXBwbHlQYXNzaXZlIH0gZnJvbSAnLi4vYmFzZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXJhZGlvJyxcbiAgbWl4aW5zOiBbRGlzcGF0Y2hGb2N1c01peGluLCBWTUFVbmlxdWVJZE1peGluXSxcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAncGlja2VkJyxcbiAgICBldmVudDogJ2NoYW5nZSdcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBuYW1lOiB7IHR5cGU6IFN0cmluZywgcmVxdWlyZWQ6IHRydWUgfSxcbiAgICB2YWx1ZTogU3RyaW5nLFxuICAgIHBpY2tlZDogU3RyaW5nLFxuICAgIGNoZWNrZWQ6IEJvb2xlYW4sXG4gICAgbGFiZWw6IFN0cmluZyxcbiAgICAnYWxpZ24tZW5kJzogQm9vbGVhbixcbiAgICBkaXNhYmxlZDogQm9vbGVhblxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7fSxcbiAgICAgIHN0eWxlczoge30sXG4gICAgICBmb3JtRmllbGRDbGFzc2VzOiB7XG4gICAgICAgICdtZGMtZm9ybS1maWVsZCc6IHRoaXMubGFiZWwsXG4gICAgICAgICdtZGMtZm9ybS1maWVsZC0tYWxpZ24tZW5kJzogdGhpcy5sYWJlbCAmJiB0aGlzLmFsaWduRW5kXG4gICAgICB9XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIGNoZWNrZWQ6ICdzZXRDaGVja2VkJyxcbiAgICBkaXNhYmxlZCh2YWx1ZSkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHZhbHVlKVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICAvLyBhZGQgZm91bmRhdGlvblxuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENSYWRpb0ZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpLFxuICAgICAgZ2V0TmF0aXZlQ29udHJvbDogKCkgPT4gdGhpcy4kcmVmcy5jb250cm9sXG4gICAgfSlcblxuICAgIC8vIGFkZCByaXBwbGVcbiAgICB0aGlzLnJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMsIHtcbiAgICAgIGlzVW5ib3VuZGVkOiAoKSA9PiB0cnVlLFxuICAgICAgaXNTdXJmYWNlQWN0aXZlOiAoKSA9PiBmYWxzZSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuY29udHJvbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciwgYXBwbHlQYXNzaXZlKCkpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmNvbnRyb2wucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIsIGFwcGx5UGFzc2l2ZSgpKVxuICAgICAgfSxcbiAgICAgIGNvbXB1dGVCb3VuZGluZ1JlY3Q6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMucm9vdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLmZvcm1GaWVsZCA9IG5ldyBNRENGb3JtRmllbGRGb3VuZGF0aW9uKHtcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmxhYmVsLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmxhYmVsLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBhY3RpdmF0ZUlucHV0UmlwcGxlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMucmlwcGxlICYmIHRoaXMucmlwcGxlLmFjdGl2YXRlKClcbiAgICAgIH0sXG4gICAgICBkZWFjdGl2YXRlSW5wdXRSaXBwbGU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5yaXBwbGUgJiYgdGhpcy5yaXBwbGUuZGVhY3RpdmF0ZSgpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgICB0aGlzLnJpcHBsZS5pbml0KClcbiAgICB0aGlzLmZvcm1GaWVsZC5pbml0KClcblxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXRWYWx1ZSh0aGlzLnZhbHVlID8gdGhpcy52YWx1ZSA6IHRoaXMubGFiZWwpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHRoaXMuZGlzYWJsZWQpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldENoZWNrZWQoXG4gICAgICB0aGlzLmNoZWNrZWQgfHwgdGhpcy5waWNrZWQgPT0gdGhpcy5mb3VuZGF0aW9uLmdldFZhbHVlKClcbiAgICApXG5cbiAgICAvLyByZWZyZXNoIG1vZGVsXG4gICAgdGhpcy5jaGVja2VkICYmIHRoaXMuc3luYygpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5mb3JtRmllbGQuZGVzdHJveSgpXG4gICAgdGhpcy5yaXBwbGUuZGVzdHJveSgpXG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgc2V0Q2hlY2tlZChjaGVja2VkKSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRDaGVja2VkKGNoZWNrZWQpXG4gICAgfSxcbiAgICBpc0NoZWNrZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5mb3VuZGF0aW9uLmlzQ2hlY2tlZCgpXG4gICAgfSxcbiAgICBzeW5jKCkge1xuICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgdGhpcy5mb3VuZGF0aW9uLmdldFZhbHVlKCkpXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY1JhZGlvIGZyb20gJy4vbWRjLXJhZGlvLnZ1ZSdcblxuZXhwb3J0IHsgbWRjUmFkaW8gfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjUmFkaW9cbn0pXG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgQk9YOiAnbWRjLXNlbGVjdC0tYm94JyxcbiAgRElTQUJMRUQ6ICdtZGMtc2VsZWN0LS1kaXNhYmxlZCcsXG4gIFJPT1Q6ICdtZGMtc2VsZWN0JyxcbiAgT1VUTElORUQ6ICdtZGMtc2VsZWN0LS1vdXRsaW5lZCcsXG59O1xuXG5jb25zdCBzdHJpbmdzID0ge1xuICBDSEFOR0VfRVZFTlQ6ICdNRENTZWxlY3Q6Y2hhbmdlJyxcbiAgTElORV9SSVBQTEVfU0VMRUNUT1I6ICcubWRjLWxpbmUtcmlwcGxlJyxcbiAgTEFCRUxfU0VMRUNUT1I6ICcubWRjLWZsb2F0aW5nLWxhYmVsJyxcbiAgTkFUSVZFX0NPTlRST0xfU0VMRUNUT1I6ICcubWRjLXNlbGVjdF9fbmF0aXZlLWNvbnRyb2wnLFxuICBPVVRMSU5FX1NFTEVDVE9SOiAnLm1kYy1ub3RjaGVkLW91dGxpbmUnLFxufTtcblxuLyoqIEBlbnVtIHtudW1iZXJ9ICovXG5jb25zdCBudW1iZXJzID0ge1xuICBMQUJFTF9TQ0FMRTogMC43NSxcbn07XG5cbmV4cG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc307XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge01EQ0ZvdW5kYXRpb259IGZyb20gJ0BtYXRlcmlhbC9iYXNlL2luZGV4JztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNRENTZWxlY3RGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICByZXR1cm4gbnVtYmVycztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBoYXNDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiBmYWxzZSxcbiAgICAgIGZsb2F0TGFiZWw6ICgvKiB2YWx1ZTogYm9vbGVhbiAqLykgPT4ge30sXG4gICAgICBhY3RpdmF0ZUJvdHRvbUxpbmU6ICgpID0+IHt9LFxuICAgICAgZGVhY3RpdmF0ZUJvdHRvbUxpbmU6ICgpID0+IHt9LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBnZXRTZWxlY3RlZEluZGV4OiAoKSA9PiAvKiBudW1iZXIgKi8gLTEsXG4gICAgICBzZXRTZWxlY3RlZEluZGV4OiAoLyogaW5kZXg6IG51bWJlciAqLykgPT4ge30sXG4gICAgICBzZXREaXNhYmxlZDogKC8qIGRpc2FibGVkOiBib29sZWFuICovKSA9PiB7fSxcbiAgICAgIGdldFZhbHVlOiAoKSA9PiAvKiBzdHJpbmcgKi8gJycsXG4gICAgICBzZXRWYWx1ZTogKC8qIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgaXNSdGw6ICgpID0+IGZhbHNlLFxuICAgICAgaGFzTGFiZWw6ICgpID0+IHt9LFxuICAgICAgZ2V0TGFiZWxXaWR0aDogKCkgPT4ge30sXG4gICAgICBoYXNPdXRsaW5lOiAoKSA9PiB7fSxcbiAgICAgIG5vdGNoT3V0bGluZTogKCkgPT4ge30sXG4gICAgICBjbG9zZU91dGxpbmU6ICgpID0+IHt9LFxuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENTZWxlY3RGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICB0aGlzLmZvY3VzSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZUZvY3VzXyhldnQpO1xuICAgIHRoaXMuYmx1ckhhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVCbHVyXyhldnQpO1xuICAgIHRoaXMuc2VsZWN0aW9uSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZVNlbGVjdF8oZXZ0KTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignZm9jdXMnLCB0aGlzLmZvY3VzSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignY2hhbmdlJywgdGhpcy5zZWxlY3Rpb25IYW5kbGVyXyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignZm9jdXMnLCB0aGlzLmZvY3VzSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignYmx1cicsIHRoaXMuYmx1ckhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2NoYW5nZScsIHRoaXMuc2VsZWN0aW9uSGFuZGxlcl8pO1xuICB9XG5cbiAgc2V0U2VsZWN0ZWRJbmRleChpbmRleCkge1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0U2VsZWN0ZWRJbmRleChpbmRleCk7XG4gICAgdGhpcy5mbG9hdExhYmVsV2l0aFZhbHVlXygpO1xuICB9XG5cbiAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldFZhbHVlKHZhbHVlKTtcbiAgICB0aGlzLnNldFNlbGVjdGVkSW5kZXgodGhpcy5hZGFwdGVyXy5nZXRTZWxlY3RlZEluZGV4KCkpO1xuICB9XG5cbiAgc2V0RGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICBjb25zdCB7RElTQUJMRUR9ID0gTURDU2VsZWN0Rm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0RGlzYWJsZWQoZGlzYWJsZWQpO1xuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhESVNBQkxFRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoRElTQUJMRUQpO1xuICAgIH1cbiAgfVxuXG4gIGZsb2F0TGFiZWxXaXRoVmFsdWVfKCkge1xuICAgIGNvbnN0IG9wdGlvbkhhc1ZhbHVlID0gdGhpcy5hZGFwdGVyXy5nZXRWYWx1ZSgpLmxlbmd0aCA+IDA7XG4gICAgdGhpcy5hZGFwdGVyXy5mbG9hdExhYmVsKG9wdGlvbkhhc1ZhbHVlKTtcbiAgICB0aGlzLm5vdGNoT3V0bGluZShvcHRpb25IYXNWYWx1ZSk7XG4gIH1cblxuICBoYW5kbGVGb2N1c18oKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5mbG9hdExhYmVsKHRydWUpO1xuICAgIHRoaXMubm90Y2hPdXRsaW5lKHRydWUpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWN0aXZhdGVCb3R0b21MaW5lKCk7XG4gIH1cblxuICBoYW5kbGVCbHVyXygpIHtcbiAgICB0aGlzLmZsb2F0TGFiZWxXaXRoVmFsdWVfKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZWFjdGl2YXRlQm90dG9tTGluZSgpO1xuICB9XG5cbiAgaGFuZGxlU2VsZWN0XygpIHtcbiAgICB0aGlzLnNldFNlbGVjdGVkSW5kZXgodGhpcy5hZGFwdGVyXy5nZXRTZWxlY3RlZEluZGV4KCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE9wZW5zL2Nsb3NlcyB0aGUgbm90Y2hlZCBvdXRsaW5lLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wZW5Ob3RjaFxuICAgKi9cbiAgbm90Y2hPdXRsaW5lKG9wZW5Ob3RjaCkge1xuICAgIGlmICghdGhpcy5hZGFwdGVyXy5oYXNPdXRsaW5lKCkgfHwgIXRoaXMuYWRhcHRlcl8uaGFzTGFiZWwoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcGVuTm90Y2gpIHtcbiAgICAgIGNvbnN0IGxhYmVsU2NhbGUgPSBudW1iZXJzLkxBQkVMX1NDQUxFO1xuICAgICAgY29uc3QgbGFiZWxXaWR0aCA9IHRoaXMuYWRhcHRlcl8uZ2V0TGFiZWxXaWR0aCgpICogbGFiZWxTY2FsZTtcbiAgICAgIGNvbnN0IGlzUnRsID0gdGhpcy5hZGFwdGVyXy5pc1J0bCgpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RjaE91dGxpbmUobGFiZWxXaWR0aCwgaXNSdGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmNsb3NlT3V0bGluZSgpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBGbG9hdGluZyBMYWJlbC5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBmbG9hdGluZyBsYWJlbCBpbnRvIHlvdXIgZnJhbWV3b3JrLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvYXV0aG9yaW5nLWNvbXBvbmVudHMubWRcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDRmxvYXRpbmdMYWJlbEFkYXB0ZXIge1xuICAvKipcbiAgICogQWRkcyBhIGNsYXNzIHRvIHRoZSBsYWJlbCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIHRoZSBsYWJlbCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBsYWJlbCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRXaWR0aCgpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiB0aGUgcm9vdCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIHJvb3QgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDRmxvYXRpbmdMYWJlbEFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBMQUJFTF9GTE9BVF9BQk9WRTogJ21kYy1mbG9hdGluZy1sYWJlbC0tZmxvYXQtYWJvdmUnLFxuICBMQUJFTF9TSEFLRTogJ21kYy1mbG9hdGluZy1sYWJlbC0tc2hha2UnLFxufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENGbG9hdGluZ0xhYmVsQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IHtjc3NDbGFzc2VzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ0Zsb2F0aW5nTGFiZWxBZGFwdGVyPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENGbG9hdGluZ0xhYmVsRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBNRENGbG9hdGluZ0xhYmVsQWRhcHRlcn0gZm9yIHR5cGluZyBpbmZvcm1hdGlvbiBvbiBwYXJhbWV0ZXJzIGFuZCByZXR1cm5cbiAgICogdHlwZXMuXG4gICAqIEByZXR1cm4geyFNRENGbG9hdGluZ0xhYmVsQWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ0Zsb2F0aW5nTGFiZWxBZGFwdGVyfSAqLyAoe1xuICAgICAgYWRkQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgZ2V0V2lkdGg6ICgpID0+IHt9LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDRmxvYXRpbmdMYWJlbEFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0Zsb2F0aW5nTGFiZWxGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLnNoYWtlQW5pbWF0aW9uRW5kSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmhhbmRsZVNoYWtlQW5pbWF0aW9uRW5kXygpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdhbmltYXRpb25lbmQnLCB0aGlzLnNoYWtlQW5pbWF0aW9uRW5kSGFuZGxlcl8pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2FuaW1hdGlvbmVuZCcsIHRoaXMuc2hha2VBbmltYXRpb25FbmRIYW5kbGVyXyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIGxhYmVsIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmdldFdpZHRoKCk7XG4gIH1cblxuICAvKipcbiAgICogU3R5bGVzIHRoZSBsYWJlbCB0byBwcm9kdWNlIHRoZSBsYWJlbCBzaGFrZSBmb3IgZXJyb3JzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFNoYWtlIGFkZHMgc2hha2UgY2xhc3MgaWYgdHJ1ZSxcbiAgICogb3RoZXJ3aXNlIHJlbW92ZXMgc2hha2UgY2xhc3MuXG4gICAqL1xuICBzaGFrZShzaG91bGRTaGFrZSkge1xuICAgIGNvbnN0IHtMQUJFTF9TSEFLRX0gPSBNRENGbG9hdGluZ0xhYmVsRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIGlmIChzaG91bGRTaGFrZSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhMQUJFTF9TSEFLRSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTEFCRUxfU0hBS0UpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTdHlsZXMgdGhlIGxhYmVsIHRvIGZsb2F0IG9yIGRvY2suXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkRmxvYXQgYWRkcyBmbG9hdCBjbGFzcyBpZiB0cnVlLCBvdGhlcndpc2UgcmVtb3ZlXG4gICAqIGZsb2F0IGFuZCBzaGFrZSBjbGFzcyB0byBkb2NrIGxhYmVsLlxuICAgKi9cbiAgZmxvYXQoc2hvdWxkRmxvYXQpIHtcbiAgICBjb25zdCB7TEFCRUxfRkxPQVRfQUJPVkUsIExBQkVMX1NIQUtFfSA9IE1EQ0Zsb2F0aW5nTGFiZWxGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgaWYgKHNob3VsZEZsb2F0KSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKExBQkVMX0ZMT0FUX0FCT1ZFKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhMQUJFTF9GTE9BVF9BQk9WRSk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKExBQkVMX1NIQUtFKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhbiBpbnRlcmFjdGlvbiBldmVudCBvbiB0aGUgcm9vdCBlbGVtZW50LlxuICAgKi9cbiAgaGFuZGxlU2hha2VBbmltYXRpb25FbmRfKCkge1xuICAgIGNvbnN0IHtMQUJFTF9TSEFLRX0gPSBNRENGbG9hdGluZ0xhYmVsRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTEFCRUxfU0hBS0UpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0Zsb2F0aW5nTGFiZWxGb3VuZGF0aW9uO1xuIiwiPHRlbXBsYXRlPlxuICA8bGFiZWxcbiAgICA6Y2xhc3M9XCJsYWJlbENsYXNzZXNcIlxuICAgIGNsYXNzPVwibWRjLWZsb2F0aW5nLWxhYmVsXCI+XG4gICAgPHNsb3QgLz5cbiAgPC9sYWJlbD5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDRmxvYXRpbmdMYWJlbEZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Zsb2F0aW5nLWxhYmVsL2ZvdW5kYXRpb24nXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1zZWxlY3QtbGFiZWwnLFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsYWJlbENsYXNzZXM6IHt9XG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENGbG9hdGluZ0xhYmVsRm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMubGFiZWxDbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICB9LFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLmxhYmVsQ2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIGdldFdpZHRoOiAoKSA9PiB0aGlzLiRlbC5vZmZzZXRXaWR0aCxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIGxldCBmb3VuZGF0aW9uID0gdGhpcy5mb3VuZGF0aW9uXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbnVsbFxuICAgIGZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBUZXh0RmllbGQgTGluZSBSaXBwbGUuXG4gKlxuICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIGFkYXB0ZXIgZXhwZWN0ZWQgYnkgdGhlIGZvdW5kYXRpb24uIEltcGxlbWVudCB0aGlzXG4gKiBhZGFwdGVyIHRvIGludGVncmF0ZSB0aGUgbGluZSByaXBwbGUgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ0xpbmVSaXBwbGVBZGFwdGVyIHtcbiAgLyoqXG4gICAqIEFkZHMgYSBjbGFzcyB0byB0aGUgbGluZSByaXBwbGUgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2xhc3MgZnJvbSB0aGUgbGluZSByaXBwbGUgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHN0eWxlIHByb3BlcnR5IHdpdGggcHJvcGVydHlOYW1lIHRvIHZhbHVlIG9uIHRoZSByb290IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRTdHlsZShwcm9wZXJ0eU5hbWUsIHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIGxpbmUgcmlwcGxlIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckV2ZW50SGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiB0aGUgbGluZSByaXBwbGUgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJFdmVudEhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDTGluZVJpcHBsZUFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBMSU5FX1JJUFBMRV9BQ1RJVkU6ICdtZGMtbGluZS1yaXBwbGUtLWFjdGl2ZScsXG4gIExJTkVfUklQUExFX0RFQUNUSVZBVElORzogJ21kYy1saW5lLXJpcHBsZS0tZGVhY3RpdmF0aW5nJyxcbn07XG5cbmV4cG9ydCB7Y3NzQ2xhc3Nlc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDTGluZVJpcHBsZUFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7Y3NzQ2xhc3Nlc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ0xpbmVSaXBwbGVBZGFwdGVyPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENMaW5lUmlwcGxlRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBNRENMaW5lUmlwcGxlQWRhcHRlcn0gZm9yIHR5cGluZyBpbmZvcm1hdGlvbiBvbiBwYXJhbWV0ZXJzIGFuZCByZXR1cm5cbiAgICogdHlwZXMuXG4gICAqIEByZXR1cm4geyFNRENMaW5lUmlwcGxlQWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ0xpbmVSaXBwbGVBZGFwdGVyfSAqLyAoe1xuICAgICAgYWRkQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgaGFzQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgc2V0U3R5bGU6ICgpID0+IHt9LFxuICAgICAgcmVnaXN0ZXJFdmVudEhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckV2ZW50SGFuZGxlcjogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDTGluZVJpcHBsZUFkYXB0ZXI9fSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyID0gLyoqIEB0eXBlIHshTURDTGluZVJpcHBsZUFkYXB0ZXJ9ICovICh7fSkpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0xpbmVSaXBwbGVGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlVHJhbnNpdGlvbkVuZChldnQpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyRXZlbnRIYW5kbGVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcl8pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJFdmVudEhhbmRsZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyk7XG4gIH1cblxuICAvKipcbiAgICogQWN0aXZhdGVzIHRoZSBsaW5lIHJpcHBsZVxuICAgKi9cbiAgYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkxJTkVfUklQUExFX0RFQUNUSVZBVElORyk7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLkxJTkVfUklQUExFX0FDVElWRSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgY2VudGVyIG9mIHRoZSByaXBwbGUgYW5pbWF0aW9uIHRvIHRoZSBnaXZlbiBYIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4Q29vcmRpbmF0ZVxuICAgKi9cbiAgc2V0UmlwcGxlQ2VudGVyKHhDb29yZGluYXRlKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZSgndHJhbnNmb3JtLW9yaWdpbicsIGAke3hDb29yZGluYXRlfXB4IGNlbnRlcmApO1xuICB9XG5cbiAgLyoqXG4gICAqIERlYWN0aXZhdGVzIHRoZSBsaW5lIHJpcHBsZVxuICAgKi9cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuTElORV9SSVBQTEVfREVBQ1RJVkFUSU5HKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgdHJhbnNpdGlvbiBlbmQgZXZlbnRcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKi9cbiAgaGFuZGxlVHJhbnNpdGlvbkVuZChldnQpIHtcbiAgICAvLyBXYWl0IGZvciB0aGUgbGluZSByaXBwbGUgdG8gYmUgZWl0aGVyIHRyYW5zcGFyZW50IG9yIG9wYXF1ZVxuICAgIC8vIGJlZm9yZSBlbWl0dGluZyB0aGUgYW5pbWF0aW9uIGVuZCBldmVudFxuICAgIGNvbnN0IGlzRGVhY3RpdmF0aW5nID0gdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhjc3NDbGFzc2VzLkxJTkVfUklQUExFX0RFQUNUSVZBVElORyk7XG5cbiAgICBpZiAoZXZ0LnByb3BlcnR5TmFtZSA9PT0gJ29wYWNpdHknKSB7XG4gICAgICBpZiAoaXNEZWFjdGl2YXRpbmcpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkxJTkVfUklQUExFX0FDVElWRSk7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5MSU5FX1JJUFBMRV9ERUFDVElWQVRJTkcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENMaW5lUmlwcGxlRm91bmRhdGlvbjtcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdlxuICAgIDpjbGFzcz1cImxpbmVDbGFzc2VzXCJcbiAgICA6c3R5bGU9XCJsaW5lU3R5bGVzXCJcbiAgICBjbGFzcz1cIm1kYy1saW5lLXJpcHBsZVwiLz5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDTGluZVJpcHBsZUZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2xpbmUtcmlwcGxlL2ZvdW5kYXRpb24nXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1zZWxlY3QtbGluZS1yaXBwbGUnLFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaW5lQ2xhc3Nlczoge30sXG4gICAgICBsaW5lU3R5bGVzOiB7fVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDTGluZVJpcHBsZUZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLmxpbmVDbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICB9LFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLmxpbmVDbGFzc2VzLCBjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgaGFzQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgc2V0U3R5bGU6IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5saW5lU3R5bGVzLCBuYW1lLCB2YWx1ZSlcbiAgICAgIH0sXG4gICAgICByZWdpc3RlckV2ZW50SGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJFdmVudEhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlcilcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICBsZXQgZm91bmRhdGlvbiA9IHRoaXMuZm91bmRhdGlvblxuICAgIHRoaXMuZm91bmRhdGlvbiA9IG51bGxcbiAgICBmb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9XG59XG48L3NjcmlwdD5cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgTm90Y2hlZCBPdXRsaW5lLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIE5vdGNoZWQgT3V0bGluZSBpbnRvIHlvdXIgZnJhbWV3b3JrLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvYXV0aG9yaW5nLWNvbXBvbmVudHMubWRcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDTm90Y2hlZE91dGxpbmVBZGFwdGVyIHtcbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSByb290IGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFdpZHRoKCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSByb290IGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldEhlaWdodCgpIHt9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjbGFzcyB0byB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIHRoZSByb290IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogU2V0cyB0aGUgXCJkXCIgYXR0cmlidXRlIG9mIHRoZSBvdXRsaW5lIGVsZW1lbnQncyBTVkcgcGF0aC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRPdXRsaW5lUGF0aEF0dHIodmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGlkbGUgb3V0bGluZSBlbGVtZW50J3MgY29tcHV0ZWQgc3R5bGUgdmFsdWUgb2YgdGhlIGdpdmVuIGNzcyBwcm9wZXJ0eSBgcHJvcGVydHlOYW1lYC5cbiAgICogV2UgYWNoaWV2ZSB0aGlzIHZpYSBgZ2V0Q29tcHV0ZWRTdHlsZSguLi4pLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHlOYW1lKWAuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWVcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0SWRsZU91dGxpbmVTdHlsZVZhbHVlKHByb3BlcnR5TmFtZSkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDTm90Y2hlZE91dGxpbmVBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgUEFUSF9TRUxFQ1RPUjogJy5tZGMtbm90Y2hlZC1vdXRsaW5lX19wYXRoJyxcbiAgSURMRV9PVVRMSU5FX1NFTEVDVE9SOiAnLm1kYy1ub3RjaGVkLW91dGxpbmVfX2lkbGUnLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBPVVRMSU5FX05PVENIRUQ6ICdtZGMtbm90Y2hlZC1vdXRsaW5lLS1ub3RjaGVkJyxcbn07XG5cbmV4cG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDTm90Y2hlZE91dGxpbmVBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDTm90Y2hlZE91dGxpbmVBZGFwdGVyPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENOb3RjaGVkT3V0bGluZUZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBNRENOb3RjaGVkT3V0bGluZUFkYXB0ZXJ9IGZvciB0eXBpbmcgaW5mb3JtYXRpb24gb24gcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAqIHR5cGVzLlxuICAgKiBAcmV0dXJuIHshTURDTm90Y2hlZE91dGxpbmVBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDTm90Y2hlZE91dGxpbmVBZGFwdGVyfSAqLyAoe1xuICAgICAgZ2V0V2lkdGg6ICgpID0+IHt9LFxuICAgICAgZ2V0SGVpZ2h0OiAoKSA9PiB7fSxcbiAgICAgIGFkZENsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHNldE91dGxpbmVQYXRoQXR0cjogKCkgPT4ge30sXG4gICAgICBnZXRJZGxlT3V0bGluZVN0eWxlVmFsdWU6ICgpID0+IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU1EQ05vdGNoZWRPdXRsaW5lQWRhcHRlcn0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDTm90Y2hlZE91dGxpbmVGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgb3V0bGluZSBub3RjaGVkIHNlbGVjdG9yIGFuZCB1cGRhdGVzIHRoZSBub3RjaCB3aWR0aFxuICAgKiBjYWxjdWxhdGVkIGJhc2VkIG9mZiBvZiBub3RjaFdpZHRoIGFuZCBpc1J0bC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG5vdGNoV2lkdGhcbiAgICogQHBhcmFtIHtib29sZWFuPX0gaXNSdGxcbiAgICovXG4gIG5vdGNoKG5vdGNoV2lkdGgsIGlzUnRsID0gZmFsc2UpIHtcbiAgICBjb25zdCB7T1VUTElORV9OT1RDSEVEfSA9IE1EQ05vdGNoZWRPdXRsaW5lRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoT1VUTElORV9OT1RDSEVEKTtcbiAgICB0aGlzLnVwZGF0ZVN2Z1BhdGhfKG5vdGNoV2lkdGgsIGlzUnRsKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIG5vdGNoZWQgb3V0bGluZSBzZWxlY3RvciB0byBjbG9zZSB0aGUgbm90Y2ggaW4gdGhlIG91dGxpbmUuXG4gICAqL1xuICBjbG9zZU5vdGNoKCkge1xuICAgIGNvbnN0IHtPVVRMSU5FX05PVENIRUR9ID0gTURDTm90Y2hlZE91dGxpbmVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhPVVRMSU5FX05PVENIRUQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIFNWRyBwYXRoIG9mIHRoZSBmb2N1cyBvdXRsaW5lIGVsZW1lbnQgYmFzZWQgb24gdGhlIG5vdGNoV2lkdGhcbiAgICogYW5kIHRoZSBSVEwgY29udGV4dC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG5vdGNoV2lkdGhcbiAgICogQHBhcmFtIHtib29sZWFuPX0gaXNSdGxcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHVwZGF0ZVN2Z1BhdGhfKG5vdGNoV2lkdGgsIGlzUnRsKSB7XG4gICAgLy8gRmFsbCBiYWNrIHRvIHJlYWRpbmcgYSBzcGVjaWZpYyBjb3JuZXIncyBzdHlsZSBiZWNhdXNlIEZpcmVmb3ggZG9lc24ndCByZXBvcnQgdGhlIHN0eWxlIG9uIGJvcmRlci1yYWRpdXMuXG4gICAgY29uc3QgcmFkaXVzU3R5bGVWYWx1ZSA9IHRoaXMuYWRhcHRlcl8uZ2V0SWRsZU91dGxpbmVTdHlsZVZhbHVlKCdib3JkZXItcmFkaXVzJykgfHxcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5nZXRJZGxlT3V0bGluZVN0eWxlVmFsdWUoJ2JvcmRlci10b3AtbGVmdC1yYWRpdXMnKTtcbiAgICBjb25zdCByYWRpdXMgPSBwYXJzZUZsb2F0KHJhZGl1c1N0eWxlVmFsdWUpO1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5hZGFwdGVyXy5nZXRXaWR0aCgpO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuYWRhcHRlcl8uZ2V0SGVpZ2h0KCk7XG4gICAgY29uc3QgY29ybmVyV2lkdGggPSByYWRpdXMgKyAxLjI7XG4gICAgY29uc3QgbGVhZGluZ1N0cm9rZUxlbmd0aCA9IE1hdGguYWJzKDExIC0gY29ybmVyV2lkdGgpO1xuICAgIGNvbnN0IHBhZGRlZE5vdGNoV2lkdGggPSBub3RjaFdpZHRoICsgODtcblxuICAgIC8vIFRoZSByaWdodCwgYm90dG9tLCBhbmQgbGVmdCBzaWRlcyBvZiB0aGUgb3V0bGluZSBmb2xsb3cgdGhlIHNhbWUgU1ZHIHBhdGguXG4gICAgY29uc3QgcGF0aE1pZGRsZSA9ICdhJyArIHJhZGl1cyArICcsJyArIHJhZGl1cyArICcgMCAwIDEgJyArIHJhZGl1cyArICcsJyArIHJhZGl1c1xuICAgICAgKyAndicgKyAoaGVpZ2h0IC0gKDIgKiBjb3JuZXJXaWR0aCkpXG4gICAgICArICdhJyArIHJhZGl1cyArICcsJyArIHJhZGl1cyArICcgMCAwIDEgJyArIC1yYWRpdXMgKyAnLCcgKyByYWRpdXNcbiAgICAgICsgJ2gnICsgKC13aWR0aCArICgyICogY29ybmVyV2lkdGgpKVxuICAgICAgKyAnYScgKyByYWRpdXMgKyAnLCcgKyByYWRpdXMgKyAnIDAgMCAxICcgKyAtcmFkaXVzICsgJywnICsgLXJhZGl1c1xuICAgICAgKyAndicgKyAoLWhlaWdodCArICgyICogY29ybmVyV2lkdGgpKVxuICAgICAgKyAnYScgKyByYWRpdXMgKyAnLCcgKyByYWRpdXMgKyAnIDAgMCAxICcgKyByYWRpdXMgKyAnLCcgKyAtcmFkaXVzO1xuXG4gICAgbGV0IHBhdGg7XG4gICAgaWYgKCFpc1J0bCkge1xuICAgICAgcGF0aCA9ICdNJyArIChjb3JuZXJXaWR0aCArIGxlYWRpbmdTdHJva2VMZW5ndGggKyBwYWRkZWROb3RjaFdpZHRoKSArICcsJyArIDFcbiAgICAgICAgKyAnaCcgKyAod2lkdGggLSAoMiAqIGNvcm5lcldpZHRoKSAtIHBhZGRlZE5vdGNoV2lkdGggLSBsZWFkaW5nU3Ryb2tlTGVuZ3RoKVxuICAgICAgICArIHBhdGhNaWRkbGVcbiAgICAgICAgKyAnaCcgKyBsZWFkaW5nU3Ryb2tlTGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gJ00nICsgKHdpZHRoIC0gY29ybmVyV2lkdGggLSBsZWFkaW5nU3Ryb2tlTGVuZ3RoKSArICcsJyArIDFcbiAgICAgICAgKyAnaCcgKyBsZWFkaW5nU3Ryb2tlTGVuZ3RoXG4gICAgICAgICsgcGF0aE1pZGRsZVxuICAgICAgICArICdoJyArICh3aWR0aCAtICgyICogY29ybmVyV2lkdGgpIC0gcGFkZGVkTm90Y2hXaWR0aCAtIGxlYWRpbmdTdHJva2VMZW5ndGgpO1xuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8uc2V0T3V0bGluZVBhdGhBdHRyKHBhdGgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ05vdGNoZWRPdXRsaW5lRm91bmRhdGlvbjtcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdj5cbiAgICA8ZGl2XG4gICAgICByZWY9XCJvdXRsaW5lZFwiXG4gICAgICA6Y2xhc3M9XCJvdXRsaW5lZENsYXNzZXNcIlxuICAgICAgY2xhc3M9XCJtZGMtbm90Y2hlZC1vdXRsaW5lXCI+XG4gICAgICA8c3ZnPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIHJlZj1cIm91dGxpbmVkUGF0aFwiXG4gICAgICAgICAgY2xhc3M9XCJtZGMtbm90Y2hlZC1vdXRsaW5lX19wYXRoXCIvPlxuICAgICAgPC9zdmc+XG4gICAgPC9kaXY+XG4gICAgPGRpdlxuICAgICAgcmVmPVwib3V0bGluZWRJZGxlXCJcbiAgICAgIGNsYXNzPVwibWRjLW5vdGNoZWQtb3V0bGluZV9faWRsZVwiLz5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ25vdGNoZWRPdXRsaW5lRm91bmRhdGlvbkZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL25vdGNoZWQtb3V0bGluZS9mb3VuZGF0aW9uJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtc2VsZWN0LW5vdGNoZWQtb3V0bGluZScsXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG91dGxpbmVkQ2xhc3Nlczoge31cbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ25vdGNoZWRPdXRsaW5lRm91bmRhdGlvbkZvdW5kYXRpb24oe1xuICAgICAgZ2V0V2lkdGg6ICgpID0+IHRoaXMuJHJlZnMub3V0bGluZWQub2Zmc2V0V2lkdGgsXG4gICAgICBnZXRIZWlnaHQ6ICgpID0+IHRoaXMuJHJlZnMub3V0bGluZWQub2Zmc2V0SGVpZ2h0LFxuICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLm91dGxpbmVkQ2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgfSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5vdXRsaW5lZENsYXNzZXMsIGNsYXNzTmFtZSlcbiAgICAgIH0sXG4gICAgICBzZXRPdXRsaW5lUGF0aEF0dHI6IHZhbHVlID0+IHtcbiAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMuJHJlZnMub3V0bGluZWRQYXRoXG4gICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdkJywgdmFsdWUpXG4gICAgICB9LFxuICAgICAgZ2V0SWRsZU91dGxpbmVTdHlsZVZhbHVlOiBwcm9wZXJ0eU5hbWUgPT4ge1xuICAgICAgICByZXR1cm4gd2luZG93XG4gICAgICAgICAgLmdldENvbXB1dGVkU3R5bGUodGhpcy4kcmVmcy5vdXRsaW5lZElkbGUpXG4gICAgICAgICAgLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHlOYW1lKVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIGxldCBmb3VuZGF0aW9uID0gdGhpcy5mb3VuZGF0aW9uXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbnVsbFxuICAgIGZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2XG4gICAgOmlkPVwiaWRcIlxuICAgIDpjbGFzcz1cInJvb3RDbGFzc2VzXCJcbiAgICA6c3R5bGU9XCJzdHlsZXNcIlxuICAgIGNsYXNzPVwibWRjLXNlbGVjdFwiPlxuICAgIDxzZWxlY3RcbiAgICAgIHJlZj1cIm5hdGl2ZV9jb250cm9sXCJcbiAgICAgIHYtYmluZD1cIiRhdHRyc1wiXG4gICAgICBjbGFzcz1cIm1kYy1zZWxlY3RfX25hdGl2ZS1jb250cm9sXCJcbiAgICAgIHYtb249XCJsaXN0ZW5lcnNcIj5cbiAgICAgIDxvcHRpb25cbiAgICAgICAgdi1pZj1cIiEhbGFiZWxcIlxuICAgICAgICBjbGFzcz1cIm1kYy1vcHRpb25cIlxuICAgICAgICB2YWx1ZT1cIlwiXG4gICAgICAgIGRpc2FibGVkXG4gICAgICAgIHNlbGVjdGVkLz5cbiAgICAgIDxzbG90Lz5cbiAgICA8L3NlbGVjdD5cbiAgICA8IS0tIGxhYmVsIC0tPlxuICAgIDxzZWxlY3QtbGFiZWxcbiAgICAgIHYtaWY9XCJsYWJlbFwiXG4gICAgICByZWY9XCJsYWJlbFwiPnt7IGxhYmVsIH19PC9zZWxlY3QtbGFiZWw+XG4gICAgPCEtLSBsaW5lIHJpcHBsZSAtLT5cbiAgICA8c2VsZWN0LWxpbmUtcmlwbGVcbiAgICAgIHYtaWY9XCIhb3V0bGluZWRcIlxuICAgICAgcmVmPVwibGluZVwiLz5cbiAgICA8IS0tIG91dGxpbmUgLS0+XG4gICAgPHNlbGVjdC1ub3RjaGVkLW91dGxpbmVcbiAgICAgIHYtaWY9XCJvdXRsaW5lZFwiXG4gICAgICByZWY9XCJvdXRsaW5lXCJcbiAgICAvPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDU2VsZWN0Rm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvc2VsZWN0L2ZvdW5kYXRpb24nXG5pbXBvcnQgeyBSaXBwbGVCYXNlIH0gZnJvbSAnLi4vcmlwcGxlJ1xuXG5pbXBvcnQgU2VsZWN0TGFiZWwgZnJvbSAnLi9tZGMtc2VsZWN0LWxhYmVsLnZ1ZSdcbmltcG9ydCBTZWxlY3RMaW5lUmlwbGUgZnJvbSAnLi9tZGMtc2VsZWN0LWxpbmUtcmlwcGxlLnZ1ZSdcbmltcG9ydCBTZWxlY3ROb3RjaGVkT3V0bGluZSBmcm9tICcuL21kYy1zZWxlY3Qtbm90Y2hlZC1vdXRsaW5lLnZ1ZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXNlbGVjdCcsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBTZWxlY3RMYWJlbCxcbiAgICBTZWxlY3RMaW5lUmlwbGUsXG4gICAgU2VsZWN0Tm90Y2hlZE91dGxpbmVcbiAgfSxcbiAgaW5oZXJpdEF0dHJzOiBmYWxzZSxcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAndmFsdWUnLFxuICAgIGV2ZW50OiAnY2hhbmdlJ1xuICB9LFxuICBwcm9wczoge1xuICAgIHZhbHVlOiBTdHJpbmcsXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgbGFiZWw6IFN0cmluZyxcbiAgICBib3g6IEJvb2xlYW4sXG4gICAgb3V0bGluZWQ6IEJvb2xlYW4sXG4gICAgaWQ6IHsgdHlwZTogU3RyaW5nIH1cbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3R5bGVzOiB7fSxcbiAgICAgIGNsYXNzZXM6IHt9XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIHJvb3RDbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21kYy1zZWxlY3QtLWJveCc6IHRoaXMuYm94LFxuICAgICAgICAnbWRjLXNlbGVjdC0tb3V0bGluZWQnOiB0aGlzLm91dGxpbmVkLFxuICAgICAgICAuLi50aGlzLmNsYXNzZXNcbiAgICAgIH1cbiAgICB9LFxuICAgIGxpc3RlbmVycygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnRoaXMuJGxpc3RlbmVycyxcbiAgICAgICAgY2hhbmdlOiBldmVudCA9PiB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBldmVudC50YXJnZXQudmFsdWUpXG4gICAgICB9XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIGRpc2FibGVkKHZhbHVlKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHZhbHVlKVxuICAgIH0sXG4gICAgdmFsdWU6ICdyZWZyZXNoSW5kZXgnXG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ1NlbGVjdEZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpLFxuICAgICAgaGFzQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSxcbiAgICAgIGFjdGl2YXRlQm90dG9tTGluZTogKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy4kcmVmcy5saW5lKSB7XG4gICAgICAgICAgdGhpcy4kcmVmcy5saW5lLmZvdW5kYXRpb24uYWN0aXZhdGUoKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZGVhY3RpdmF0ZUJvdHRvbUxpbmU6ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuJHJlZnMubGluZSkge1xuICAgICAgICAgIHRoaXMuJHJlZnMubGluZS5mb3VuZGF0aW9uLmRlYWN0aXZhdGUoKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0RGlzYWJsZWQ6IGRpc2FibGVkID0+ICh0aGlzLiRyZWZzLm5hdGl2ZV9jb250cm9sLmRpc2FibGVkID0gZGlzYWJsZWQpLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PlxuICAgICAgICB0aGlzLiRyZWZzLm5hdGl2ZV9jb250cm9sLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5uYXRpdmVfY29udHJvbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpLFxuICAgICAgZ2V0U2VsZWN0ZWRJbmRleDogKCkgPT4gdGhpcy4kcmVmcy5uYXRpdmVfY29udHJvbC5zZWxlY3RlZEluZGV4LFxuICAgICAgc2V0U2VsZWN0ZWRJbmRleDogaW5kZXggPT5cbiAgICAgICAgKHRoaXMuJHJlZnMubmF0aXZlX2NvbnRyb2wuc2VsZWN0ZWRJbmRleCA9IGluZGV4KSxcbiAgICAgIGdldFZhbHVlOiAoKSA9PiB0aGlzLiRyZWZzLm5hdGl2ZV9jb250cm9sLnZhbHVlLFxuICAgICAgc2V0VmFsdWU6IHZhbHVlID0+ICh0aGlzLiRyZWZzLm5hdGl2ZV9jb250cm9sLnZhbHVlID0gdmFsdWUpLFxuICAgICAgaXNSdGw6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRlbCkuZ2V0UHJvcGVydHlWYWx1ZSgnZGlyZWN0aW9uJykgPT09XG4gICAgICAgICAgJ3J0bCdcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIG5vdGNoT3V0bGluZTogKGxhYmVsV2lkdGgsIGlzUnRsKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLiRyZWZzLm91dGxpbmUpIHtcbiAgICAgICAgICB0aGlzLiRyZWZzLm91dGxpbmUuZm91bmRhdGlvbi5ub3RjaChsYWJlbFdpZHRoLCBpc1J0bClcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNsb3NlT3V0bGluZTogKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy4kcmVmcy5vdXRsaW5lKSB7XG4gICAgICAgICAgdGhpcy4kcmVmcy5vdXRsaW5lLmZvdW5kYXRpb24uY2xvc2VOb3RjaCgpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBoYXNPdXRsaW5lOiAoKSA9PiAhIXRoaXMuJHJlZnMub3V0bGluZSxcbiAgICAgIGZsb2F0TGFiZWw6IHZhbHVlID0+IHtcbiAgICAgICAgaWYgKHRoaXMuJHJlZnMubGFiZWwpIHtcbiAgICAgICAgICB0aGlzLiRyZWZzLmxhYmVsLmZvdW5kYXRpb24uZmxvYXQodmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBoYXNMYWJlbDogKCkgPT4gISF0aGlzLiRyZWZzLmxhYmVsLFxuICAgICAgZ2V0TGFiZWxXaWR0aDogKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy4kcmVmcy5sYWJlbCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLiRyZWZzLmxhYmVsLmZvdW5kYXRpb24uZ2V0V2lkdGgoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcblxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXREaXNhYmxlZCh0aGlzLmRpc2FibGVkKVxuXG4gICAgLy8gaW5pdGlhbCBzeW5jIHdpdGggRE9NXG4gICAgdGhpcy5yZWZyZXNoSW5kZXgoKVxuICAgIHRoaXMuc2xvdE9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4gdGhpcy5yZWZyZXNoSW5kZXgoKSlcbiAgICB0aGlzLnNsb3RPYnNlcnZlci5vYnNlcnZlKHRoaXMuJHJlZnMubmF0aXZlX2NvbnRyb2wsIHtcbiAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgIHN1YnRyZWU6IHRydWVcbiAgICB9KVxuXG4gICAgdGhpcy5yaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzKVxuICAgIHRoaXMucmlwcGxlLmluaXQoKVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuc2xvdE9ic2VydmVyLmRpc2Nvbm5lY3QoKVxuXG4gICAgbGV0IGZvdW5kYXRpb24gPSB0aGlzLmZvdW5kYXRpb25cbiAgICB0aGlzLmZvdW5kYXRpb24gPSBudWxsXG4gICAgZm91bmRhdGlvbi5kZXN0cm95KClcblxuICAgIHRoaXMucmlwcGxlICYmIHRoaXMucmlwcGxlLmRlc3Ryb3koKVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgcmVmcmVzaEluZGV4KCkge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IFsuLi50aGlzLiRyZWZzLm5hdGl2ZV9jb250cm9sLnF1ZXJ5U2VsZWN0b3JBbGwoJ29wdGlvbicpXVxuXG4gICAgICBjb25zdCBpZHggPSBvcHRpb25zLmZpbmRJbmRleCgoeyB2YWx1ZSB9KSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlID09PSB2YWx1ZVxuICAgICAgfSlcblxuICAgICAgaWYgKHRoaXMuJHJlZnMubmF0aXZlX2NvbnRyb2wuc2VsZWN0ZWRJbmRleCAhPT0gaWR4KSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRTZWxlY3RlZEluZGV4KGlkeClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjU2VsZWN0IGZyb20gJy4vbWRjLXNlbGVjdC52dWUnXG5cbmV4cG9ydCB7IG1kY1NlbGVjdCB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNTZWxlY3Rcbn0pXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgQUNUSVZFOiAnbWRjLXNsaWRlci0tYWN0aXZlJyxcbiAgRElTQUJMRUQ6ICdtZGMtc2xpZGVyLS1kaXNhYmxlZCcsXG4gIERJU0NSRVRFOiAnbWRjLXNsaWRlci0tZGlzY3JldGUnLFxuICBGT0NVUzogJ21kYy1zbGlkZXItLWZvY3VzJyxcbiAgSU5fVFJBTlNJVDogJ21kYy1zbGlkZXItLWluLXRyYW5zaXQnLFxuICBJU19ESVNDUkVURTogJ21kYy1zbGlkZXItLWRpc2NyZXRlJyxcbiAgSEFTX1RSQUNLX01BUktFUjogJ21kYy1zbGlkZXItLWRpc3BsYXktbWFya2VycycsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIFRSQUNLX1NFTEVDVE9SOiAnLm1kYy1zbGlkZXJfX3RyYWNrJyxcbiAgVFJBQ0tfTUFSS0VSX0NPTlRBSU5FUl9TRUxFQ1RPUjogJy5tZGMtc2xpZGVyX190cmFjay1tYXJrZXItY29udGFpbmVyJyxcbiAgTEFTVF9UUkFDS19NQVJLRVJfU0VMRUNUT1I6ICcubWRjLXNsaWRlcl9fdHJhY2stbWFya2VyOmxhc3QtY2hpbGQnLFxuICBUSFVNQl9DT05UQUlORVJfU0VMRUNUT1I6ICcubWRjLXNsaWRlcl9fdGh1bWItY29udGFpbmVyJyxcbiAgUElOX1ZBTFVFX01BUktFUl9TRUxFQ1RPUjogJy5tZGMtc2xpZGVyX19waW4tdmFsdWUtbWFya2VyJyxcbiAgQVJJQV9WQUxVRU1JTjogJ2FyaWEtdmFsdWVtaW4nLFxuICBBUklBX1ZBTFVFTUFYOiAnYXJpYS12YWx1ZW1heCcsXG4gIEFSSUFfVkFMVUVOT1c6ICdhcmlhLXZhbHVlbm93JyxcbiAgQVJJQV9ESVNBQkxFRDogJ2FyaWEtZGlzYWJsZWQnLFxuICBTVEVQX0RBVEFfQVRUUjogJ2RhdGEtc3RlcCcsXG4gIENIQU5HRV9FVkVOVDogJ01EQ1NsaWRlcjpjaGFuZ2UnLFxuICBJTlBVVF9FVkVOVDogJ01EQ1NsaWRlcjppbnB1dCcsXG59O1xuXG4vKiogQGVudW0ge251bWJlcn0gKi9cbmNvbnN0IG51bWJlcnMgPSB7XG4gIFBBR0VfRkFDVE9SOiA0LFxufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgU2xpZGVyLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIFNsaWRlciBpbnRvIHlvdXIgZnJhbWV3b3JrLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvYXV0aG9yaW5nLWNvbXBvbmVudHMubWRcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDU2xpZGVyQWRhcHRlciB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgY2xhc3NOYW1lIGV4aXN0cyBmb3IgdGhlIHNsaWRlciBFbGVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogQWRkcyBhIGNsYXNzIHRvIHRoZSBzbGlkZXIgRWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIHRoZSBzbGlkZXIgRWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgaWYgYXR0cmlidXRlIG5hbWUgZXhpc3RzIG9uIHRoZSBzbGlkZXIgRWxlbWVudCxcbiAgICogb3RoZXJ3aXNlIHJldHVybnMgbnVsbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfVxuICAgKi9cbiAgZ2V0QXR0cmlidXRlKG5hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgYXR0cmlidXRlIG5hbWUgb24gc2xpZGVyIEVsZW1lbnQgdG8gdmFsdWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYXR0cmlidXRlIG5hbWUgZnJvbSBzbGlkZXIgRWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKi9cbiAgcmVtb3ZlQXR0cmlidXRlKG5hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGNsaWVudCByZWN0IGZvciB0aGUgc2xpZGVyIEVsZW1lbnRcbiAgICogQHJldHVybiB7P0NsaWVudFJlY3R9XG4gICAqL1xuICBjb21wdXRlQm91bmRpbmdSZWN0KCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGFiIGluZGV4IG9mIHRoZSBzbGlkZXIgRWxlbWVudFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRUYWJJbmRleCgpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIG9uIHRoZSByb290IGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIG9uIHRoZSByb290IGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIG9uIHRoZSB0aHVtYiBjb250YWluZXIgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgdGh1bWIgY29udGFpbmVyIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgb24gdGhlIGJvZHkgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgYm9keSBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIGZvciB0aGUgd2luZG93IHJlc2l6ZSBldmVudFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSB3aW5kb3cgcmVzaXplIGV2ZW50XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBFbWl0cyBhIGN1c3RvbSBldmVudCBNRENTbGlkZXI6aW5wdXQgZnJvbSB0aGUgcm9vdFxuICAgKi9cbiAgbm90aWZ5SW5wdXQoKSB7fVxuXG4gIC8qKlxuICAgKiBFbWl0cyBhIGN1c3RvbSBldmVudCBNRENTbGlkZXI6Y2hhbmdlIGZyb20gdGhlIHJvb3RcbiAgICovXG4gIG5vdGlmeUNoYW5nZSgpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdHlsZSBwcm9wZXJ0eSBvZiB0aGUgdGh1bWIgY29udGFpbmVyIGVsZW1lbnQgdG8gdGhlIHBhc3NlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0VGh1bWJDb250YWluZXJTdHlsZVByb3BlcnR5KHByb3BlcnR5TmFtZSwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdHlsZSBwcm9wZXJ0eSBvZiB0aGUgdHJhY2sgZWxlbWVudCB0byB0aGUgcGFzc2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRUcmFja1N0eWxlUHJvcGVydHkocHJvcGVydHlOYW1lLCB2YWx1ZSkge31cblxuICAvKipcbiAgICogU2V0cyB0aGUgaW5uZXIgdGV4dCBvZiB0aGUgcGluIG1hcmtlciB0byB0aGUgcGFzc2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgKi9cbiAgc2V0TWFya2VyVmFsdWUodmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgdGhlIHBhc3NlZCBudW1iZXIgb2YgdHJhY2sgbWFya2VycyB0byB0aGUgdHJhY2sgbWFyayBjb250YWluZXIgZWxlbWVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gbnVtTWFya2Vyc1xuICAgKi9cbiAgYXBwZW5kVHJhY2tNYXJrZXJzKG51bU1hcmtlcnMpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIHRyYWNrIG1hcmtlcnMgZnJvbXQgaGUgdHJhY2sgbWFyayBjb250YWluZXIgZWxlbWVudFxuICAgKi9cbiAgcmVtb3ZlVHJhY2tNYXJrZXJzKCkge31cblxuICAvKipcbiAgICogU2V0cyBhIHN0eWxlIHByb3BlcnR5IG9mIHRoZSBsYXN0IHRyYWNrIG1hcmtlciB0byB0aGUgcGFzc2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRMYXN0VHJhY2tNYXJrZXJzU3R5bGVQcm9wZXJ0eShwcm9wZXJ0eU5hbWUsIHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJvb3QgZWxlbWVudCBpcyBSVEwsIG90aGVyd2lzZSBmYWxzZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNSVEwoKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENTbGlkZXJBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICp5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc30gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IE1EQ1NsaWRlckFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcblxuaW1wb3J0IHtnZXRDb3JyZWN0RXZlbnROYW1lLCBnZXRDb3JyZWN0UHJvcGVydHlOYW1lfSBmcm9tICdAbWF0ZXJpYWwvYW5pbWF0aW9uL2luZGV4JztcbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IEtFWV9JRFMgPSB7XG4gIEFSUk9XX0xFRlQ6ICdBcnJvd0xlZnQnLFxuICBBUlJPV19SSUdIVDogJ0Fycm93UmlnaHQnLFxuICBBUlJPV19VUDogJ0Fycm93VXAnLFxuICBBUlJPV19ET1dOOiAnQXJyb3dEb3duJyxcbiAgSE9NRTogJ0hvbWUnLFxuICBFTkQ6ICdFbmQnLFxuICBQQUdFX1VQOiAnUGFnZVVwJyxcbiAgUEFHRV9ET1dOOiAnUGFnZURvd24nLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBNT1ZFX0VWRU5UX01BUCA9IHtcbiAgJ21vdXNlZG93bic6ICdtb3VzZW1vdmUnLFxuICAndG91Y2hzdGFydCc6ICd0b3VjaG1vdmUnLFxuICAncG9pbnRlcmRvd24nOiAncG9pbnRlcm1vdmUnLFxufTtcblxuY29uc3QgRE9XTl9FVkVOVFMgPSBbJ21vdXNlZG93bicsICdwb2ludGVyZG93bicsICd0b3VjaHN0YXJ0J107XG5jb25zdCBVUF9FVkVOVFMgPSBbJ21vdXNldXAnLCAncG9pbnRlcnVwJywgJ3RvdWNoZW5kJ107XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ1NsaWRlckFkYXB0ZXI+fVxuICovXG5jbGFzcyBNRENTbGlkZXJGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge2Nzc0NsYXNzZXN9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ3N9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge251bWJlcnN9ICovXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICByZXR1cm4gbnVtYmVycztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshTURDU2xpZGVyQWRhcHRlcn0gKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDU2xpZGVyQWRhcHRlcn0gKi8gKHtcbiAgICAgIGhhc0NsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IC8qIGJvb2xlYW4gKi8gZmFsc2UsXG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgZ2V0QXR0cmlidXRlOiAoLyogbmFtZTogc3RyaW5nICovKSA9PiAvKiBzdHJpbmd8bnVsbCAqLyBudWxsLFxuICAgICAgc2V0QXR0cmlidXRlOiAoLyogbmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUF0dHJpYnV0ZTogKC8qIG5hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBjb21wdXRlQm91bmRpbmdSZWN0OiAoKSA9PiAvKiBDbGllbnRSZWN0ICovICh7XG4gICAgICAgIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMCwgd2lkdGg6IDAsIGhlaWdodDogMCxcbiAgICAgIH0pLFxuICAgICAgZ2V0VGFiSW5kZXg6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlclRodW1iQ29udGFpbmVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJUaHVtYkNvbnRhaW5lckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgbm90aWZ5SW5wdXQ6ICgpID0+IHt9LFxuICAgICAgbm90aWZ5Q2hhbmdlOiAoKSA9PiB7fSxcbiAgICAgIHNldFRodW1iQ29udGFpbmVyU3R5bGVQcm9wZXJ0eTogKC8qIHByb3BlcnR5TmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldFRyYWNrU3R5bGVQcm9wZXJ0eTogKC8qIHByb3BlcnR5TmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldE1hcmtlclZhbHVlOiAoLyogdmFsdWU6IG51bWJlciAqLykgPT4ge30sXG4gICAgICBhcHBlbmRUcmFja01hcmtlcnM6ICgvKiBudW1NYXJrZXJzOiBudW1iZXIgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlVHJhY2tNYXJrZXJzOiAoKSA9PiB7fSxcbiAgICAgIHNldExhc3RUcmFja01hcmtlcnNTdHlsZVByb3BlcnR5OiAoLyogcHJvcGVydHlOYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgaXNSVEw6ICgpID0+IC8qIGJvb2xlYW4gKi8gZmFsc2UsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBNRENTbGlkZXJGb3VuZGF0aW9uXG4gICAqIEBwYXJhbSB7P01EQ1NsaWRlckFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1NsaWRlckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcbiAgICAvKiogQHByaXZhdGUgez9DbGllbnRSZWN0fSAqL1xuICAgIHRoaXMucmVjdF8gPSBudWxsO1xuICAgIC8vIFdlIHNldCB0aGlzIHRvIE5hTiBzaW5jZSB3ZSB3YW50IGl0IHRvIGJlIGEgbnVtYmVyLCBidXQgd2UgY2FuJ3QgdXNlICcwJyBvciAnLTEnXG4gICAgLy8gYmVjYXVzZSB0aG9zZSBjb3VsZCBiZSB2YWxpZCB0YWJpbmRpY2VzIHNldCBieSB0aGUgY2xpZW50IGNvZGUuXG4gICAgdGhpcy5zYXZlZFRhYkluZGV4XyA9IE5hTjtcbiAgICB0aGlzLmFjdGl2ZV8gPSBmYWxzZTtcbiAgICB0aGlzLmluVHJhbnNpdF8gPSBmYWxzZTtcbiAgICB0aGlzLmlzRGlzY3JldGVfID0gZmFsc2U7XG4gICAgdGhpcy5oYXNUcmFja01hcmtlcl8gPSBmYWxzZTtcbiAgICB0aGlzLmhhbmRsaW5nVGh1bWJUYXJnZXRFdnRfID0gZmFsc2U7XG4gICAgdGhpcy5taW5fID0gMDtcbiAgICB0aGlzLm1heF8gPSAxMDA7XG4gICAgdGhpcy5zdGVwXyA9IDA7XG4gICAgdGhpcy52YWx1ZV8gPSAwO1xuICAgIHRoaXMuZGlzYWJsZWRfID0gZmFsc2U7XG4gICAgdGhpcy5wcmV2ZW50Rm9jdXNTdGF0ZV8gPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZVVJRnJhbWVfID0gMDtcbiAgICB0aGlzLnRodW1iQ29udGFpbmVyUG9pbnRlckhhbmRsZXJfID0gKCkgPT4ge1xuICAgICAgdGhpcy5oYW5kbGluZ1RodW1iVGFyZ2V0RXZ0XyA9IHRydWU7XG4gICAgfTtcbiAgICB0aGlzLmludGVyYWN0aW9uU3RhcnRIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlRG93bl8oZXZ0KTtcbiAgICB0aGlzLmtleWRvd25IYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlS2V5ZG93bl8oZXZ0KTtcbiAgICB0aGlzLmZvY3VzSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmhhbmRsZUZvY3VzXygpO1xuICAgIHRoaXMuYmx1ckhhbmRsZXJfID0gKCkgPT4gdGhpcy5oYW5kbGVCbHVyXygpO1xuICAgIHRoaXMucmVzaXplSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmxheW91dCgpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmlzRGlzY3JldGVfID0gdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhjc3NDbGFzc2VzLklTX0RJU0NSRVRFKTtcbiAgICB0aGlzLmhhc1RyYWNrTWFya2VyXyA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5IQVNfVFJBQ0tfTUFSS0VSKTtcbiAgICBET1dOX0VWRU5UUy5mb3JFYWNoKChldnROYW1lKSA9PiB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dE5hbWUsIHRoaXMuaW50ZXJhY3Rpb25TdGFydEhhbmRsZXJfKSk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdmb2N1cycsIHRoaXMuZm9jdXNIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignYmx1cicsIHRoaXMuYmx1ckhhbmRsZXJfKTtcbiAgICBET1dOX0VWRU5UUy5mb3JFYWNoKChldnROYW1lKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0TmFtZSwgdGhpcy50aHVtYkNvbnRhaW5lclBvaW50ZXJIYW5kbGVyXyk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclJlc2l6ZUhhbmRsZXIodGhpcy5yZXNpemVIYW5kbGVyXyk7XG4gICAgdGhpcy5sYXlvdXQoKTtcbiAgICAvLyBBdCBsYXN0IHN0ZXAsIHByb3ZpZGUgYSByZWFzb25hYmxlIGRlZmF1bHQgdmFsdWUgdG8gZGlzY3JldGUgc2xpZGVyXG4gICAgaWYgKHRoaXMuaXNEaXNjcmV0ZV8gJiYgdGhpcy5nZXRTdGVwKCkgPT0gMCkge1xuICAgICAgdGhpcy5zdGVwXyA9IDE7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBET1dOX0VWRU5UUy5mb3JFYWNoKChldnROYW1lKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0TmFtZSwgdGhpcy5pbnRlcmFjdGlvblN0YXJ0SGFuZGxlcl8pO1xuICAgIH0pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyXyk7XG4gICAgRE9XTl9FVkVOVFMuZm9yRWFjaCgoZXZ0TmFtZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0TmFtZSwgdGhpcy50aHVtYkNvbnRhaW5lclBvaW50ZXJIYW5kbGVyXyk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgfVxuXG4gIHNldHVwVHJhY2tNYXJrZXIoKSB7XG4gICAgaWYgKHRoaXMuaXNEaXNjcmV0ZV8gJiYgdGhpcy5oYXNUcmFja01hcmtlcl8mJiB0aGlzLmdldFN0ZXAoKSAhPSAwKSB7XG4gICAgICBjb25zdCBtaW4gPSB0aGlzLmdldE1pbigpO1xuICAgICAgY29uc3QgbWF4ID0gdGhpcy5nZXRNYXgoKTtcbiAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLmdldFN0ZXAoKTtcbiAgICAgIGxldCBudW1NYXJrZXJzID0gKG1heCAtIG1pbikgLyBzdGVwO1xuXG4gICAgICAvLyBJbiBjYXNlIGRpc3RhbmNlIGJldHdlZW4gbWF4ICYgbWluIGlzIGluZGl2aXNpYmxlIHRvIHN0ZXAsXG4gICAgICAvLyB3ZSBwbGFjZSB0aGUgc2Vjb25kYXJ5IHRvIGxhc3QgbWFya2VyIHByb3BvcnRpb25hbGx5IGF0IHdoZXJlIHRodW1iXG4gICAgICAvLyBjb3VsZCByZWFjaCBhbmQgcGxhY2UgdGhlIGxhc3QgbWFya2VyIGF0IG1heCB2YWx1ZVxuICAgICAgY29uc3QgaW5kaXZpc2libGUgPSBNYXRoLmNlaWwobnVtTWFya2VycykgIT09IG51bU1hcmtlcnM7XG4gICAgICBpZiAoaW5kaXZpc2libGUpIHtcbiAgICAgICAgbnVtTWFya2VycyA9IE1hdGguY2VpbChudW1NYXJrZXJzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVUcmFja01hcmtlcnMoKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYXBwZW5kVHJhY2tNYXJrZXJzKG51bU1hcmtlcnMpO1xuXG4gICAgICBpZiAoaW5kaXZpc2libGUpIHtcbiAgICAgICAgY29uc3QgbGFzdFN0ZXBSYXRpbyA9IChtYXggLSBudW1NYXJrZXJzICogc3RlcCkgLyBzdGVwICsgMTtcbiAgICAgICAgY29uc3QgZmxleCA9IGdldENvcnJlY3RQcm9wZXJ0eU5hbWUod2luZG93LCAnZmxleCcpO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnNldExhc3RUcmFja01hcmtlcnNTdHlsZVByb3BlcnR5KGZsZXgsIFN0cmluZyhsYXN0U3RlcFJhdGlvKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGF5b3V0KCkge1xuICAgIHRoaXMucmVjdF8gPSB0aGlzLmFkYXB0ZXJfLmNvbXB1dGVCb3VuZGluZ1JlY3QoKTtcbiAgICB0aGlzLnVwZGF0ZVVJRm9yQ3VycmVudFZhbHVlXygpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVfO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAqL1xuICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuc2V0VmFsdWVfKHZhbHVlLCBmYWxzZSk7XG4gIH1cblxuICAvKiogQHJldHVybiB7bnVtYmVyfSAqL1xuICBnZXRNYXgoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4XztcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge251bWJlcn0gbWF4ICovXG4gIHNldE1heChtYXgpIHtcbiAgICBpZiAobWF4IDwgdGhpcy5taW5fKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZXQgbWF4IHRvIGJlIGxlc3MgdGhhbiB0aGUgc2xpZGVyXFwncyBtaW5pbXVtIHZhbHVlJyk7XG4gICAgfVxuICAgIHRoaXMubWF4XyA9IG1heDtcbiAgICB0aGlzLnNldFZhbHVlXyh0aGlzLnZhbHVlXywgZmFsc2UsIHRydWUpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cmlidXRlKHN0cmluZ3MuQVJJQV9WQUxVRU1BWCwgU3RyaW5nKHRoaXMubWF4XykpO1xuICAgIHRoaXMuc2V0dXBUcmFja01hcmtlcigpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbiAgZ2V0TWluKCkge1xuICAgIHJldHVybiB0aGlzLm1pbl87XG4gIH1cblxuICAvKiogQHBhcmFtIHtudW1iZXJ9IG1pbiAqL1xuICBzZXRNaW4obWluKSB7XG4gICAgaWYgKG1pbiA+IHRoaXMubWF4Xykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2V0IG1pbiB0byBiZSBncmVhdGVyIHRoYW4gdGhlIHNsaWRlclxcJ3MgbWF4aW11bSB2YWx1ZScpO1xuICAgIH1cbiAgICB0aGlzLm1pbl8gPSBtaW47XG4gICAgdGhpcy5zZXRWYWx1ZV8odGhpcy52YWx1ZV8sIGZhbHNlLCB0cnVlKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHJpYnV0ZShzdHJpbmdzLkFSSUFfVkFMVUVNSU4sIFN0cmluZyh0aGlzLm1pbl8pKTtcbiAgICB0aGlzLnNldHVwVHJhY2tNYXJrZXIoKTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtudW1iZXJ9ICovXG4gIGdldFN0ZXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RlcF87XG4gIH1cblxuICAvKiogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgKi9cbiAgc2V0U3RlcChzdGVwKSB7XG4gICAgaWYgKHN0ZXAgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0ZXAgY2Fubm90IGJlIHNldCB0byBhIG5lZ2F0aXZlIG51bWJlcicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0Rpc2NyZXRlXyAmJiAodHlwZW9mKHN0ZXApICE9PSAnbnVtYmVyJyB8fCBzdGVwIDwgMSkpIHtcbiAgICAgIHN0ZXAgPSAxO1xuICAgIH1cbiAgICB0aGlzLnN0ZXBfID0gc3RlcDtcbiAgICB0aGlzLnNldFZhbHVlXyh0aGlzLnZhbHVlXywgZmFsc2UsIHRydWUpO1xuICAgIHRoaXMuc2V0dXBUcmFja01hcmtlcigpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzYWJsZWRfO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWQgKi9cbiAgc2V0RGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICB0aGlzLmRpc2FibGVkXyA9IGRpc2FibGVkO1xuICAgIHRoaXMudG9nZ2xlQ2xhc3NfKGNzc0NsYXNzZXMuRElTQUJMRUQsIHRoaXMuZGlzYWJsZWRfKTtcbiAgICBpZiAodGhpcy5kaXNhYmxlZF8pIHtcbiAgICAgIHRoaXMuc2F2ZWRUYWJJbmRleF8gPSB0aGlzLmFkYXB0ZXJfLmdldFRhYkluZGV4KCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHJpYnV0ZShzdHJpbmdzLkFSSUFfRElTQUJMRUQsICd0cnVlJyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVBdHRyaWJ1dGUoc3RyaW5ncy5BUklBX0RJU0FCTEVEKTtcbiAgICAgIGlmICghaXNOYU4odGhpcy5zYXZlZFRhYkluZGV4XykpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgU3RyaW5nKHRoaXMuc2F2ZWRUYWJJbmRleF8pKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGludGVyYWN0aW5nIHdpdGggdGhlIHNsaWRlclxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVEb3duXyhldnQpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnByZXZlbnRGb2N1c1N0YXRlXyA9IHRydWU7XG4gICAgdGhpcy5zZXRJblRyYW5zaXRfKCF0aGlzLmhhbmRsaW5nVGh1bWJUYXJnZXRFdnRfKTtcbiAgICB0aGlzLmhhbmRsaW5nVGh1bWJUYXJnZXRFdnRfID0gZmFsc2U7XG4gICAgdGhpcy5zZXRBY3RpdmVfKHRydWUpO1xuXG4gICAgY29uc3QgbW92ZUhhbmRsZXIgPSAoZXZ0KSA9PiB7XG4gICAgICB0aGlzLmhhbmRsZU1vdmVfKGV2dCk7XG4gICAgfTtcblxuICAgIC8vIE5vdGU6IHVwSGFuZGxlciBpcyBbZGVdcmVnaXN0ZXJlZCBvbiBBTEwgcG90ZW50aWFsIHBvaW50ZXItcmVsYXRlZCByZWxlYXNlIGV2ZW50IHR5cGVzLCBzaW5jZSBzb21lIGJyb3dzZXJzXG4gICAgLy8gZG8gbm90IGFsd2F5cyBmaXJlIHRoZXNlIGNvbnNpc3RlbnRseSBpbiBwYWlycy5cbiAgICAvLyAoU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2lzc3Vlcy8xMTkyKVxuICAgIGNvbnN0IHVwSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlVXBfKCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyKE1PVkVfRVZFTlRfTUFQW2V2dC50eXBlXSwgbW92ZUhhbmRsZXIpO1xuICAgICAgVVBfRVZFTlRTLmZvckVhY2goKGV2dE5hbWUpID0+IHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0TmFtZSwgdXBIYW5kbGVyKSk7XG4gICAgfTtcblxuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyKE1PVkVfRVZFTlRfTUFQW2V2dC50eXBlXSwgbW92ZUhhbmRsZXIpO1xuICAgIFVQX0VWRU5UUy5mb3JFYWNoKChldnROYW1lKSA9PiB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlcihldnROYW1lLCB1cEhhbmRsZXIpKTtcbiAgICB0aGlzLnNldFZhbHVlRnJvbUV2dF8oZXZ0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgdXNlciBtb3ZlcyB0aGUgc2xpZGVyXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZU1vdmVfKGV2dCkge1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuc2V0VmFsdWVGcm9tRXZ0XyhldnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSB1c2VyJ3MgaW50ZXJhY3Rpb24gd2l0aCB0aGUgc2xpZGVyIGVuZHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVVwXygpIHtcbiAgICB0aGlzLnNldEFjdGl2ZV8oZmFsc2UpO1xuICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2hhbmdlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGFnZVggb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UGFnZVhfKGV2dCkge1xuICAgIGlmIChldnQudGFyZ2V0VG91Y2hlcyAmJiBldnQudGFyZ2V0VG91Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gZXZ0LnRhcmdldFRvdWNoZXNbMF0ucGFnZVg7XG4gICAgfVxuICAgIHJldHVybiBldnQucGFnZVg7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc2xpZGVyIHZhbHVlIGZyb20gYW4gZXZlbnRcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0VmFsdWVGcm9tRXZ0XyhldnQpIHtcbiAgICBjb25zdCBwYWdlWCA9IHRoaXMuZ2V0UGFnZVhfKGV2dCk7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmNvbXB1dGVWYWx1ZUZyb21QYWdlWF8ocGFnZVgpO1xuICAgIHRoaXMuc2V0VmFsdWVfKHZhbHVlLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgbmV3IHZhbHVlIGZyb20gdGhlIHBhZ2VYIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwYWdlWFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBjb21wdXRlVmFsdWVGcm9tUGFnZVhfKHBhZ2VYKSB7XG4gICAgY29uc3Qge21heF86IG1heCwgbWluXzogbWlufSA9IHRoaXM7XG4gICAgY29uc3QgeFBvcyA9IHBhZ2VYIC0gdGhpcy5yZWN0Xy5sZWZ0O1xuICAgIGxldCBwY3RDb21wbGV0ZSA9IHhQb3MgLyB0aGlzLnJlY3RfLndpZHRoO1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzUlRMKCkpIHtcbiAgICAgIHBjdENvbXBsZXRlID0gMSAtIHBjdENvbXBsZXRlO1xuICAgIH1cbiAgICAvLyBGaXQgdGhlIHBlcmNlbnRhZ2UgY29tcGxldGUgYmV0d2VlbiB0aGUgcmFuZ2UgW21pbixtYXhdXG4gICAgLy8gYnkgcmVtYXBwaW5nIGZyb20gWzAsIDFdIHRvIFttaW4sIG1pbisobWF4LW1pbildLlxuICAgIHJldHVybiBtaW4gKyBwY3RDb21wbGV0ZSAqIChtYXggLSBtaW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMga2V5ZG93biBldmVudHNcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKi9cbiAgaGFuZGxlS2V5ZG93bl8oZXZ0KSB7XG4gICAgY29uc3Qga2V5SWQgPSB0aGlzLmdldEtleUlkXyhldnQpO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXRWYWx1ZUZvcktleUlkXyhrZXlJZCk7XG4gICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFByZXZlbnQgcGFnZSBmcm9tIHNjcm9sbGluZyBkdWUgdG8ga2V5IHByZXNzZXMgdGhhdCB3b3VsZCBub3JtYWxseSBzY3JvbGwgdGhlIHBhZ2VcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuRk9DVVMpO1xuICAgIHRoaXMuc2V0VmFsdWVfKHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUNoYW5nZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbXB1dGVkIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7IUV2ZW50fSBrYmRFdnRcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0S2V5SWRfKGtiZEV2dCkge1xuICAgIGlmIChrYmRFdnQua2V5ID09PSBLRVlfSURTLkFSUk9XX0xFRlQgfHwga2JkRXZ0LmtleUNvZGUgPT09IDM3KSB7XG4gICAgICByZXR1cm4gS0VZX0lEUy5BUlJPV19MRUZUO1xuICAgIH1cbiAgICBpZiAoa2JkRXZ0LmtleSA9PT0gS0VZX0lEUy5BUlJPV19SSUdIVCB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzkpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLkFSUk9XX1JJR0hUO1xuICAgIH1cbiAgICBpZiAoa2JkRXZ0LmtleSA9PT0gS0VZX0lEUy5BUlJPV19VUCB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzgpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLkFSUk9XX1VQO1xuICAgIH1cbiAgICBpZiAoa2JkRXZ0LmtleSA9PT0gS0VZX0lEUy5BUlJPV19ET1dOIHx8IGtiZEV2dC5rZXlDb2RlID09PSA0MCkge1xuICAgICAgcmV0dXJuIEtFWV9JRFMuQVJST1dfRE9XTjtcbiAgICB9XG4gICAgaWYgKGtiZEV2dC5rZXkgPT09IEtFWV9JRFMuSE9NRSB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzYpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLkhPTUU7XG4gICAgfVxuICAgIGlmIChrYmRFdnQua2V5ID09PSBLRVlfSURTLkVORCB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzUpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLkVORDtcbiAgICB9XG4gICAgaWYgKGtiZEV2dC5rZXkgPT09IEtFWV9JRFMuUEFHRV9VUCB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzMpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLlBBR0VfVVA7XG4gICAgfVxuICAgIGlmIChrYmRFdnQua2V5ID09PSBLRVlfSURTLlBBR0VfRE9XTiB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzQpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLlBBR0VfRE9XTjtcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHZhbHVlIGdpdmVuIGEga2V5Ym9hcmQga2V5IElEXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlJZFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRWYWx1ZUZvcktleUlkXyhrZXlJZCkge1xuICAgIGNvbnN0IHttYXhfOiBtYXgsIG1pbl86IG1pbiwgc3RlcF86IHN0ZXB9ID0gdGhpcztcbiAgICBsZXQgZGVsdGEgPSBzdGVwIHx8IChtYXggLSBtaW4pIC8gMTAwO1xuICAgIGNvbnN0IHZhbHVlTmVlZHNUb0JlRmxpcHBlZCA9IHRoaXMuYWRhcHRlcl8uaXNSVEwoKSAmJiAoXG4gICAgICBrZXlJZCA9PT0gS0VZX0lEUy5BUlJPV19MRUZUIHx8IGtleUlkID09PSBLRVlfSURTLkFSUk9XX1JJR0hUXG4gICAgKTtcbiAgICBpZiAodmFsdWVOZWVkc1RvQmVGbGlwcGVkKSB7XG4gICAgICBkZWx0YSA9IC1kZWx0YTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGtleUlkKSB7XG4gICAgY2FzZSBLRVlfSURTLkFSUk9XX0xFRlQ6XG4gICAgY2FzZSBLRVlfSURTLkFSUk9XX0RPV046XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZV8gLSBkZWx0YTtcbiAgICBjYXNlIEtFWV9JRFMuQVJST1dfUklHSFQ6XG4gICAgY2FzZSBLRVlfSURTLkFSUk9XX1VQOlxuICAgICAgcmV0dXJuIHRoaXMudmFsdWVfICsgZGVsdGE7XG4gICAgY2FzZSBLRVlfSURTLkhPTUU6XG4gICAgICByZXR1cm4gdGhpcy5taW5fO1xuICAgIGNhc2UgS0VZX0lEUy5FTkQ6XG4gICAgICByZXR1cm4gdGhpcy5tYXhfO1xuICAgIGNhc2UgS0VZX0lEUy5QQUdFX1VQOlxuICAgICAgcmV0dXJuIHRoaXMudmFsdWVfICsgZGVsdGEgKiBudW1iZXJzLlBBR0VfRkFDVE9SO1xuICAgIGNhc2UgS0VZX0lEUy5QQUdFX0RPV046XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZV8gLSBkZWx0YSAqIG51bWJlcnMuUEFHRV9GQUNUT1I7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlRm9jdXNfKCkge1xuICAgIGlmICh0aGlzLnByZXZlbnRGb2N1c1N0YXRlXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuRk9DVVMpO1xuICB9XG5cbiAgaGFuZGxlQmx1cl8oKSB7XG4gICAgdGhpcy5wcmV2ZW50Rm9jdXNTdGF0ZV8gPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuRk9DVVMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBzbGlkZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkRmlyZUlucHV0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGZvcmNlXG4gICAqL1xuICBzZXRWYWx1ZV8odmFsdWUsIHNob3VsZEZpcmVJbnB1dCwgZm9yY2UgPSBmYWxzZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdGhpcy52YWx1ZV8gJiYgIWZvcmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge21pbl86IG1pbiwgbWF4XzogbWF4fSA9IHRoaXM7XG4gICAgY29uc3QgdmFsdWVTZXRUb0JvdW5kYXJ5ID0gdmFsdWUgPT09IG1pbiB8fCB2YWx1ZSA9PT0gbWF4O1xuICAgIGlmICh0aGlzLnN0ZXBfICYmICF2YWx1ZVNldFRvQm91bmRhcnkpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5xdWFudGl6ZV8odmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICAgIHZhbHVlID0gbWluO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgIHZhbHVlID0gbWF4O1xuICAgIH1cbiAgICB0aGlzLnZhbHVlXyA9IHZhbHVlO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cmlidXRlKHN0cmluZ3MuQVJJQV9WQUxVRU5PVywgU3RyaW5nKHRoaXMudmFsdWVfKSk7XG4gICAgdGhpcy51cGRhdGVVSUZvckN1cnJlbnRWYWx1ZV8oKTtcblxuICAgIGlmIChzaG91bGRGaXJlSW5wdXQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5SW5wdXQoKTtcbiAgICAgIGlmICh0aGlzLmlzRGlzY3JldGVfKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uc2V0TWFya2VyVmFsdWUodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBxdWFudGl6ZWQgdmFsdWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHF1YW50aXplXyh2YWx1ZSkge1xuICAgIGNvbnN0IG51bVN0ZXBzID0gTWF0aC5yb3VuZCh2YWx1ZSAvIHRoaXMuc3RlcF8pO1xuICAgIGNvbnN0IHF1YW50aXplZFZhbCA9IG51bVN0ZXBzICogdGhpcy5zdGVwXztcbiAgICByZXR1cm4gcXVhbnRpemVkVmFsO1xuICB9XG5cbiAgdXBkYXRlVUlGb3JDdXJyZW50VmFsdWVfKCkge1xuICAgIGNvbnN0IHttYXhfOiBtYXgsIG1pbl86IG1pbiwgdmFsdWVfOiB2YWx1ZX0gPSB0aGlzO1xuICAgIGNvbnN0IHBjdENvbXBsZXRlID0gKHZhbHVlIC0gbWluKSAvIChtYXggLSBtaW4pO1xuICAgIGxldCB0cmFuc2xhdGVQeCA9IHBjdENvbXBsZXRlICogdGhpcy5yZWN0Xy53aWR0aDtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc1JUTCgpKSB7XG4gICAgICB0cmFuc2xhdGVQeCA9IHRoaXMucmVjdF8ud2lkdGggLSB0cmFuc2xhdGVQeDtcbiAgICB9XG5cbiAgICBjb25zdCB0cmFuc2Zvcm1Qcm9wID0gZ2V0Q29ycmVjdFByb3BlcnR5TmFtZSh3aW5kb3csICd0cmFuc2Zvcm0nKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uZW5kRXZ0TmFtZSA9IGdldENvcnJlY3RFdmVudE5hbWUod2luZG93LCAndHJhbnNpdGlvbmVuZCcpO1xuXG4gICAgaWYgKHRoaXMuaW5UcmFuc2l0Xykge1xuICAgICAgY29uc3Qgb25UcmFuc2l0aW9uRW5kID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnNldEluVHJhbnNpdF8oZmFsc2UpO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJUaHVtYkNvbnRhaW5lckludGVyYWN0aW9uSGFuZGxlcih0cmFuc2l0aW9uZW5kRXZ0TmFtZSwgb25UcmFuc2l0aW9uRW5kKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIodHJhbnNpdGlvbmVuZEV2dE5hbWUsIG9uVHJhbnNpdGlvbkVuZCk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVVSUZyYW1lXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAvLyBOT1RFKHRyYXZpc2thdWZtYW4pOiBJdCB3b3VsZCBiZSBuaWNlIHRvIHVzZSBjYWxjKCkgaGVyZSxcbiAgICAgIC8vIGJ1dCBJRSBjYW5ub3QgaGFuZGxlIGNhbGNzIGluIHRyYW5zZm9ybXMgY29ycmVjdGx5LlxuICAgICAgLy8gU2VlOiBodHRwczovL2dvby5nbC9OQzJpdGtcbiAgICAgIC8vIEFsc28gbm90ZSB0aGF0IHRoZSAtNTAlIG9mZnNldCBpcyB1c2VkIHRvIGNlbnRlciB0aGUgc2xpZGVyIHRodW1iLlxuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRUaHVtYkNvbnRhaW5lclN0eWxlUHJvcGVydHkodHJhbnNmb3JtUHJvcCwgYHRyYW5zbGF0ZVgoJHt0cmFuc2xhdGVQeH1weCkgdHJhbnNsYXRlWCgtNTAlKWApO1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRUcmFja1N0eWxlUHJvcGVydHkodHJhbnNmb3JtUHJvcCwgYHNjYWxlWCgke3BjdENvbXBsZXRlfSlgKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBhY3RpdmUgc3RhdGUgb2YgdGhlIHNsaWRlclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFjdGl2ZVxuICAgKi9cbiAgc2V0QWN0aXZlXyhhY3RpdmUpIHtcbiAgICB0aGlzLmFjdGl2ZV8gPSBhY3RpdmU7XG4gICAgdGhpcy50b2dnbGVDbGFzc18oY3NzQ2xhc3Nlcy5BQ1RJVkUsIHRoaXMuYWN0aXZlXyk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgaW5UcmFuc2l0IHN0YXRlIG9mIHRoZSBzbGlkZXJcbiAgICogQHBhcmFtIHtib29sZWFufSBpblRyYW5zaXRcbiAgICovXG4gIHNldEluVHJhbnNpdF8oaW5UcmFuc2l0KSB7XG4gICAgdGhpcy5pblRyYW5zaXRfID0gaW5UcmFuc2l0O1xuICAgIHRoaXMudG9nZ2xlQ2xhc3NfKGNzc0NsYXNzZXMuSU5fVFJBTlNJVCwgdGhpcy5pblRyYW5zaXRfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25kaXRpb25hbGx5IGFkZHMgb3IgcmVtb3ZlcyBhIGNsYXNzIGJhc2VkIG9uIHNob3VsZEJlUHJlc2VudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkQmVQcmVzZW50XG4gICAqL1xuICB0b2dnbGVDbGFzc18oY2xhc3NOYW1lLCBzaG91bGRCZVByZXNlbnQpIHtcbiAgICBpZiAoc2hvdWxkQmVQcmVzZW50KSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNsYXNzTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDU2xpZGVyRm91bmRhdGlvbjtcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdlxuICAgIDpjbGFzcz1cImNsYXNzZXNcIlxuICAgIGNsYXNzPVwibWRjLXNsaWRlclwiXG4gICAgdGFiaW5kZXg9XCIwXCJcbiAgICByb2xlPVwic2xpZGVyXCI+XG4gICAgPGRpdiBjbGFzcz1cIm1kYy1zbGlkZXJfX3RyYWNrLWNvbnRhaW5lclwiPlxuICAgICAgPGRpdlxuICAgICAgICA6c3R5bGU9XCJ0cmFja1N0eWxlc1wiXG4gICAgICAgIGNsYXNzPVwibWRjLXNsaWRlcl9fdHJhY2tcIi8+XG4gICAgICA8ZGl2XG4gICAgICAgIHYtaWY9XCJoYXNNYXJrZXJzXCJcbiAgICAgICAgY2xhc3M9XCJtZGMtc2xpZGVyX190cmFjay1tYXJrZXItY29udGFpbmVyXCI+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICB2LWZvcj1cIm1hcmtlck51bSBpbiBudW1NYXJrZXJzXCJcbiAgICAgICAgICA6a2V5PVwibWFya2VyTnVtXCJcbiAgICAgICAgICA6c3R5bGU9XCIobWFya2VyTnVtID09IG51bU1hcmtlcnMpID8gbGFzdFRyYWNrTWFya2Vyc1N0eWxlcyA6IHt9XCJcbiAgICAgICAgICBjbGFzcz1cIm1kYy1zbGlkZXJfX3RyYWNrLW1hcmtlclwiXG4gICAgICAgIC8+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2XG4gICAgICByZWY9XCJ0aHVtYkNvbnRhaW5lclwiXG4gICAgICA6c3R5bGU9XCJ0aHVtYlN0eWxlc1wiXG4gICAgICBjbGFzcz1cIm1kYy1zbGlkZXJfX3RodW1iLWNvbnRhaW5lclwiPlxuICAgICAgPGRpdlxuICAgICAgICB2LWlmPVwiaXNEaXNjcmV0ZVwiXG4gICAgICAgIGNsYXNzPVwibWRjLXNsaWRlcl9fcGluXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwibWRjLXNsaWRlcl9fcGluLXZhbHVlLW1hcmtlclwiPnt7IG1hcmtlclZhbHVlIH19PC9zcGFuPlxuICAgICAgPC9kaXY+XG4gICAgICA8c3ZnXG4gICAgICAgIGNsYXNzPVwibWRjLXNsaWRlcl9fdGh1bWJcIlxuICAgICAgICB3aWR0aD1cIjIxXCJcbiAgICAgICAgaGVpZ2h0PVwiMjFcIj5cbiAgICAgICAgPGNpcmNsZVxuICAgICAgICAgIGN4PVwiMTAuNVwiXG4gICAgICAgICAgY3k9XCIxMC41XCJcbiAgICAgICAgICByPVwiNy44NzVcIi8+XG4gICAgICA8L3N2Zz5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtc2xpZGVyX19mb2N1cy1yaW5nXCIvPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDU2xpZGVyRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvc2xpZGVyL2ZvdW5kYXRpb24nXG5pbXBvcnQgeyBEaXNwYXRjaEZvY3VzTWl4aW4sIGFwcGx5UGFzc2l2ZSB9IGZyb20gJy4uL2Jhc2UnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1zbGlkZXInLFxuICBtaXhpbnM6IFtEaXNwYXRjaEZvY3VzTWl4aW5dLFxuICBtb2RlbDoge1xuICAgIHByb3A6ICd2YWx1ZScsXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgdmFsdWU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgbWluOiB7IHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sIGRlZmF1bHQ6IDAgfSxcbiAgICBtYXg6IHsgdHlwZTogW051bWJlciwgU3RyaW5nXSwgZGVmYXVsdDogMTAwIH0sXG4gICAgc3RlcDogeyB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLCBkZWZhdWx0OiAwIH0sXG4gICAgZGlzcGxheU1hcmtlcnM6IEJvb2xlYW4sXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgbGF5b3V0T246IFN0cmluZyxcbiAgICBsYXlvdXRPblNvdXJjZTogeyB0eXBlOiBPYmplY3QsIHJlcXVpcmVkOiBmYWxzZSB9XG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1zbGlkZXItLWRpc2NyZXRlJzogISF0aGlzLnN0ZXAsXG4gICAgICAgICdtZGMtc2xpZGVyLS1kaXNwbGF5LW1hcmtlcnMnOiB0aGlzLmRpc3BsYXlNYXJrZXJzXG4gICAgICB9LFxuICAgICAgdHJhY2tTdHlsZXM6IHt9LFxuICAgICAgbGFzdFRyYWNrTWFya2Vyc1N0eWxlczoge30sXG4gICAgICB0aHVtYlN0eWxlczoge30sXG4gICAgICBtYXJrZXJWYWx1ZTogJycsXG4gICAgICBudW1NYXJrZXJzOiAwXG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGlzRGlzY3JldGUoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnN0ZXBcbiAgICB9LFxuICAgIGhhc01hcmtlcnMoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnN0ZXAgJiYgdGhpcy5kaXNwbGF5TWFya2VycyAmJiB0aGlzLm51bU1hcmtlcnNcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgdmFsdWUoKSB7XG4gICAgICBpZiAodGhpcy5mb3VuZGF0aW9uLmdldFZhbHVlKCkgIT09IE51bWJlcih0aGlzLnZhbHVlKSkge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24uc2V0VmFsdWUodGhpcy52YWx1ZSlcbiAgICAgIH1cbiAgICB9LFxuICAgIG1pbigpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRNaW4oTnVtYmVyKHRoaXMubWluKSlcbiAgICB9LFxuICAgIG1heCgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRNYXgoTnVtYmVyKHRoaXMubWF4KSlcbiAgICB9LFxuICAgIHN0ZXAoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0U3RlcChOdW1iZXIodGhpcy5zdGVwKSlcbiAgICB9LFxuICAgIGRpc2FibGVkKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHRoaXMuZGlzYWJsZWQpXG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENTbGlkZXJGb3VuZGF0aW9uKHtcbiAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSksXG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgfSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICB9LFxuICAgICAgZ2V0QXR0cmlidXRlOiBuYW1lID0+IHRoaXMuJGVsLmdldEF0dHJpYnV0ZShuYW1lKSxcbiAgICAgIHNldEF0dHJpYnV0ZTogKG5hbWUsIHZhbHVlKSA9PiB0aGlzLiRlbC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpLFxuICAgICAgcmVtb3ZlQXR0cmlidXRlOiBuYW1lID0+IHRoaXMuJGVsLnJlbW92ZUF0dHJpYnV0ZShuYW1lKSxcbiAgICAgIGNvbXB1dGVCb3VuZGluZ1JlY3Q6ICgpID0+IHRoaXMuJGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgZ2V0VGFiSW5kZXg6ICgpID0+IHRoaXMuJGVsLnRhYkluZGV4LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgYXBwbHlQYXNzaXZlKCkpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBhcHBseVBhc3NpdmUoKSlcbiAgICAgIH0sXG4gICAgICByZWdpc3RlclRodW1iQ29udGFpbmVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLnRodW1iQ29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgIGFwcGx5UGFzc2l2ZSgpXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMudGh1bWJDb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgYXBwbHlQYXNzaXZlKClcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgbm90aWZ5SW5wdXQ6ICgpID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCB0aGlzLmZvdW5kYXRpb24uZ2V0VmFsdWUoKSlcbiAgICAgIH0sXG4gICAgICBub3RpZnlDaGFuZ2U6ICgpID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgdGhpcy5mb3VuZGF0aW9uLmdldFZhbHVlKCkpXG4gICAgICB9LFxuICAgICAgc2V0VGh1bWJDb250YWluZXJTdHlsZVByb3BlcnR5OiAocHJvcGVydHlOYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy50aHVtYlN0eWxlcywgcHJvcGVydHlOYW1lLCB2YWx1ZSlcbiAgICAgIH0sXG4gICAgICBzZXRUcmFja1N0eWxlUHJvcGVydHk6IChwcm9wZXJ0eU5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnRyYWNrU3R5bGVzLCBwcm9wZXJ0eU5hbWUsIHZhbHVlKVxuICAgICAgfSxcbiAgICAgIHNldE1hcmtlclZhbHVlOiB2YWx1ZSA9PiB7XG4gICAgICAgIHRoaXMubWFya2VyVmFsdWUgPSB2YWx1ZVxuICAgICAgfSxcbiAgICAgIGFwcGVuZFRyYWNrTWFya2VyczogbnVtTWFya2VycyA9PiB7XG4gICAgICAgIHRoaXMubnVtTWFya2VycyA9IG51bU1hcmtlcnNcbiAgICAgIH0sXG4gICAgICByZW1vdmVUcmFja01hcmtlcnM6ICgpID0+IHtcbiAgICAgICAgdGhpcy5udW1NYXJrZXJzID0gMFxuICAgICAgfSxcbiAgICAgIHNldExhc3RUcmFja01hcmtlcnNTdHlsZVByb3BlcnR5OiAocHJvcGVydHlOYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5sYXN0VHJhY2tNYXJrZXJzU3R5bGVzLCBwcm9wZXJ0eU5hbWUsIHZhbHVlKVxuICAgICAgfSxcbiAgICAgIGlzUlRMOiAoKSA9PiBmYWxzZVxuICAgIH0pXG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHRoaXMuZGlzYWJsZWQpXG4gICAgaWYgKE51bWJlcih0aGlzLm1pbikgPD0gdGhpcy5mb3VuZGF0aW9uLmdldE1heCgpKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0TWluKE51bWJlcih0aGlzLm1pbikpXG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0TWF4KE51bWJlcih0aGlzLm1heCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRNYXgoTnVtYmVyKHRoaXMubWF4KSlcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRNaW4oTnVtYmVyKHRoaXMubWluKSlcbiAgICB9XG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldFN0ZXAoTnVtYmVyKHRoaXMuc3RlcCkpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldFZhbHVlKE51bWJlcih0aGlzLnZhbHVlKSlcbiAgICBpZiAodGhpcy5oYXNNYXJrZXJzKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0dXBUcmFja01hcmtlcigpXG4gICAgfVxuXG4gICAgdGhpcy4kcm9vdC4kb24oJ3ZtYTpsYXlvdXQnLCB0aGlzLmxheW91dClcblxuICAgIGlmICh0aGlzLmxheW91dE9uKSB7XG4gICAgICB0aGlzLmxheW91dE9uRXZlbnRTb3VyY2UgPSB0aGlzLmxheW91dE9uU291cmNlIHx8IHRoaXMuJHJvb3RcbiAgICAgIHRoaXMubGF5b3V0T25FdmVudFNvdXJjZS4kb24odGhpcy5sYXlvdXRPbiwgdGhpcy5sYXlvdXQpXG4gICAgfVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuJHJvb3QuJG9mZigndm1hOmxheW91dCcsIHRoaXMubGF5b3V0KVxuICAgIGlmICh0aGlzLmxheW91dE9uRXZlbnRTb3VyY2UpIHtcbiAgICAgIHRoaXMubGF5b3V0T25FdmVudFNvdXJjZS4kb2ZmKHRoaXMubGF5b3V0T24sIHRoaXMubGF5b3V0KVxuICAgIH1cbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBsYXlvdXQoKSB7XG4gICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24ubGF5b3V0KClcbiAgICAgIH0pXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY1NsaWRlciBmcm9tICcuL21kYy1zbGlkZXIudnVlJ1xuXG5leHBvcnQgeyBtZGNTbGlkZXIgfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjU2xpZGVyXG59KVxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xuICBST09UOiAnbWRjLXNuYWNrYmFyJyxcbiAgVEVYVDogJ21kYy1zbmFja2Jhcl9fdGV4dCcsXG4gIEFDVElPTl9XUkFQUEVSOiAnbWRjLXNuYWNrYmFyX19hY3Rpb24td3JhcHBlcicsXG4gIEFDVElPTl9CVVRUT046ICdtZGMtc25hY2tiYXJfX2FjdGlvbi1idXR0b24nLFxuICBBQ1RJVkU6ICdtZGMtc25hY2tiYXItLWFjdGl2ZScsXG4gIE1VTFRJTElORTogJ21kYy1zbmFja2Jhci0tbXVsdGlsaW5lJyxcbiAgQUNUSU9OX09OX0JPVFRPTTogJ21kYy1zbmFja2Jhci0tYWN0aW9uLW9uLWJvdHRvbScsXG59O1xuXG5leHBvcnQgY29uc3Qgc3RyaW5ncyA9IHtcbiAgVEVYVF9TRUxFQ1RPUjogJy5tZGMtc25hY2tiYXJfX3RleHQnLFxuICBBQ1RJT05fV1JBUFBFUl9TRUxFQ1RPUjogJy5tZGMtc25hY2tiYXJfX2FjdGlvbi13cmFwcGVyJyxcbiAgQUNUSU9OX0JVVFRPTl9TRUxFQ1RPUjogJy5tZGMtc25hY2tiYXJfX2FjdGlvbi1idXR0b24nLFxuICBTSE9XX0VWRU5UOiAnTURDU25hY2tiYXI6c2hvdycsXG4gIEhJREVfRVZFTlQ6ICdNRENTbmFja2JhcjpoaWRlJyxcbn07XG5cbmV4cG9ydCBjb25zdCBudW1iZXJzID0ge1xuICBNRVNTQUdFX1RJTUVPVVQ6IDI3NTAsXG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtNRENGb3VuZGF0aW9ufSBmcm9tICdAbWF0ZXJpYWwvYmFzZS9pbmRleCc7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURDU25hY2tiYXJGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXRBcmlhSGlkZGVuOiAoKSA9PiB7fSxcbiAgICAgIHVuc2V0QXJpYUhpZGRlbjogKCkgPT4ge30sXG4gICAgICBzZXRBY3Rpb25BcmlhSGlkZGVuOiAoKSA9PiB7fSxcbiAgICAgIHVuc2V0QWN0aW9uQXJpYUhpZGRlbjogKCkgPT4ge30sXG4gICAgICBzZXRBY3Rpb25UZXh0OiAoLyogYWN0aW9uVGV4dDogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldE1lc3NhZ2VUZXh0OiAoLyogbWVzc2FnZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldEZvY3VzOiAoKSA9PiB7fSxcbiAgICAgIHZpc2liaWxpdHlJc0hpZGRlbjogKCkgPT4gLyogYm9vbGVhbiAqLyBmYWxzZSxcbiAgICAgIHJlZ2lzdGVyQ2FwdHVyZWRCbHVySGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckNhcHR1cmVkQmx1ckhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyVmlzaWJpbGl0eUNoYW5nZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJWaXNpYmlsaXR5Q2hhbmdlSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJDYXB0dXJlZEludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dFR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyQ2FwdHVyZWRJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnRUeXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJBY3Rpb25DbGlja0hhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJBY3Rpb25DbGlja0hhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgbm90aWZ5U2hvdzogKCkgPT4ge30sXG4gICAgICBub3RpZnlIaWRlOiAoKSA9PiB7fSxcbiAgICB9O1xuICB9XG5cbiAgZ2V0IGFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVfO1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDU25hY2tiYXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICB0aGlzLmFjdGl2ZV8gPSBmYWxzZTtcbiAgICB0aGlzLmFjdGlvbldhc0NsaWNrZWRfID0gZmFsc2U7XG4gICAgdGhpcy5kaXNtaXNzT25BY3Rpb25fID0gdHJ1ZTtcbiAgICB0aGlzLmZpcnN0Rm9jdXNfID0gdHJ1ZTtcbiAgICB0aGlzLnBvaW50ZXJEb3duUmVjb2duaXplZF8gPSBmYWxzZTtcbiAgICB0aGlzLnNuYWNrYmFySGFzRm9jdXNfID0gZmFsc2U7XG4gICAgdGhpcy5zbmFja2JhckRhdGFfID0gbnVsbDtcbiAgICB0aGlzLnF1ZXVlXyA9IFtdO1xuICAgIHRoaXMuYWN0aW9uQ2xpY2tIYW5kbGVyXyA9ICgpID0+IHtcbiAgICAgIHRoaXMuYWN0aW9uV2FzQ2xpY2tlZF8gPSB0cnVlO1xuICAgICAgdGhpcy5pbnZva2VBY3Rpb25fKCk7XG4gICAgfTtcbiAgICB0aGlzLnZpc2liaWxpdHljaGFuZ2VIYW5kbGVyXyA9ICgpID0+IHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZF8pO1xuICAgICAgdGhpcy5zbmFja2Jhckhhc0ZvY3VzXyA9IHRydWU7XG5cbiAgICAgIGlmICghdGhpcy5hZGFwdGVyXy52aXNpYmlsaXR5SXNIaWRkZW4oKSkge1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMuY2xlYW51cF8uYmluZCh0aGlzKSwgdGhpcy5zbmFja2JhckRhdGFfLnRpbWVvdXQgfHwgbnVtYmVycy5NRVNTQUdFX1RJTUVPVVQpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXJfID0gKGV2dCkgPT4ge1xuICAgICAgaWYgKGV2dC50eXBlID09ICd0b3VjaHN0YXJ0JyB8fCBldnQudHlwZSA9PSAnbW91c2Vkb3duJykge1xuICAgICAgICB0aGlzLnBvaW50ZXJEb3duUmVjb2duaXplZF8gPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5oYW5kbGVQb3NzaWJsZVRhYktleWJvYXJkRm9jdXNfKGV2dCk7XG5cbiAgICAgIGlmIChldnQudHlwZSA9PSAnZm9jdXMnKSB7XG4gICAgICAgIHRoaXMucG9pbnRlckRvd25SZWNvZ25pemVkXyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5ibHVySGFuZGxlcl8gPSAoKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWRfKTtcbiAgICAgIHRoaXMuc25hY2tiYXJIYXNGb2N1c18gPSBmYWxzZTtcbiAgICAgIHRoaXMudGltZW91dElkXyA9IHNldFRpbWVvdXQodGhpcy5jbGVhbnVwXy5iaW5kKHRoaXMpLCB0aGlzLnNuYWNrYmFyRGF0YV8udGltZW91dCB8fCBudW1iZXJzLk1FU1NBR0VfVElNRU9VVCk7XG4gICAgfTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckFjdGlvbkNsaWNrSGFuZGxlcih0aGlzLmFjdGlvbkNsaWNrSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXJpYUhpZGRlbigpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QWN0aW9uQXJpYUhpZGRlbigpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJBY3Rpb25DbGlja0hhbmRsZXIodGhpcy5hY3Rpb25DbGlja0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJDYXB0dXJlZEJsdXJIYW5kbGVyKHRoaXMuYmx1ckhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJWaXNpYmlsaXR5Q2hhbmdlSGFuZGxlcih0aGlzLnZpc2liaWxpdHljaGFuZ2VIYW5kbGVyXyk7XG4gICAgWyd0b3VjaHN0YXJ0JywgJ21vdXNlZG93bicsICdmb2N1cyddLmZvckVhY2goKGV2dFR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckNhcHR1cmVkSW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyXyk7XG4gICAgfSk7XG4gIH1cblxuICBkaXNtaXNzZXNPbkFjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNtaXNzT25BY3Rpb25fO1xuICB9XG5cbiAgc2V0RGlzbWlzc09uQWN0aW9uKGRpc21pc3NPbkFjdGlvbikge1xuICAgIHRoaXMuZGlzbWlzc09uQWN0aW9uXyA9ICEhZGlzbWlzc09uQWN0aW9uO1xuICB9XG5cbiAgc2hvdyhkYXRhKSB7XG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdQbGVhc2UgcHJvdmlkZSBhIGRhdGEgb2JqZWN0IHdpdGggYXQgbGVhc3QgYSBtZXNzYWdlIHRvIGRpc3BsYXkuJyk7XG4gICAgfVxuICAgIGlmICghZGF0YS5tZXNzYWdlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwcm92aWRlIGEgbWVzc2FnZSB0byBiZSBkaXNwbGF5ZWQuJyk7XG4gICAgfVxuICAgIGlmIChkYXRhLmFjdGlvbkhhbmRsZXIgJiYgIWRhdGEuYWN0aW9uVGV4dCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcHJvdmlkZSBhY3Rpb24gdGV4dCB3aXRoIHRoZSBoYW5kbGVyLicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgIHRoaXMucXVldWVfLnB1c2goZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZF8pO1xuICAgIHRoaXMuc25hY2tiYXJEYXRhXyA9IGRhdGE7XG4gICAgdGhpcy5maXJzdEZvY3VzXyA9IHRydWU7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclZpc2liaWxpdHlDaGFuZ2VIYW5kbGVyKHRoaXMudmlzaWJpbGl0eWNoYW5nZUhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyQ2FwdHVyZWRCbHVySGFuZGxlcih0aGlzLmJsdXJIYW5kbGVyXyk7XG4gICAgWyd0b3VjaHN0YXJ0JywgJ21vdXNlZG93bicsICdmb2N1cyddLmZvckVhY2goKGV2dFR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJDYXB0dXJlZEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCB0aGlzLmludGVyYWN0aW9uSGFuZGxlcl8pO1xuICAgIH0pO1xuXG4gICAgY29uc3Qge0FDVElWRSwgTVVMVElMSU5FLCBBQ1RJT05fT05fQk9UVE9NfSA9IGNzc0NsYXNzZXM7XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnNldE1lc3NhZ2VUZXh0KHRoaXMuc25hY2tiYXJEYXRhXy5tZXNzYWdlKTtcblxuICAgIGlmICh0aGlzLnNuYWNrYmFyRGF0YV8ubXVsdGlsaW5lKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1VTFRJTElORSk7XG4gICAgICBpZiAodGhpcy5zbmFja2JhckRhdGFfLmFjdGlvbk9uQm90dG9tKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoQUNUSU9OX09OX0JPVFRPTSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc25hY2tiYXJEYXRhXy5hY3Rpb25IYW5kbGVyKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEFjdGlvblRleHQodGhpcy5zbmFja2JhckRhdGFfLmFjdGlvblRleHQpO1xuICAgICAgdGhpcy5hY3Rpb25IYW5kbGVyXyA9IHRoaXMuc25hY2tiYXJEYXRhXy5hY3Rpb25IYW5kbGVyO1xuICAgICAgdGhpcy5zZXRBY3Rpb25IaWRkZW5fKGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRBY3Rpb25IaWRkZW5fKHRydWUpO1xuICAgICAgdGhpcy5hY3Rpb25IYW5kbGVyXyA9IG51bGw7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEFjdGlvblRleHQobnVsbCk7XG4gICAgfVxuXG4gICAgdGhpcy5hY3RpdmVfID0gdHJ1ZTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKEFDVElWRSk7XG4gICAgdGhpcy5hZGFwdGVyXy51bnNldEFyaWFIaWRkZW4oKTtcbiAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeVNob3coKTtcblxuICAgIHRoaXMudGltZW91dElkXyA9IHNldFRpbWVvdXQodGhpcy5jbGVhbnVwXy5iaW5kKHRoaXMpLCB0aGlzLnNuYWNrYmFyRGF0YV8udGltZW91dCB8fCBudW1iZXJzLk1FU1NBR0VfVElNRU9VVCk7XG4gIH1cblxuICBoYW5kbGVQb3NzaWJsZVRhYktleWJvYXJkRm9jdXNfKCkge1xuICAgIGNvbnN0IGhpamFja0ZvY3VzID1cbiAgICAgIHRoaXMuZmlyc3RGb2N1c18gJiYgIXRoaXMucG9pbnRlckRvd25SZWNvZ25pemVkXztcblxuICAgIGlmIChoaWphY2tGb2N1cykge1xuICAgICAgdGhpcy5zZXRGb2N1c09uQWN0aW9uXygpO1xuICAgIH1cblxuICAgIHRoaXMuZmlyc3RGb2N1c18gPSBmYWxzZTtcbiAgfVxuXG4gIHNldEZvY3VzT25BY3Rpb25fKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0Rm9jdXMoKTtcbiAgICB0aGlzLnNuYWNrYmFySGFzRm9jdXNfID0gdHJ1ZTtcbiAgICB0aGlzLmZpcnN0Rm9jdXNfID0gZmFsc2U7XG4gIH1cblxuICBpbnZva2VBY3Rpb25fKCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIXRoaXMuYWN0aW9uSGFuZGxlcl8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFjdGlvbkhhbmRsZXJfKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh0aGlzLmRpc21pc3NPbkFjdGlvbl8pIHtcbiAgICAgICAgdGhpcy5jbGVhbnVwXygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNsZWFudXBfKCkge1xuICAgIGNvbnN0IGFsbG93RGlzbWlzc2FsID0gIXRoaXMuc25hY2tiYXJIYXNGb2N1c18gfHwgdGhpcy5hY3Rpb25XYXNDbGlja2VkXztcblxuICAgIGlmIChhbGxvd0Rpc21pc3NhbCkge1xuICAgICAgY29uc3Qge0FDVElWRSwgTVVMVElMSU5FLCBBQ1RJT05fT05fQk9UVE9NfSA9IGNzc0NsYXNzZXM7XG5cbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoQUNUSVZFKTtcblxuICAgICAgY29uc3QgaGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkXyk7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyKGhhbmRsZXIpO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1VTFRJTElORSk7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoQUNUSU9OX09OX0JPVFRPTSk7XG4gICAgICAgIHRoaXMuc2V0QWN0aW9uSGlkZGVuXyh0cnVlKTtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBcmlhSGlkZGVuKCk7XG4gICAgICAgIHRoaXMuYWN0aXZlXyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNuYWNrYmFySGFzRm9jdXNfID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5SGlkZSgpO1xuICAgICAgICB0aGlzLnNob3dOZXh0XygpO1xuICAgICAgfTtcblxuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyKGhhbmRsZXIpO1xuICAgIH1cbiAgfVxuXG4gIHNob3dOZXh0XygpIHtcbiAgICBpZiAoIXRoaXMucXVldWVfLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNob3codGhpcy5xdWV1ZV8uc2hpZnQoKSk7XG4gIH1cblxuICBzZXRBY3Rpb25IaWRkZW5fKGlzSGlkZGVuKSB7XG4gICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEFjdGlvbkFyaWFIaWRkZW4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy51bnNldEFjdGlvbkFyaWFIaWRkZW4oKTtcbiAgICB9XG4gIH1cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBcbiAgICByZWY9XCJyb290XCIgXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiIFxuICAgIDphcmlhLWhpZGRlbj1cImhpZGRlblwiIFxuICAgIGNsYXNzPVwibWRjLXNuYWNrYmFyXCIgXG4gICAgYXJpYS1saXZlPVwiYXNzZXJ0aXZlXCIgXG4gICAgYXJpYS1hdG9taWM9XCJ0cnVlXCI+XG4gICAgPGRpdiBjbGFzcz1cIm1kYy1zbmFja2Jhcl9fdGV4dFwiPnt7IG1lc3NhZ2UgfX08L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLXNuYWNrYmFyX19hY3Rpb24td3JhcHBlclwiPlxuICAgICAgPGJ1dHRvbiBcbiAgICAgICAgcmVmPVwiYnV0dG9uXCIgXG4gICAgICAgIDphcmlhLWhpZGRlbj1cImFjdGlvbkhpZGRlblwiIFxuICAgICAgICB0eXBlPVwiYnV0dG9uXCIgXG4gICAgICAgIGNsYXNzPVwibWRjLXNuYWNrYmFyX19hY3Rpb24tYnV0dG9uXCI+e3sgYWN0aW9uVGV4dCB9fTwvYnV0dG9uPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDU25hY2tiYXJGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9zbmFja2Jhci9mb3VuZGF0aW9uJ1xuaW1wb3J0IHsgZ2V0Q29ycmVjdEV2ZW50TmFtZSB9IGZyb20gJ0BtYXRlcmlhbC9hbmltYXRpb24nXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1zbmFja2JhcicsXG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ3NuYWNrJyxcbiAgICBldmVudDogJ3F1ZXVlZCdcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICAnYWxpZ24tc3RhcnQnOiBCb29sZWFuLFxuICAgIHNuYWNrOiBPYmplY3QsXG4gICAgZXZlbnQ6IFN0cmluZyxcbiAgICAnZXZlbnQtc291cmNlJzoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgZGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJvb3RcbiAgICAgIH1cbiAgICB9LFxuICAgICdkaXNtaXNzZXMtb24tYWN0aW9uJzoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9XG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1zbmFja2Jhci0tYWxpZ24tc3RhcnQnOiB0aGlzLmFsaWduU3RhcnRcbiAgICAgIH0sXG4gICAgICBtZXNzYWdlOiAnJyxcbiAgICAgIGFjdGlvblRleHQ6ICcnLFxuICAgICAgaGlkZGVuOiBmYWxzZSxcbiAgICAgIGFjdGlvbkhpZGRlbjogZmFsc2VcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgc25hY2s6ICdvblNuYWNrJ1xuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENTbmFja2JhckZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpLFxuICAgICAgc2V0QXJpYUhpZGRlbjogKCkgPT4gKHRoaXMuaGlkZGVuID0gdHJ1ZSksXG4gICAgICB1bnNldEFyaWFIaWRkZW46ICgpID0+ICh0aGlzLmhpZGRlbiA9IGZhbHNlKSxcbiAgICAgIHNldEFjdGlvbkFyaWFIaWRkZW46ICgpID0+ICh0aGlzLmFjdGlvbkhpZGRlbiA9IHRydWUpLFxuICAgICAgdW5zZXRBY3Rpb25BcmlhSGlkZGVuOiAoKSA9PiAodGhpcy5hY3Rpb25IaWRkZW4gPSBmYWxzZSksXG4gICAgICBzZXRBY3Rpb25UZXh0OiB0ZXh0ID0+IHtcbiAgICAgICAgdGhpcy5hY3Rpb25UZXh0ID0gdGV4dFxuICAgICAgfSxcbiAgICAgIHNldE1lc3NhZ2VUZXh0OiB0ZXh0ID0+IHtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdGV4dFxuICAgICAgfSxcbiAgICAgIHNldEZvY3VzOiAoKSA9PiB0aGlzLiRyZWZzLmJ1dHRvbi5mb2N1cygpLFxuICAgICAgdmlzaWJpbGl0eUlzSGlkZGVuOiAoKSA9PiBkb2N1bWVudC5oaWRkZW4sXG4gICAgICByZWdpc3RlckNhcHR1cmVkQmx1ckhhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5idXR0b24uYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZXIsIHRydWUpLFxuICAgICAgZGVyZWdpc3RlckNhcHR1cmVkQmx1ckhhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5idXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZXIsIHRydWUpLFxuICAgICAgcmVnaXN0ZXJWaXNpYmlsaXR5Q2hhbmdlSGFuZGxlcjogaGFuZGxlciA9PlxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVyVmlzaWJpbGl0eUNoYW5nZUhhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIGhhbmRsZXIpLFxuICAgICAgcmVnaXN0ZXJDYXB0dXJlZEludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciwgdHJ1ZSksXG4gICAgICBkZXJlZ2lzdGVyQ2FwdHVyZWRJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIsIHRydWUpLFxuICAgICAgcmVnaXN0ZXJBY3Rpb25DbGlja0hhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5idXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJBY3Rpb25DbGlja0hhbmRsZXI6IGhhbmRsZXIgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5idXR0b24ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVyKSxcbiAgICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICBjb25zdCByb290ID0gdGhpcy4kcmVmcy5yb290XG4gICAgICAgIHJvb3QgJiZcbiAgICAgICAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICBnZXRDb3JyZWN0RXZlbnROYW1lKHdpbmRvdywgJ3RyYW5zaXRpb25lbmQnKSxcbiAgICAgICAgICAgIGhhbmRsZXJcbiAgICAgICAgICApXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgY29uc3Qgcm9vdCA9IHRoaXMuJHJlZnMucm9vdFxuICAgICAgICByb290ICYmXG4gICAgICAgICAgcm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgZ2V0Q29ycmVjdEV2ZW50TmFtZSh3aW5kb3csICd0cmFuc2l0aW9uZW5kJyksXG4gICAgICAgICAgICBoYW5kbGVyXG4gICAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIG5vdGlmeVNob3c6ICgpID0+IHRoaXMuJGVtaXQoJ3Nob3cnKSxcbiAgICAgIG5vdGlmeUhpZGU6ICgpID0+IHRoaXMuJGVtaXQoJ2hpZGUnKVxuICAgIH0pXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuXG4gICAgLy8gaWYgZXZlbnQgc3BlY2lmaWVkIHVzZSBpdCwgZWxzZSBpZiBubyBzbmFjayBwcm9wIHRoZW4gdXNlIGRlZmF1bHQuXG4gICAgdGhpcy5ldmVudE5hbWUgPVxuICAgICAgdGhpcy5ldmVudCB8fCAodGhpcy5zbmFjayA9PT0gdm9pZCAwID8gJ3Nob3ctc25hY2tiYXInIDogbnVsbClcbiAgICBpZiAodGhpcy5ldmVudE5hbWUpIHtcbiAgICAgIHRoaXMuZXZlbnRTb3VyY2UuJG9uKHRoaXMuZXZlbnROYW1lLCB0aGlzLnNob3cpXG4gICAgfVxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXREaXNtaXNzT25BY3Rpb24odGhpcy5kaXNtaXNzZXNPbkFjdGlvbilcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5ldmVudFNvdXJjZSkge1xuICAgICAgdGhpcy5ldmVudFNvdXJjZS4kb2ZmKHRoaXMuZXZlbnROYW1lLCB0aGlzLnNob3cpXG4gICAgfVxuICAgIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uU25hY2soc25hY2spIHtcbiAgICAgIGlmIChzbmFjayAmJiBzbmFjay5tZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5zaG93KHNuYWNrKVxuICAgICAgICB0aGlzLiRlbWl0KCdxdWV1ZWQnLCBzbmFjaylcbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3coZGF0YSkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNob3coZGF0YSlcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjU25hY2tiYXIgZnJvbSAnLi9tZGMtc25hY2tiYXIudnVlJ1xuXG5leHBvcnQgeyBtZGNTbmFja2JhciB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNTbmFja2JhclxufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdlxuICAgIDpjbGFzcz1cIntcbiAgICAgICdtZGMtZm9ybS1maWVsZCc6IGhhc0xhYmVsLFxuICAgICAgJ21kYy1mb3JtLWZpZWxkLS1hbGlnbi1lbmQnOiBoYXNMYWJlbCAmJiBhbGlnbkVuZFxuICAgIH1cIlxuICAgIGNsYXNzPVwibWRjLXN3aXRjaC13cmFwcGVyXCIgPlxuXG4gICAgPGRpdlxuICAgICAgOmNsYXNzPVwieydtZGMtc3dpdGNoLS1kaXNhYmxlZCc6IGRpc2FibGVkIH1cIlxuICAgICAgY2xhc3M9XCJtZGMtc3dpdGNoXCI+XG4gICAgICA8aW5wdXRcbiAgICAgICAgcmVmPVwiY29udHJvbFwiXG4gICAgICAgIDpuYW1lPVwibmFtZVwiXG4gICAgICAgIDppZD1cInZtYV91aWRfXCJcbiAgICAgICAgOmNoZWNrZWQ9XCJjaGVja2VkXCJcbiAgICAgICAgOmRpc2FibGVkPVwiZGlzYWJsZWRcIlxuICAgICAgICB0eXBlPVwiY2hlY2tib3hcIlxuICAgICAgICBjbGFzcz1cIm1kYy1zd2l0Y2hfX25hdGl2ZS1jb250cm9sXCJcbiAgICAgICAgQGNoYW5nZT1cIm9uQ2hhbmdlZFwiID5cblxuICAgICAgPGRpdiBjbGFzcz1cIm1kYy1zd2l0Y2hfX2JhY2tncm91bmRcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIm1kYy1zd2l0Y2hfX2tub2JcIi8+XG4gICAgICA8L2Rpdj5cblxuICAgIDwvZGl2PlxuXG4gICAgPGxhYmVsXG4gICAgICB2LWlmPVwiaGFzTGFiZWxcIlxuICAgICAgOmZvcj1cInZtYV91aWRfXCJcbiAgICAgIGNsYXNzPVwibWRjLXN3aXRjaC1sYWJlbFwiPlxuICAgICAgPHNsb3Q+e3sgbGFiZWwgfX08L3Nsb3Q+XG4gICAgPC9sYWJlbD5cblxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBEaXNwYXRjaEZvY3VzTWl4aW4sIFZNQVVuaXF1ZUlkTWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtc3dpdGNoJyxcbiAgbWl4aW5zOiBbRGlzcGF0Y2hGb2N1c01peGluLCBWTUFVbmlxdWVJZE1peGluXSxcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAnY2hlY2tlZCcsXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgY2hlY2tlZDogQm9vbGVhbixcbiAgICBsYWJlbDogU3RyaW5nLFxuICAgIGFsaWduRW5kOiBCb29sZWFuLFxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gJ29uJ1xuICAgICAgfVxuICAgIH0sXG4gICAgbmFtZTogU3RyaW5nXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaGFzTGFiZWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYWJlbCB8fCB0aGlzLiRzbG90cy5kZWZhdWx0XG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25DaGFuZ2VkKGV2ZW50KSB7XG4gICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBldmVudC50YXJnZXQuY2hlY2tlZClcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjU3dpdGNoIGZyb20gJy4vbWRjLXN3aXRjaC52dWUnXG5cbmV4cG9ydCB7IG1kY1N3aXRjaCB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNTd2l0Y2hcbn0pXG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgQUNUSVZFOiAnbWRjLXRhYi0tYWN0aXZlJyxcbn07XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBTRUxFQ1RFRF9FVkVOVDogJ01EQ1RhYjpzZWxlY3RlZCcsXG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURDVGFiRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBnZXRPZmZzZXRXaWR0aDogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBnZXRPZmZzZXRMZWZ0OiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIG5vdGlmeVNlbGVjdGVkOiAoKSA9PiB7fSxcbiAgICB9O1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlciA9IHt9KSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENUYWJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICB0aGlzLmNvbXB1dGVkV2lkdGhfID0gMDtcbiAgICB0aGlzLmNvbXB1dGVkTGVmdF8gPSAwO1xuICAgIHRoaXMuaXNBY3RpdmVfID0gZmFsc2U7XG4gICAgdGhpcy5wcmV2ZW50RGVmYXVsdE9uQ2xpY2tfID0gZmFsc2U7XG5cbiAgICB0aGlzLmNsaWNrSGFuZGxlcl8gPSAoZXZ0KSA9PiB7XG4gICAgICBpZiAodGhpcy5wcmV2ZW50RGVmYXVsdE9uQ2xpY2tfKSB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlTZWxlY3RlZCgpO1xuICAgIH07XG5cbiAgICB0aGlzLmtleWRvd25IYW5kbGVyXyA9IChldnQpID0+IHtcbiAgICAgIGlmIChldnQua2V5ICYmIGV2dC5rZXkgPT09ICdFbnRlcicgfHwgZXZ0LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5U2VsZWN0ZWQoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXJfKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXlkb3duJywgdGhpcy5rZXlkb3duSGFuZGxlcl8pO1xuICB9XG5cbiAgZ2V0Q29tcHV0ZWRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wdXRlZFdpZHRoXztcbiAgfVxuXG4gIGdldENvbXB1dGVkTGVmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb21wdXRlZExlZnRfO1xuICB9XG5cbiAgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNBY3RpdmVfO1xuICB9XG5cbiAgc2V0QWN0aXZlKGlzQWN0aXZlKSB7XG4gICAgdGhpcy5pc0FjdGl2ZV8gPSBpc0FjdGl2ZTtcbiAgICBpZiAodGhpcy5pc0FjdGl2ZV8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5BQ1RJVkUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuQUNUSVZFKTtcbiAgICB9XG4gIH1cblxuICBwcmV2ZW50c0RlZmF1bHRPbkNsaWNrKCkge1xuICAgIHJldHVybiB0aGlzLnByZXZlbnREZWZhdWx0T25DbGlja187XG4gIH1cblxuICBzZXRQcmV2ZW50RGVmYXVsdE9uQ2xpY2socHJldmVudERlZmF1bHRPbkNsaWNrKSB7XG4gICAgdGhpcy5wcmV2ZW50RGVmYXVsdE9uQ2xpY2tfID0gcHJldmVudERlZmF1bHRPbkNsaWNrO1xuICB9XG5cbiAgbWVhc3VyZVNlbGYoKSB7XG4gICAgdGhpcy5jb21wdXRlZFdpZHRoXyA9IHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0V2lkdGgoKTtcbiAgICB0aGlzLmNvbXB1dGVkTGVmdF8gPSB0aGlzLmFkYXB0ZXJfLmdldE9mZnNldExlZnQoKTtcbiAgfVxufVxuIiwiPHRlbXBsYXRlPlxyXG4gIDxjdXN0b20tbGluayBcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCJcclxuICAgIDpzdHlsZT1cInN0eWxlc1wiIFxuICAgIDpsaW5rPVwibGlua1wiXHJcbiAgICBjbGFzcz1cIm1kYy10YWJcIlxyXG4gICAgdi1vbj1cImxpc3RlbmVyc1wiPlxyXG5cclxuICAgIDxpIFxuICAgICAgdi1pZj1cIiEhaGFzSWNvblwiIFxuICAgICAgcmVmPVwiaWNvblwiXHJcbiAgICAgIDpjbGFzcz1cImhhc0ljb24uY2xhc3Nlc1wiXHJcbiAgICAgIHRhYmluZGV4PVwiMFwiXHJcbiAgICAgIGNsYXNzPVwibWRjLXRhYl9faWNvblwiPlxyXG4gICAgICA8c2xvdCBuYW1lPVwiaWNvblwiPnt7IGhhc0ljb24uY29udGVudCB9fTwvc2xvdD5cclxuICAgIDwvaT5cclxuXHJcbiAgICA8c3BhbiBcbiAgICAgIHYtaWY9XCJoYXNUZXh0XCIgXG4gICAgICA6Y2xhc3M9XCJ7J21kYy10YWJfX2ljb24tdGV4dCc6ICEhaGFzSWNvbn1cIj5cclxuICAgICAgPHNsb3QvPlxyXG4gICAgPC9zcGFuPlxyXG5cclxuICA8L2N1c3RvbS1saW5rPlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuaW1wb3J0IE1EQ1RhYkZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3RhYnMvdGFiL2ZvdW5kYXRpb24nXHJcbmltcG9ydCB7XHJcbiAgQ3VzdG9tTGlua01peGluLFxyXG4gIERpc3BhdGNoRXZlbnRNaXhpbixcclxuICBlbWl0Q3VzdG9tRXZlbnQsXHJcbiAgZXh0cmFjdEljb25Qcm9wXHJcbn0gZnJvbSAnLi4vYmFzZSdcclxuaW1wb3J0IHsgUmlwcGxlQmFzZSB9IGZyb20gJy4uL3JpcHBsZSdcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiAnbWRjLXRhYicsXHJcbiAgbWl4aW5zOiBbQ3VzdG9tTGlua01peGluLCBEaXNwYXRjaEV2ZW50TWl4aW5dLFxyXG4gIHByb3BzOiB7XHJcbiAgICBhY3RpdmU6IEJvb2xlYW4sXHJcbiAgICBpY29uOiBbU3RyaW5nLCBBcnJheSwgT2JqZWN0XVxyXG4gIH0sXHJcbiAgZGF0YSgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNsYXNzZXM6IHt9LFxyXG4gICAgICBzdHlsZXM6IHt9XHJcbiAgICB9XHJcbiAgfSxcclxuICBjb21wdXRlZDoge1xyXG4gICAgaGFzSWNvbigpIHtcclxuICAgICAgaWYgKHRoaXMuaWNvbiB8fCB0aGlzLiRzbG90cy5pY29uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaWNvbiA/IGV4dHJhY3RJY29uUHJvcCh0aGlzLmljb24pIDoge31cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH0sXHJcbiAgICBoYXNUZXh0KCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLiRzbG90cy5kZWZhdWx0XHJcbiAgICB9XHJcbiAgfSxcclxuICB3YXRjaDoge1xyXG4gICAgYWN0aXZlKHZhbHVlKSB7XHJcbiAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5hZGFwdGVyXy5ub3RpZnlTZWxlY3RlZCgpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LFxyXG4gIG1vdW50ZWQoKSB7XHJcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDVGFiRm91bmRhdGlvbih7XHJcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKSxcclxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpLFxyXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+XHJcbiAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSxcclxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+XHJcbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSxcclxuICAgICAgZ2V0T2Zmc2V0V2lkdGg6ICgpID0+IHtcclxuICAgICAgICByZXR1cm4gdGhpcy4kZWwub2Zmc2V0V2lkdGhcclxuICAgICAgfSxcclxuICAgICAgZ2V0T2Zmc2V0TGVmdDogKCkgPT4gdGhpcy4kZWwub2Zmc2V0TGVmdCxcclxuICAgICAgbm90aWZ5U2VsZWN0ZWQ6ICgpID0+IHtcclxuICAgICAgICBlbWl0Q3VzdG9tRXZlbnQoXHJcbiAgICAgICAgICB0aGlzLiRlbCxcclxuICAgICAgICAgIE1EQ1RhYkZvdW5kYXRpb24uc3RyaW5ncy5TRUxFQ1RFRF9FVkVOVCxcclxuICAgICAgICAgIHsgdGFiOiB0aGlzIH0sXHJcbiAgICAgICAgICB0cnVlXHJcbiAgICAgICAgKVxyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxyXG4gICAgdGhpcy5zZXRBY3RpdmUodGhpcy5hY3RpdmUpXHJcbiAgICB0aGlzLnJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMpXHJcbiAgICB0aGlzLnJpcHBsZS5pbml0KClcclxuICB9LFxyXG4gIGJlZm9yZURlc3Ryb3koKSB7XHJcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXHJcbiAgICB0aGlzLnJpcHBsZS5kZXN0cm95KClcclxuICB9LFxyXG4gIG1ldGhvZHM6IHtcclxuICAgIGdldENvbXB1dGVkV2lkdGgoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZvdW5kYXRpb24uZ2V0Q29tcHV0ZWRXaWR0aCgpXHJcbiAgICB9LFxyXG4gICAgZ2V0Q29tcHV0ZWRMZWZ0KCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5mb3VuZGF0aW9uLmdldENvbXB1dGVkTGVmdCgpXHJcbiAgICB9LFxyXG4gICAgaXNBY3RpdmUoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZvdW5kYXRpb24uaXNBY3RpdmUoKVxyXG4gICAgfSxcclxuICAgIHNldEFjdGl2ZShpc0FjdGl2ZSkge1xyXG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0QWN0aXZlKGlzQWN0aXZlKVxyXG4gICAgfSxcclxuICAgIGlzRGVmYXVsdFByZXZlbnRlZE9uQ2xpY2soKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZvdW5kYXRpb24ucHJldmVudHNEZWZhdWx0T25DbGljaygpXHJcbiAgICB9LFxyXG4gICAgc2V0UHJldmVudERlZmF1bHRPbkNsaWNrKHByZXZlbnREZWZhdWx0T25DbGljaykge1xyXG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0UHJldmVudERlZmF1bHRPbkNsaWNrKHByZXZlbnREZWZhdWx0T25DbGljaylcclxuICAgIH0sXHJcbiAgICBtZWFzdXJlU2VsZigpIHtcclxuICAgICAgdGhpcy5mb3VuZGF0aW9uLm1lYXN1cmVTZWxmKClcclxuICAgIH1cclxuICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xuICBVUEdSQURFRDogJ21kYy10YWItYmFyLXVwZ3JhZGVkJyxcbn07XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBUQUJfU0VMRUNUT1I6ICcubWRjLXRhYicsXG4gIElORElDQVRPUl9TRUxFQ1RPUjogJy5tZGMtdGFiLWJhcl9faW5kaWNhdG9yJyxcbiAgQ0hBTkdFX0VWRU5UOiAnTURDVGFiQmFyOmNoYW5nZScsXG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQge2dldENvcnJlY3RQcm9wZXJ0eU5hbWV9IGZyb20gJ0BtYXRlcmlhbC9hbmltYXRpb24vaW5kZXgnO1xuXG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURDVGFiQmFyRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgYmluZE9uTURDVGFiU2VsZWN0ZWRFdmVudDogKCkgPT4ge30sXG4gICAgICB1bmJpbmRPbk1EQ1RhYlNlbGVjdGVkRXZlbnQ6ICgpID0+IHt9LFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZ2V0T2Zmc2V0V2lkdGg6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgc2V0U3R5bGVGb3JJbmRpY2F0b3I6ICgvKiBwcm9wZXJ0eU5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBnZXRPZmZzZXRXaWR0aEZvckluZGljYXRvcjogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBub3RpZnlDaGFuZ2U6ICgvKiBldnREYXRhOiB7YWN0aXZlVGFiSW5kZXg6IG51bWJlcn0gKi8pID0+IHt9LFxuICAgICAgZ2V0TnVtYmVyT2ZUYWJzOiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIGlzVGFiQWN0aXZlQXRJbmRleDogKC8qIGluZGV4OiBudW1iZXIgKi8pID0+IC8qIGJvb2xlYW4gKi8gZmFsc2UsXG4gICAgICBzZXRUYWJBY3RpdmVBdEluZGV4OiAoLyogaW5kZXg6IG51bWJlciwgaXNBY3RpdmU6IHRydWUgKi8pID0+IHt9LFxuICAgICAgaXNEZWZhdWx0UHJldmVudGVkT25DbGlja0ZvclRhYkF0SW5kZXg6ICgvKiBpbmRleDogbnVtYmVyICovKSA9PiAvKiBib29sZWFuICovIGZhbHNlLFxuICAgICAgc2V0UHJldmVudERlZmF1bHRPbkNsaWNrRm9yVGFiQXRJbmRleDogKC8qIGluZGV4OiBudW1iZXIsIHByZXZlbnREZWZhdWx0T25DbGljazogYm9vbGVhbiAqLykgPT4ge30sXG4gICAgICBtZWFzdXJlVGFiQXRJbmRleDogKC8qIGluZGV4OiBudW1iZXIgKi8pID0+IHt9LFxuICAgICAgZ2V0Q29tcHV0ZWRXaWR0aEZvclRhYkF0SW5kZXg6ICgvKiBpbmRleDogbnVtYmVyICovKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIGdldENvbXB1dGVkTGVmdEZvclRhYkF0SW5kZXg6ICgvKiBpbmRleDogbnVtYmVyICovKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICB9O1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDVGFiQmFyRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgdGhpcy5pc0luZGljYXRvclNob3duXyA9IGZhbHNlO1xuICAgIHRoaXMuY29tcHV0ZWRXaWR0aF8gPSAwO1xuICAgIHRoaXMuY29tcHV0ZWRMZWZ0XyA9IDA7XG4gICAgdGhpcy5hY3RpdmVUYWJJbmRleF8gPSAwO1xuICAgIHRoaXMubGF5b3V0RnJhbWVfID0gMDtcbiAgICB0aGlzLnJlc2l6ZUhhbmRsZXJfID0gKCkgPT4gdGhpcy5sYXlvdXQoKTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLlVQR1JBREVEKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmJpbmRPbk1EQ1RhYlNlbGVjdGVkRXZlbnQoKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgICBjb25zdCBhY3RpdmVUYWJJbmRleCA9IHRoaXMuZmluZEFjdGl2ZVRhYkluZGV4XygpO1xuICAgIGlmIChhY3RpdmVUYWJJbmRleCA+PSAwKSB7XG4gICAgICB0aGlzLmFjdGl2ZVRhYkluZGV4XyA9IGFjdGl2ZVRhYkluZGV4O1xuICAgIH1cbiAgICB0aGlzLmxheW91dCgpO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuVVBHUkFERUQpO1xuICAgIHRoaXMuYWRhcHRlcl8udW5iaW5kT25NRENUYWJTZWxlY3RlZEV2ZW50KCk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgfVxuXG4gIGxheW91dEludGVybmFsXygpIHtcbiAgICB0aGlzLmZvckVhY2hUYWJJbmRleF8oKGluZGV4KSA9PiB0aGlzLmFkYXB0ZXJfLm1lYXN1cmVUYWJBdEluZGV4KGluZGV4KSk7XG4gICAgdGhpcy5jb21wdXRlZFdpZHRoXyA9IHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0V2lkdGgoKTtcbiAgICB0aGlzLmxheW91dEluZGljYXRvcl8oKTtcbiAgfVxuXG4gIGxheW91dEluZGljYXRvcl8oKSB7XG4gICAgY29uc3QgaXNJbmRpY2F0b3JGaXJzdFJlbmRlciA9ICF0aGlzLmlzSW5kaWNhdG9yU2hvd25fO1xuXG4gICAgLy8gRW5zdXJlIHRoYXQgaW5kaWNhdG9yIGFwcGVhcnMgaW4gdGhlIHJpZ2h0IHBvc2l0aW9uIGltbWVkaWF0ZWx5IGZvciBjb3JyZWN0IGZpcnN0IHJlbmRlci5cbiAgICBpZiAoaXNJbmRpY2F0b3JGaXJzdFJlbmRlcikge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZUZvckluZGljYXRvcigndHJhbnNpdGlvbicsICdub25lJyk7XG4gICAgfVxuXG4gICAgY29uc3QgdHJhbnNsYXRlQW10Rm9yQWN0aXZlVGFiTGVmdCA9IHRoaXMuYWRhcHRlcl8uZ2V0Q29tcHV0ZWRMZWZ0Rm9yVGFiQXRJbmRleCh0aGlzLmFjdGl2ZVRhYkluZGV4Xyk7XG4gICAgY29uc3Qgc2NhbGVBbXRGb3JBY3RpdmVUYWJXaWR0aCA9XG4gICAgICB0aGlzLmFkYXB0ZXJfLmdldENvbXB1dGVkV2lkdGhGb3JUYWJBdEluZGV4KHRoaXMuYWN0aXZlVGFiSW5kZXhfKSAvIHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0V2lkdGgoKTtcblxuICAgIGNvbnN0IHRyYW5zZm9ybVZhbHVlID0gYHRyYW5zbGF0ZVgoJHt0cmFuc2xhdGVBbXRGb3JBY3RpdmVUYWJMZWZ0fXB4KSBzY2FsZSgke3NjYWxlQW10Rm9yQWN0aXZlVGFiV2lkdGh9LCAxKWA7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZUZvckluZGljYXRvcihnZXRDb3JyZWN0UHJvcGVydHlOYW1lKHdpbmRvdywgJ3RyYW5zZm9ybScpLCB0cmFuc2Zvcm1WYWx1ZSk7XG5cbiAgICBpZiAoaXNJbmRpY2F0b3JGaXJzdFJlbmRlcikge1xuICAgICAgLy8gRm9yY2UgbGF5b3V0IHNvIHRoYXQgdHJhbnNmb3JtIHN0eWxlcyB0byB0YWtlIGVmZmVjdC5cbiAgICAgIHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0V2lkdGhGb3JJbmRpY2F0b3IoKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGVGb3JJbmRpY2F0b3IoJ3RyYW5zaXRpb24nLCAnJyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlRm9ySW5kaWNhdG9yKCd2aXNpYmlsaXR5JywgJ3Zpc2libGUnKTtcbiAgICAgIHRoaXMuaXNJbmRpY2F0b3JTaG93bl8gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGZpbmRBY3RpdmVUYWJJbmRleF8oKSB7XG4gICAgbGV0IGFjdGl2ZVRhYkluZGV4ID0gLTE7XG4gICAgdGhpcy5mb3JFYWNoVGFiSW5kZXhfKChpbmRleCkgPT4ge1xuICAgICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNUYWJBY3RpdmVBdEluZGV4KGluZGV4KSkge1xuICAgICAgICBhY3RpdmVUYWJJbmRleCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYWN0aXZlVGFiSW5kZXg7XG4gIH1cblxuICBmb3JFYWNoVGFiSW5kZXhfKGl0ZXJhdG9yKSB7XG4gICAgY29uc3QgbnVtVGFicyA9IHRoaXMuYWRhcHRlcl8uZ2V0TnVtYmVyT2ZUYWJzKCk7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IG51bVRhYnM7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IHNob3VsZEJyZWFrID0gaXRlcmF0b3IoaW5kZXgpO1xuICAgICAgaWYgKHNob3VsZEJyZWFrKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxheW91dCgpIHtcbiAgICBpZiAodGhpcy5sYXlvdXRGcmFtZV8pIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMubGF5b3V0RnJhbWVfKTtcbiAgICB9XG5cbiAgICB0aGlzLmxheW91dEZyYW1lXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmxheW91dEludGVybmFsXygpO1xuICAgICAgdGhpcy5sYXlvdXRGcmFtZV8gPSAwO1xuICAgIH0pO1xuICB9XG5cbiAgc3dpdGNoVG9UYWJBdEluZGV4KGluZGV4LCBzaG91bGROb3RpZnkpIHtcbiAgICBpZiAoaW5kZXggPT09IHRoaXMuYWN0aXZlVGFiSW5kZXhfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+PSB0aGlzLmFkYXB0ZXJfLmdldE51bWJlck9mVGFicygpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE91dCBvZiBib3VuZHMgaW5kZXggc3BlY2lmaWVkIGZvciB0YWI6ICR7aW5kZXh9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJldkFjdGl2ZVRhYkluZGV4ID0gdGhpcy5hY3RpdmVUYWJJbmRleF87XG4gICAgdGhpcy5hY3RpdmVUYWJJbmRleF8gPSBpbmRleDtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgaWYgKHByZXZBY3RpdmVUYWJJbmRleCA+PSAwKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uc2V0VGFiQWN0aXZlQXRJbmRleChwcmV2QWN0aXZlVGFiSW5kZXgsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0VGFiQWN0aXZlQXRJbmRleCh0aGlzLmFjdGl2ZVRhYkluZGV4XywgdHJ1ZSk7XG4gICAgICB0aGlzLmxheW91dEluZGljYXRvcl8oKTtcbiAgICAgIGlmIChzaG91bGROb3RpZnkpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlDaGFuZ2Uoe2FjdGl2ZVRhYkluZGV4OiB0aGlzLmFjdGl2ZVRhYkluZGV4X30pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0QWN0aXZlVGFiSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluZEFjdGl2ZVRhYkluZGV4XygpO1xuICB9XG59XG4iLCI8dGVtcGxhdGU+XG4gIDxuYXYgXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiIFxuICAgIGNsYXNzPVwibWRjLXRhYi1iYXJcIiBcbiAgICB2LW9uPVwiJGxpc3RlbmVyc1wiPlxuICAgIDxzbG90Lz5cbiAgICA8c3BhbiBcbiAgICAgIHJlZj1cImluZGljYXRvclwiIFxuICAgICAgOnN0eWxlPVwiaW5kaWNhdG9yU3R5bGVzXCJcbiAgICAgIGNsYXNzPVwibWRjLXRhYi1iYXJfX2luZGljYXRvclwiLz5cbiAgPC9uYXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ1RhYkJhckZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3RhYnMvdGFiLWJhci9mb3VuZGF0aW9uJ1xuaW1wb3J0IE1EQ1RhYkZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3RhYnMvdGFiL2ZvdW5kYXRpb24nXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10YWItYmFyJyxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge30sXG4gICAgICBpbmRpY2F0b3JTdHlsZXM6IHt9LFxuICAgICAgdGFiczogW11cbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ1RhYkJhckZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpLFxuICAgICAgYmluZE9uTURDVGFiU2VsZWN0ZWRFdmVudDogKCkgPT4ge1xuICAgICAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgIE1EQ1RhYkZvdW5kYXRpb24uc3RyaW5ncy5TRUxFQ1RFRF9FVkVOVCxcbiAgICAgICAgICB0aGlzLm9uU2VsZWN0XG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICB1bmJpbmRPbk1EQ1RhYlNlbGVjdGVkRXZlbnQ6ICgpID0+XG4gICAgICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgTURDVGFiRm91bmRhdGlvbi5zdHJpbmdzLlNFTEVDVEVEX0VWRU5ULFxuICAgICAgICAgIHRoaXMub25TZWxlY3RcbiAgICAgICAgKSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogaGFuZGxlciA9PlxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogaGFuZGxlciA9PlxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlciksXG4gICAgICBnZXRPZmZzZXRXaWR0aDogKCkgPT4gdGhpcy4kZWwub2Zmc2V0V2lkdGgsXG4gICAgICBzZXRTdHlsZUZvckluZGljYXRvcjogKHByb3BlcnR5TmFtZSwgdmFsdWUpID0+XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLmluZGljYXRvclN0eWxlcywgcHJvcGVydHlOYW1lLCB2YWx1ZSksXG4gICAgICBnZXRPZmZzZXRXaWR0aEZvckluZGljYXRvcjogKCkgPT4gdGhpcy4kcmVmcy5pbmRpY2F0b3Iub2Zmc2V0V2lkdGgsXG4gICAgICBub3RpZnlDaGFuZ2U6IGV2dERhdGEgPT4ge1xuICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBldnREYXRhLmFjdGl2ZVRhYkluZGV4KVxuICAgICAgfSxcbiAgICAgIGdldE51bWJlck9mVGFiczogKCkgPT4gdGhpcy50YWJzLmxlbmd0aCxcbiAgICAgIGlzVGFiQWN0aXZlQXRJbmRleDogaW5kZXggPT4gdGhpcy50YWJzW2luZGV4XS5pc0FjdGl2ZSgpLFxuICAgICAgc2V0VGFiQWN0aXZlQXRJbmRleDogKGluZGV4LCBpc0FjdGl2ZSkgPT4ge1xuICAgICAgICAvLyBwZ2JyOiAyMDE4LTA0LTA3XG4gICAgICAgIC8vIHNpbmNlIGl0IGlzIHBvc3NpYmxlIHRvIGNoYW5nZSB0aGUgbnVtYmVyIG9mIHRhYnMgcHJvZ3JhbWF0aWNhbGx5XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gZGV0ZWN0IHRoZSBmb3VuZGF0aW9uIGRlYWN0aXZhdGluZyBhIHRhYlxuICAgICAgICAvLyB0aGF0IG5vIGxvbmdlciBleGlzdHMgYnV0IHdhcyBwcmV2aW91c2x5IGFjdGl2ZS5cbiAgICAgICAgaWYgKCFpc0FjdGl2ZSAmJiBpbmRleCA+PSB0aGlzLnRhYnMubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50YWJzW2luZGV4XS5zZXRBY3RpdmUoaXNBY3RpdmUpXG4gICAgICB9LFxuICAgICAgaXNEZWZhdWx0UHJldmVudGVkT25DbGlja0ZvclRhYkF0SW5kZXg6IGluZGV4ID0+XG4gICAgICAgIHRoaXMudGFic1tpbmRleF0uaXNEZWZhdWx0UHJldmVudGVkT25DbGljaygpLFxuICAgICAgc2V0UHJldmVudERlZmF1bHRPbkNsaWNrRm9yVGFiQXRJbmRleDogKGluZGV4LCBwcmV2ZW50RGVmYXVsdE9uQ2xpY2spID0+IHtcbiAgICAgICAgdGhpcy50YWJzW2luZGV4XS5zZXRQcmV2ZW50RGVmYXVsdE9uQ2xpY2socHJldmVudERlZmF1bHRPbkNsaWNrKVxuICAgICAgfSxcbiAgICAgIG1lYXN1cmVUYWJBdEluZGV4OiBpbmRleCA9PiB0aGlzLnRhYnNbaW5kZXhdLm1lYXN1cmVTZWxmKCksXG4gICAgICBnZXRDb21wdXRlZFdpZHRoRm9yVGFiQXRJbmRleDogaW5kZXggPT5cbiAgICAgICAgdGhpcy50YWJzW2luZGV4XS5nZXRDb21wdXRlZFdpZHRoKCksXG4gICAgICBnZXRDb21wdXRlZExlZnRGb3JUYWJBdEluZGV4OiBpbmRleCA9PiB0aGlzLnRhYnNbaW5kZXhdLmdldENvbXB1dGVkTGVmdCgpXG4gICAgfSlcblxuICAgIGNvbnN0IHJlc2V0VGFicyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHRhYkVsZW1lbnRzID0gW10uc2xpY2UuY2FsbChcbiAgICAgICAgdGhpcy4kZWwucXVlcnlTZWxlY3RvckFsbChNRENUYWJCYXJGb3VuZGF0aW9uLnN0cmluZ3MuVEFCX1NFTEVDVE9SKVxuICAgICAgKVxuICAgICAgdGhpcy50YWJzID0gdGFiRWxlbWVudHMubWFwKGVsID0+IGVsLl9fdnVlX18pXG5cbiAgICAgIGxldCBoYXNUZXh0LCBoYXNJY29uXG4gICAgICBjb25zdCB0YWJzID0gdGhpcy50YWJzXG4gICAgICBmb3IgKGxldCB0YWIgb2YgdGFicykge1xuICAgICAgICBpZiAodGFiLmhhc1RleHQpIHtcbiAgICAgICAgICBoYXNUZXh0ID0gdHJ1ZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IHRhYiBvZiB0YWJzKSB7XG4gICAgICAgIGlmICh0YWIuaGFzSWNvbikge1xuICAgICAgICAgIGhhc0ljb24gPSB0cnVlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaGFzVGV4dCAmJiBoYXNJY29uKSB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsICdtZGMtdGFiLWJhci0taWNvbnMtd2l0aC10ZXh0JywgdHJ1ZSlcbiAgICAgIH0gZWxzZSBpZiAoaGFzSWNvbikge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCAnbWRjLXRhYi1iYXItLWljb24tdGFiLWJhcicsIHRydWUpXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmZvdW5kYXRpb24pIHtcbiAgICAgICAgY29uc3QgYWN0aXZlVGFiSW5kZXggPSB0aGlzLmZvdW5kYXRpb24uZ2V0QWN0aXZlVGFiSW5kZXgoKVxuICAgICAgICBpZiAoYWN0aXZlVGFiSW5kZXggPj0gMCkge1xuICAgICAgICAgIHRoaXMuZm91bmRhdGlvbi5zd2l0Y2hUb1RhYkF0SW5kZXgoYWN0aXZlVGFiSW5kZXgsIHRydWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5mb3VuZGF0aW9uLnN3aXRjaFRvVGFiQXRJbmRleCgwLCB0cnVlKVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5sYXlvdXQoKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJlc2V0VGFicygpXG5cbiAgICB0aGlzLnNsb3RPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHJlc2V0VGFicygpKVxuICAgIHRoaXMuc2xvdE9ic2VydmVyLm9ic2VydmUodGhpcy4kZWwsIHsgY2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlIH0pXG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5zbG90T2JzZXJ2ZXIuZGlzY29ubmVjdCgpXG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25TZWxlY3QoeyBkZXRhaWwgfSkge1xuICAgICAgY29uc3QgeyB0YWIgfSA9IGRldGFpbFxuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnRhYnMuaW5kZXhPZih0YWIpXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWRjLXRhYi1iYXIgaW50ZXJuYWwgZXJyb3I6IGluZGV4IG5vdCBmb3VuZCcpXG4gICAgICB9XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc3dpdGNoVG9UYWJBdEluZGV4KGluZGV4LCB0cnVlKVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNUYWIgZnJvbSAnLi9tZGMtdGFiLnZ1ZSdcbmltcG9ydCBtZGNUYWJCYXIgZnJvbSAnLi9tZGMtdGFiLWJhci52dWUnXG5cbmV4cG9ydCB7IG1kY1RhYiwgbWRjVGFiQmFyIH1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY1RhYixcbiAgbWRjVGFiQmFyXG59KVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBUZXh0IEZpZWxkIEhlbHBlciBUZXh0LlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIFRleHRGaWVsZCBoZWxwZXIgdGV4dCBpbnRvIHlvdXIgZnJhbWV3b3JrLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvYXV0aG9yaW5nLWNvbXBvbmVudHMubWRcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDVGV4dEZpZWxkSGVscGVyVGV4dEFkYXB0ZXIge1xuICAvKipcbiAgICogQWRkcyBhIGNsYXNzIHRvIHRoZSBoZWxwZXIgdGV4dCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIHRoZSBoZWxwZXIgdGV4dCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGhlbHBlciB0ZXh0IGVsZW1lbnQgY29udGFpbnMgdGhlIGdpdmVuIGNsYXNzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgYW4gYXR0cmlidXRlIHdpdGggYSBnaXZlbiB2YWx1ZSBvbiB0aGUgaGVscGVyIHRleHQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRBdHRyKGF0dHIsIHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGF0dHJpYnV0ZSBmcm9tIHRoZSBoZWxwZXIgdGV4dCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICAgKi9cbiAgcmVtb3ZlQXR0cihhdHRyKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0ZXh0IGNvbnRlbnQgZm9yIHRoZSBoZWxwZXIgdGV4dCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICAgKi9cbiAgc2V0Q29udGVudChjb250ZW50KSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUZXh0RmllbGRIZWxwZXJUZXh0QWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIEFSSUFfSElEREVOOiAnYXJpYS1oaWRkZW4nLFxuICBST0xFOiAncm9sZScsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIEhFTFBFUl9URVhUX1BFUlNJU1RFTlQ6ICdtZGMtdGV4dC1maWVsZC1oZWxwZXItdGV4dC0tcGVyc2lzdGVudCcsXG4gIEhFTFBFUl9URVhUX1ZBTElEQVRJT05fTVNHOiAnbWRjLXRleHQtZmllbGQtaGVscGVyLXRleHQtLXZhbGlkYXRpb24tbXNnJyxcbn07XG5cbmV4cG9ydCB7c3RyaW5ncywgY3NzQ2xhc3Nlc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDVGV4dEZpZWxkSGVscGVyVGV4dEFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ1RleHRGaWVsZEhlbHBlclRleHRBZGFwdGVyPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENUZXh0RmllbGRIZWxwZXJUZXh0Rm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIE1EQ1RleHRGaWVsZEhlbHBlclRleHRBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ1RleHRGaWVsZEhlbHBlclRleHRBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDVGV4dEZpZWxkSGVscGVyVGV4dEFkYXB0ZXJ9ICovICh7XG4gICAgICBhZGRDbGFzczogKCkgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKCkgPT4ge30sXG4gICAgICBoYXNDbGFzczogKCkgPT4ge30sXG4gICAgICBzZXRBdHRyOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUF0dHI6ICgpID0+IHt9LFxuICAgICAgc2V0Q29udGVudDogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDVGV4dEZpZWxkSGVscGVyVGV4dEFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgY29udGVudCBvZiB0aGUgaGVscGVyIHRleHQgZmllbGQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gICAqL1xuICBzZXRDb250ZW50KGNvbnRlbnQpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldENvbnRlbnQoY29udGVudCk7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBpc1BlcnNpc3RlbnQgU2V0cyB0aGUgcGVyc2lzdGVuY3kgb2YgdGhlIGhlbHBlciB0ZXh0LiAqL1xuICBzZXRQZXJzaXN0ZW50KGlzUGVyc2lzdGVudCkge1xuICAgIGlmIChpc1BlcnNpc3RlbnQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5IRUxQRVJfVEVYVF9QRVJTSVNURU5UKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkhFTFBFUl9URVhUX1BFUlNJU1RFTlQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVmFsaWRhdGlvbiBUcnVlIHRvIG1ha2UgdGhlIGhlbHBlciB0ZXh0IGFjdCBhcyBhblxuICAgKiAgIGVycm9yIHZhbGlkYXRpb24gbWVzc2FnZS5cbiAgICovXG4gIHNldFZhbGlkYXRpb24oaXNWYWxpZGF0aW9uKSB7XG4gICAgaWYgKGlzVmFsaWRhdGlvbikge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLkhFTFBFUl9URVhUX1ZBTElEQVRJT05fTVNHKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkhFTFBFUl9URVhUX1ZBTElEQVRJT05fTVNHKTtcbiAgICB9XG4gIH1cblxuICAvKiogTWFrZXMgdGhlIGhlbHBlciB0ZXh0IHZpc2libGUgdG8gdGhlIHNjcmVlbiByZWFkZXIuICovXG4gIHNob3dUb1NjcmVlblJlYWRlcigpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUF0dHIoc3RyaW5ncy5BUklBX0hJRERFTik7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsaWRpdHkgb2YgdGhlIGhlbHBlciB0ZXh0IGJhc2VkIG9uIHRoZSBpbnB1dCB2YWxpZGl0eS5cbiAgICogQHBhcmFtIHtib29sZWFufSBpbnB1dElzVmFsaWRcbiAgICovXG4gIHNldFZhbGlkaXR5KGlucHV0SXNWYWxpZCkge1xuICAgIGNvbnN0IGhlbHBlclRleHRJc1BlcnNpc3RlbnQgPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuSEVMUEVSX1RFWFRfUEVSU0lTVEVOVCk7XG4gICAgY29uc3QgaGVscGVyVGV4dElzVmFsaWRhdGlvbk1zZyA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5IRUxQRVJfVEVYVF9WQUxJREFUSU9OX01TRyk7XG4gICAgY29uc3QgdmFsaWRhdGlvbk1zZ05lZWRzRGlzcGxheSA9IGhlbHBlclRleHRJc1ZhbGlkYXRpb25Nc2cgJiYgIWlucHV0SXNWYWxpZDtcblxuICAgIGlmICh2YWxpZGF0aW9uTXNnTmVlZHNEaXNwbGF5KSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoc3RyaW5ncy5ST0xFLCAnYWxlcnQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVBdHRyKHN0cmluZ3MuUk9MRSk7XG4gICAgfVxuXG4gICAgaWYgKCFoZWxwZXJUZXh0SXNQZXJzaXN0ZW50ICYmICF2YWxpZGF0aW9uTXNnTmVlZHNEaXNwbGF5KSB7XG4gICAgICB0aGlzLmhpZGVfKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhpZGVzIHRoZSBoZWxwIHRleHQgZnJvbSBzY3JlZW4gcmVhZGVycy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhpZGVfKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cihzdHJpbmdzLkFSSUFfSElEREVOLCAndHJ1ZScpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBUZXh0IEZpZWxkIEljb24uXG4gKlxuICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIGFkYXB0ZXIgZXhwZWN0ZWQgYnkgdGhlIGZvdW5kYXRpb24uIEltcGxlbWVudCB0aGlzXG4gKiBhZGFwdGVyIHRvIGludGVncmF0ZSB0aGUgdGV4dCBmaWVsZCBpY29uIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENUZXh0RmllbGRJY29uQWRhcHRlciB7XG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUgb24gdGhlIGljb24gZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0QXR0cihhdHRyKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIGFuIGF0dHJpYnV0ZSBvbiB0aGUgaWNvbiBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICovXG4gIHNldEF0dHIoYXR0ciwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gYXR0cmlidXRlIGZyb20gdGhlIGljb24gZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICovXG4gIHJlbW92ZUF0dHIoYXR0cikge31cblxuICAvKipcbiAgICogU2V0cyB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBpY29uIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gICAqL1xuICBzZXRDb250ZW50KGNvbnRlbnQpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiB0aGUgaWNvbiBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIGljb24gZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRW1pdHMgYSBjdXN0b20gZXZlbnQgXCJNRENUZXh0RmllbGQ6aWNvblwiIGRlbm90aW5nIGEgdXNlciBoYXMgY2xpY2tlZCB0aGUgaWNvbi5cbiAgICovXG4gIG5vdGlmeUljb25BY3Rpb24oKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUZXh0RmllbGRJY29uQWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIElDT05fRVZFTlQ6ICdNRENUZXh0RmllbGQ6aWNvbicsXG4gIElDT05fUk9MRTogJ2J1dHRvbicsXG59O1xuXG5leHBvcnQge3N0cmluZ3N9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ1RleHRGaWVsZEljb25BZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge3N0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENUZXh0RmllbGRJY29uQWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgTURDVGV4dEZpZWxkSWNvbkFkYXB0ZXJ9IGZvciB0eXBpbmcgaW5mb3JtYXRpb24gb24gcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAqIHR5cGVzLlxuICAgKiBAcmV0dXJuIHshTURDVGV4dEZpZWxkSWNvbkFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUZXh0RmllbGRJY29uQWRhcHRlcn0gKi8gKHtcbiAgICAgIGdldEF0dHI6ICgpID0+IHt9LFxuICAgICAgc2V0QXR0cjogKCkgPT4ge30sXG4gICAgICByZW1vdmVBdHRyOiAoKSA9PiB7fSxcbiAgICAgIHNldENvbnRlbnQ6ICgpID0+IHt9LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBub3RpZnlJY29uQWN0aW9uOiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENUZXh0RmllbGRJY29uQWRhcHRlcn0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7c3RyaW5nP30gKi9cbiAgICB0aGlzLnNhdmVkVGFiSW5kZXhfID0gbnVsbDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlSW50ZXJhY3Rpb24oZXZ0KTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5zYXZlZFRhYkluZGV4XyA9IHRoaXMuYWRhcHRlcl8uZ2V0QXR0cigndGFiaW5kZXgnKTtcblxuICAgIFsnY2xpY2snLCAna2V5ZG93biddLmZvckVhY2goKGV2dFR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXJfKTtcbiAgICB9KTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgWydjbGljaycsICdrZXlkb3duJ10uZm9yRWFjaCgoZXZ0VHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyXyk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZCAqL1xuICBzZXREaXNhYmxlZChkaXNhYmxlZCkge1xuICAgIGlmICghdGhpcy5zYXZlZFRhYkluZGV4Xykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVBdHRyKCdyb2xlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cigndGFiaW5kZXgnLCB0aGlzLnNhdmVkVGFiSW5kZXhfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cigncm9sZScsIHN0cmluZ3MuSUNPTl9ST0xFKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGxhYmVsICovXG4gIHNldEFyaWFMYWJlbChsYWJlbCkge1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cignYXJpYS1sYWJlbCcsIGxhYmVsKTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCAqL1xuICBzZXRDb250ZW50KGNvbnRlbnQpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldENvbnRlbnQoY29udGVudCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhbiBpbnRlcmFjdGlvbiBldmVudFxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqL1xuICBoYW5kbGVJbnRlcmFjdGlvbihldnQpIHtcbiAgICBpZiAoZXZ0LnR5cGUgPT09ICdjbGljaycgfHwgZXZ0LmtleSA9PT0gJ0VudGVyJyB8fCBldnQua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5SWNvbkFjdGlvbigpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUZXh0RmllbGRJY29uRm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IE1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9uIGZyb20gJy4vaGVscGVyLXRleHQvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb24gZnJvbSAnLi9pY29uL2ZvdW5kYXRpb24nO1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICB2YWx1ZTogc3RyaW5nLFxuICogICBkaXNhYmxlZDogYm9vbGVhbixcbiAqICAgYmFkSW5wdXQ6IGJvb2xlYW4sXG4gKiAgIHZhbGlkaXR5OiB7XG4gKiAgICAgYmFkSW5wdXQ6IGJvb2xlYW4sXG4gKiAgICAgdmFsaWQ6IGJvb2xlYW4sXG4gKiAgIH0sXG4gKiB9fVxuICovXG5sZXQgTmF0aXZlSW5wdXRUeXBlO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGhlbHBlclRleHQ6ICghTURDVGV4dEZpZWxkSGVscGVyVGV4dEZvdW5kYXRpb258dW5kZWZpbmVkKSxcbiAqICAgaWNvbjogKCFNRENUZXh0RmllbGRJY29uRm91bmRhdGlvbnx1bmRlZmluZWQpLFxuICogfX1cbiAqL1xubGV0IEZvdW5kYXRpb25NYXBUeXBlO1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBUZXh0IEZpZWxkLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIFRleHQgRmllbGQgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1RleHRGaWVsZEFkYXB0ZXIge1xuICAvKipcbiAgICogQWRkcyBhIGNsYXNzIHRvIHRoZSByb290IEVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNsYXNzIGZyb20gdGhlIHJvb3QgRWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJvb3QgZWxlbWVudCBjb250YWlucyB0aGUgZ2l2ZW4gY2xhc3MgbmFtZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgcm9vdCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJUZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgcm9vdCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlclRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIG5hdGl2ZSBpbnB1dCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiB0aGUgbmF0aXZlIGlucHV0IGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgdmFsaWRhdGlvbiBhdHRyaWJ1dGUgY2hhbmdlIGxpc3RlbmVyIG9uIHRoZSBpbnB1dCBlbGVtZW50LlxuICAgKiBIYW5kbGVyIGFjY2VwdHMgbGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUFycmF5PHN0cmluZz4pOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICogQHJldHVybiB7IU11dGF0aW9uT2JzZXJ2ZXJ9XG4gICAqL1xuICByZWdpc3RlclZhbGlkYXRpb25BdHRyaWJ1dGVDaGFuZ2VIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERpc2Nvbm5lY3RzIGEgdmFsaWRhdGlvbiBhdHRyaWJ1dGUgb2JzZXJ2ZXIgb24gdGhlIGlucHV0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7IU11dGF0aW9uT2JzZXJ2ZXJ9IG9ic2VydmVyXG4gICAqL1xuICBkZXJlZ2lzdGVyVmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXIob2JzZXJ2ZXIpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgbmF0aXZlIHRleHQgaW5wdXQgZWxlbWVudCwgd2l0aCBhXG4gICAqIHNpbWlsYXIgQVBJIHNoYXBlLiBUaGUgb2JqZWN0IHJldHVybmVkIHNob3VsZCBpbmNsdWRlIHRoZSB2YWx1ZSwgZGlzYWJsZWRcbiAgICogYW5kIGJhZElucHV0IHByb3BlcnRpZXMsIGFzIHdlbGwgYXMgdGhlIGNoZWNrVmFsaWRpdHkoKSBmdW5jdGlvbi4gV2UgbmV2ZXJcbiAgICogYWx0ZXIgdGhlIHZhbHVlIHdpdGhpbiBvdXIgY29kZSwgaG93ZXZlciB3ZSBkbyB1cGRhdGUgdGhlIGRpc2FibGVkXG4gICAqIHByb3BlcnR5LCBzbyBpZiB5b3UgY2hvb3NlIHRvIGR1Y2stdHlwZSB0aGUgcmV0dXJuIHZhbHVlIGZvciB0aGlzIG1ldGhvZFxuICAgKiBpbiB5b3VyIGltcGxlbWVudGF0aW9uIGl0J3MgaW1wb3J0YW50IHRvIGtlZXAgdGhpcyBpbiBtaW5kLiBBbHNvIG5vdGUgdGhhdFxuICAgKiB0aGlzIG1ldGhvZCBjYW4gcmV0dXJuIG51bGwsIHdoaWNoIHRoZSBmb3VuZGF0aW9uIHdpbGwgaGFuZGxlIGdyYWNlZnVsbHkuXG4gICAqIEByZXR1cm4gez9FbGVtZW50fD9OYXRpdmVJbnB1dFR5cGV9XG4gICAqL1xuICBnZXROYXRpdmVJbnB1dCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGV4dGZpZWxkIGlzIGZvY3VzZWQuXG4gICAqIFdlIGFjaGlldmUgdGhpcyB2aWEgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMucm9vdF9gLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNGb2N1c2VkKCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHJvb3QgZWxlbWVudCBpcyBzZXQgdG8gUlRMLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNSdGwoKSB7fVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgdGhlIGxpbmUgcmlwcGxlLlxuICAgKi9cbiAgYWN0aXZhdGVMaW5lUmlwcGxlKCkge31cblxuICAvKipcbiAgICogRGVhY3RpdmF0ZXMgdGhlIGxpbmUgcmlwcGxlLlxuICAgKi9cbiAgZGVhY3RpdmF0ZUxpbmVSaXBwbGUoKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0cmFuc2Zvcm0gb3JpZ2luIG9mIHRoZSBsaW5lIHJpcHBsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG5vcm1hbGl6ZWRYXG4gICAqL1xuICBzZXRMaW5lUmlwcGxlVHJhbnNmb3JtT3JpZ2luKG5vcm1hbGl6ZWRYKSB7fVxuXG4gIC8qKlxuICAgKiBPbmx5IGltcGxlbWVudCBpZiBsYWJlbCBleGlzdHMuXG4gICAqIFNoYWtlcyBsYWJlbCBpZiBzaG91bGRTaGFrZSBpcyB0cnVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZFNoYWtlXG4gICAqL1xuICBzaGFrZUxhYmVsKHNob3VsZFNoYWtlKSB7fVxuXG4gIC8qKlxuICAgKiBPbmx5IGltcGxlbWVudCBpZiBsYWJlbCBleGlzdHMuXG4gICAqIEZsb2F0cyB0aGUgbGFiZWwgYWJvdmUgdGhlIGlucHV0IGVsZW1lbnQgaWYgc2hvdWxkRmxvYXQgaXMgdHJ1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRGbG9hdFxuICAgKi9cbiAgZmxvYXRMYWJlbChzaG91bGRGbG9hdCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGxhYmVsIGVsZW1lbnQgZXhpc3RzLCBmYWxzZSBpZiBpdCBkb2Vzbid0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzTGFiZWwoKSB7fVxuXG4gIC8qKlxuICAgKiBPbmx5IGltcGxlbWVudCBpZiBsYWJlbCBleGlzdHMuXG4gICAqIFJldHVybnMgd2lkdGggb2YgbGFiZWwgaW4gcGl4ZWxzLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMYWJlbFdpZHRoKCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIG91dGxpbmUgZWxlbWVudCBleGlzdHMsIGZhbHNlIGlmIGl0IGRvZXNuJ3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNPdXRsaW5lKCkge31cblxuICAvKipcbiAgICogT25seSBpbXBsZW1lbnQgaWYgb3V0bGluZSBlbGVtZW50IGV4aXN0cy5cbiAgICogVXBkYXRlcyBTVkcgUGF0aCBhbmQgb3V0bGluZSBlbGVtZW50IGJhc2VkIG9uIHRoZVxuICAgKiBsYWJlbCBlbGVtZW50IHdpZHRoIGFuZCBSVEwgY29udGV4dC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxhYmVsV2lkdGhcbiAgICogQHBhcmFtIHtib29sZWFuPX0gaXNSdGxcbiAgICovXG4gIG5vdGNoT3V0bGluZShsYWJlbFdpZHRoLCBpc1J0bCkge31cblxuICAvKipcbiAgICogT25seSBpbXBsZW1lbnQgaWYgb3V0bGluZSBlbGVtZW50IGV4aXN0cy5cbiAgICogQ2xvc2VzIG5vdGNoIGluIG91dGxpbmUgZWxlbWVudC5cbiAgICovXG4gIGNsb3NlT3V0bGluZSgpIHt9XG59XG5cbmV4cG9ydCB7TURDVGV4dEZpZWxkQWRhcHRlciwgTmF0aXZlSW5wdXRUeXBlLCBGb3VuZGF0aW9uTWFwVHlwZX07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBBUklBX0NPTlRST0xTOiAnYXJpYS1jb250cm9scycsXG4gIElOUFVUX1NFTEVDVE9SOiAnLm1kYy10ZXh0LWZpZWxkX19pbnB1dCcsXG4gIExBQkVMX1NFTEVDVE9SOiAnLm1kYy1mbG9hdGluZy1sYWJlbCcsXG4gIElDT05fU0VMRUNUT1I6ICcubWRjLXRleHQtZmllbGRfX2ljb24nLFxuICBPVVRMSU5FX1NFTEVDVE9SOiAnLm1kYy1ub3RjaGVkLW91dGxpbmUnLFxuICBMSU5FX1JJUFBMRV9TRUxFQ1RPUjogJy5tZGMtbGluZS1yaXBwbGUnLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBST09UOiAnbWRjLXRleHQtZmllbGQnLFxuICBVUEdSQURFRDogJ21kYy10ZXh0LWZpZWxkLS11cGdyYWRlZCcsXG4gIERJU0FCTEVEOiAnbWRjLXRleHQtZmllbGQtLWRpc2FibGVkJyxcbiAgREVOU0U6ICdtZGMtdGV4dC1maWVsZC0tZGVuc2UnLFxuICBGT0NVU0VEOiAnbWRjLXRleHQtZmllbGQtLWZvY3VzZWQnLFxuICBJTlZBTElEOiAnbWRjLXRleHQtZmllbGQtLWludmFsaWQnLFxuICBCT1g6ICdtZGMtdGV4dC1maWVsZC0tYm94JyxcbiAgT1VUTElORUQ6ICdtZGMtdGV4dC1maWVsZC0tb3V0bGluZWQnLFxufTtcblxuLyoqIEBlbnVtIHtudW1iZXJ9ICovXG5jb25zdCBudW1iZXJzID0ge1xuICBMQUJFTF9TQ0FMRTogMC43NSxcbiAgREVOU0VfTEFCRUxfU0NBTEU6IDAuOTIzLFxufTtcblxuLy8gd2hpdGVsaXN0IGJhc2VkIG9mZiBvZiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9HdWlkZS9IVE1ML0hUTUw1L0NvbnN0cmFpbnRfdmFsaWRhdGlvblxuLy8gdW5kZXIgc2VjdGlvbjogYFZhbGlkYXRpb24tcmVsYXRlZCBhdHRyaWJ1dGVzYFxuY29uc3QgVkFMSURBVElPTl9BVFRSX1dISVRFTElTVCA9IFtcbiAgJ3BhdHRlcm4nLCAnbWluJywgJ21heCcsICdyZXF1aXJlZCcsICdzdGVwJywgJ21pbmxlbmd0aCcsICdtYXhsZW5ndGgnLFxuXTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzLCBWQUxJREFUSU9OX0FUVFJfV0hJVEVMSVNUfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQgTURDVGV4dEZpZWxkSGVscGVyVGV4dEZvdW5kYXRpb24gZnJvbSAnLi9oZWxwZXItdGV4dC9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENUZXh0RmllbGRJY29uRm91bmRhdGlvbiBmcm9tICcuL2ljb24vZm91bmRhdGlvbic7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1RleHRGaWVsZEFkYXB0ZXIsIE5hdGl2ZUlucHV0VHlwZSwgRm91bmRhdGlvbk1hcFR5cGV9IGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnMsIFZBTElEQVRJT05fQVRUUl9XSElURUxJU1R9IGZyb20gJy4vY29uc3RhbnRzJztcblxuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENUZXh0RmllbGRBZGFwdGVyPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENUZXh0RmllbGRGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICByZXR1cm4gbnVtYmVycztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBnZXQgc2hvdWxkU2hha2UoKSB7XG4gICAgcmV0dXJuICF0aGlzLmlzVmFsaWQoKSAmJiAhdGhpcy5pc0ZvY3VzZWRfO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGdldCBzaG91bGRGbG9hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0ZvY3VzZWRfIHx8ICEhdGhpcy5nZXRWYWx1ZSgpIHx8IHRoaXMuaXNCYWRJbnB1dF8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBNRENUZXh0RmllbGRBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ1RleHRGaWVsZEFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUZXh0RmllbGRBZGFwdGVyfSAqLyAoe1xuICAgICAgYWRkQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgaGFzQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVnaXN0ZXJUZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICByZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICByZWdpc3RlclZhbGlkYXRpb25BdHRyaWJ1dGVDaGFuZ2VIYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJWYWxpZGF0aW9uQXR0cmlidXRlQ2hhbmdlSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBnZXROYXRpdmVJbnB1dDogKCkgPT4ge30sXG4gICAgICBpc0ZvY3VzZWQ6ICgpID0+IHt9LFxuICAgICAgaXNSdGw6ICgpID0+IHt9LFxuICAgICAgYWN0aXZhdGVMaW5lUmlwcGxlOiAoKSA9PiB7fSxcbiAgICAgIGRlYWN0aXZhdGVMaW5lUmlwcGxlOiAoKSA9PiB7fSxcbiAgICAgIHNldExpbmVSaXBwbGVUcmFuc2Zvcm1PcmlnaW46ICgpID0+IHt9LFxuICAgICAgc2hha2VMYWJlbDogKCkgPT4ge30sXG4gICAgICBmbG9hdExhYmVsOiAoKSA9PiB7fSxcbiAgICAgIGhhc0xhYmVsOiAoKSA9PiB7fSxcbiAgICAgIGdldExhYmVsV2lkdGg6ICgpID0+IHt9LFxuICAgICAgaGFzT3V0bGluZTogKCkgPT4ge30sXG4gICAgICBub3RjaE91dGxpbmU6ICgpID0+IHt9LFxuICAgICAgY2xvc2VPdXRsaW5lOiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENUZXh0RmllbGRBZGFwdGVyfSBhZGFwdGVyXG4gICAqIEBwYXJhbSB7IUZvdW5kYXRpb25NYXBUeXBlPX0gZm91bmRhdGlvbk1hcCBNYXAgZnJvbSBzdWJjb21wb25lbnQgbmFtZXMgdG8gdGhlaXIgc3ViZm91bmRhdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyLCBmb3VuZGF0aW9uTWFwID0gLyoqIEB0eXBlIHshRm91bmRhdGlvbk1hcFR5cGV9ICovICh7fSkpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1RleHRGaWVsZEZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAdHlwZSB7IU1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9ufHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLmhlbHBlclRleHRfID0gZm91bmRhdGlvbk1hcC5oZWxwZXJUZXh0O1xuICAgIC8qKiBAdHlwZSB7IU1EQ1RleHRGaWVsZEljb25Gb3VuZGF0aW9ufHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLmljb25fID0gZm91bmRhdGlvbk1hcC5pY29uO1xuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMuaXNGb2N1c2VkXyA9IGZhbHNlO1xuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLnJlY2VpdmVkVXNlcklucHV0XyA9IGZhbHNlO1xuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLnVzZUN1c3RvbVZhbGlkaXR5Q2hlY2tpbmdfID0gZmFsc2U7XG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMuaXNWYWxpZF8gPSB0cnVlO1xuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oKTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMuaW5wdXRGb2N1c0hhbmRsZXJfID0gKCkgPT4gdGhpcy5hY3RpdmF0ZUZvY3VzKCk7XG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbigpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy5pbnB1dEJsdXJIYW5kbGVyXyA9ICgpID0+IHRoaXMuZGVhY3RpdmF0ZUZvY3VzKCk7XG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbigpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy5pbnB1dElucHV0SGFuZGxlcl8gPSAoKSA9PiB0aGlzLmF1dG9Db21wbGV0ZUZvY3VzKCk7XG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy5zZXRQb2ludGVyWE9mZnNldF8gPSAoZXZ0KSA9PiB0aGlzLnNldFRyYW5zZm9ybU9yaWdpbihldnQpO1xuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMudGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyXyA9ICgpID0+IHRoaXMuaGFuZGxlVGV4dEZpZWxkSW50ZXJhY3Rpb24oKTtcbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFBcnJheSk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLnZhbGlkYXRpb25BdHRyaWJ1dGVDaGFuZ2VIYW5kbGVyXyA9IChhdHRyaWJ1dGVzTGlzdCkgPT4gdGhpcy5oYW5kbGVWYWxpZGF0aW9uQXR0cmlidXRlQ2hhbmdlKGF0dHJpYnV0ZXNMaXN0KTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IU11dGF0aW9uT2JzZXJ2ZXJ9ICovXG4gICAgdGhpcy52YWxpZGF0aW9uT2JzZXJ2ZXJfO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ1RleHRGaWVsZEZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5VUEdSQURFRCk7XG4gICAgLy8gRW5zdXJlIGxhYmVsIGRvZXMgbm90IGNvbGxpZGUgd2l0aCBhbnkgcHJlLWZpbGxlZCB2YWx1ZS5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5oYXNMYWJlbCgpICYmICh0aGlzLmdldFZhbHVlKCkgfHwgdGhpcy5pc0JhZElucHV0XygpKSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5mbG9hdExhYmVsKHRoaXMuc2hvdWxkRmxvYXQpO1xuICAgICAgdGhpcy5ub3RjaE91dGxpbmUodGhpcy5zaG91bGRGbG9hdCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNGb2N1c2VkKCkpIHtcbiAgICAgIHRoaXMuaW5wdXRGb2N1c0hhbmRsZXJfKCk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyKCdmb2N1cycsIHRoaXMuaW5wdXRGb2N1c0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoJ2JsdXInLCB0aGlzLmlucHV0Qmx1ckhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoJ2lucHV0JywgdGhpcy5pbnB1dElucHV0SGFuZGxlcl8pO1xuICAgIFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnXS5mb3JFYWNoKChldnRUeXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgdGhpcy5zZXRQb2ludGVyWE9mZnNldF8pO1xuICAgIH0pO1xuICAgIFsnY2xpY2snLCAna2V5ZG93biddLmZvckVhY2goKGV2dFR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJUZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgdGhpcy50ZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXJfKTtcbiAgICB9KTtcbiAgICB0aGlzLnZhbGlkYXRpb25PYnNlcnZlcl8gPVxuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyVmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXIodGhpcy52YWxpZGF0aW9uQXR0cmlidXRlQ2hhbmdlSGFuZGxlcl8pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ1RleHRGaWVsZEZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5VUEdSQURFRCk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoJ2ZvY3VzJywgdGhpcy5pbnB1dEZvY3VzSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyKCdibHVyJywgdGhpcy5pbnB1dEJsdXJIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoJ2lucHV0JywgdGhpcy5pbnB1dElucHV0SGFuZGxlcl8pO1xuICAgIFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnXS5mb3JFYWNoKChldnRUeXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCB0aGlzLnNldFBvaW50ZXJYT2Zmc2V0Xyk7XG4gICAgfSk7XG4gICAgWydjbGljaycsICdrZXlkb3duJ10uZm9yRWFjaCgoZXZ0VHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyVGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMudGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyXyk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyVmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXIodGhpcy52YWxpZGF0aW9uT2JzZXJ2ZXJfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHVzZXIgaW50ZXJhY3Rpb25zIHdpdGggdGhlIFRleHQgRmllbGQuXG4gICAqL1xuICBoYW5kbGVUZXh0RmllbGRJbnRlcmFjdGlvbigpIHtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5nZXROYXRpdmVJbnB1dCgpLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVjZWl2ZWRVc2VySW5wdXRfID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHZhbGlkYXRpb24gYXR0cmlidXRlIGNoYW5nZXNcbiAgICogQHBhcmFtIHshQXJyYXk8c3RyaW5nPn0gYXR0cmlidXRlc0xpc3RcbiAgICovXG4gIGhhbmRsZVZhbGlkYXRpb25BdHRyaWJ1dGVDaGFuZ2UoYXR0cmlidXRlc0xpc3QpIHtcbiAgICBhdHRyaWJ1dGVzTGlzdC5zb21lKChhdHRyaWJ1dGVOYW1lKSA9PiB7XG4gICAgICBpZiAoVkFMSURBVElPTl9BVFRSX1dISVRFTElTVC5pbmRleE9mKGF0dHJpYnV0ZU5hbWUpID4gLTEpIHtcbiAgICAgICAgdGhpcy5zdHlsZVZhbGlkaXR5Xyh0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogT3BlbnMvY2xvc2VzIHRoZSBub3RjaGVkIG91dGxpbmUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3Blbk5vdGNoXG4gICAqL1xuICBub3RjaE91dGxpbmUob3Blbk5vdGNoKSB7XG4gICAgaWYgKCF0aGlzLmFkYXB0ZXJfLmhhc091dGxpbmUoKSB8fCAhdGhpcy5hZGFwdGVyXy5oYXNMYWJlbCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9wZW5Ob3RjaCkge1xuICAgICAgY29uc3QgaXNEZW5zZSA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5ERU5TRSk7XG4gICAgICBjb25zdCBsYWJlbFNjYWxlID0gaXNEZW5zZSA/IG51bWJlcnMuREVOU0VfTEFCRUxfU0NBTEUgOiBudW1iZXJzLkxBQkVMX1NDQUxFO1xuICAgICAgY29uc3QgbGFiZWxXaWR0aCA9IHRoaXMuYWRhcHRlcl8uZ2V0TGFiZWxXaWR0aCgpICogbGFiZWxTY2FsZTtcbiAgICAgIGNvbnN0IGlzUnRsID0gdGhpcy5hZGFwdGVyXy5pc1J0bCgpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RjaE91dGxpbmUobGFiZWxXaWR0aCwgaXNSdGwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmNsb3NlT3V0bGluZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgdGhlIHRleHQgZmllbGQgZm9jdXMgc3RhdGUuXG4gICAqL1xuICBhY3RpdmF0ZUZvY3VzKCkge1xuICAgIHRoaXMuaXNGb2N1c2VkXyA9IHRydWU7XG4gICAgdGhpcy5zdHlsZUZvY3VzZWRfKHRoaXMuaXNGb2N1c2VkXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5hY3RpdmF0ZUxpbmVSaXBwbGUoKTtcbiAgICB0aGlzLm5vdGNoT3V0bGluZSh0aGlzLnNob3VsZEZsb2F0KTtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5oYXNMYWJlbCgpKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNoYWtlTGFiZWwodGhpcy5zaG91bGRTaGFrZSk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmZsb2F0TGFiZWwodGhpcy5zaG91bGRGbG9hdCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmhlbHBlclRleHRfKSB7XG4gICAgICB0aGlzLmhlbHBlclRleHRfLnNob3dUb1NjcmVlblJlYWRlcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsaW5lIHJpcHBsZSdzIHRyYW5zZm9ybSBvcmlnaW4sIHNvIHRoYXQgdGhlIGxpbmUgcmlwcGxlIGFjdGl2YXRlXG4gICAqIGFuaW1hdGlvbiB3aWxsIGFuaW1hdGUgb3V0IGZyb20gdGhlIHVzZXIncyBjbGljayBsb2NhdGlvbi5cbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKi9cbiAgc2V0VHJhbnNmb3JtT3JpZ2luKGV2dCkge1xuICAgIGNvbnN0IHRhcmdldENsaWVudFJlY3QgPSBldnQudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGV2dENvb3JkcyA9IHt4OiBldnQuY2xpZW50WCwgeTogZXZ0LmNsaWVudFl9O1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRYID0gZXZ0Q29vcmRzLnggLSB0YXJnZXRDbGllbnRSZWN0LmxlZnQ7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRMaW5lUmlwcGxlVHJhbnNmb3JtT3JpZ2luKG5vcm1hbGl6ZWRYKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgdGhlIFRleHQgRmllbGQncyBmb2N1cyBzdGF0ZSBpbiBjYXNlcyB3aGVuIHRoZSBpbnB1dCB2YWx1ZVxuICAgKiBjaGFuZ2VzIHdpdGhvdXQgdXNlciBpbnB1dCAoZS5nLiBwcm9ncmFtYXRpY2FsbHkpLlxuICAgKi9cbiAgYXV0b0NvbXBsZXRlRm9jdXMoKSB7XG4gICAgaWYgKCF0aGlzLnJlY2VpdmVkVXNlcklucHV0Xykge1xuICAgICAgdGhpcy5hY3RpdmF0ZUZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlYWN0aXZhdGVzIHRoZSBUZXh0IEZpZWxkJ3MgZm9jdXMgc3RhdGUuXG4gICAqL1xuICBkZWFjdGl2YXRlRm9jdXMoKSB7XG4gICAgdGhpcy5pc0ZvY3VzZWRfID0gZmFsc2U7XG4gICAgdGhpcy5hZGFwdGVyXy5kZWFjdGl2YXRlTGluZVJpcHBsZSgpO1xuICAgIGNvbnN0IGlucHV0ID0gdGhpcy5nZXROYXRpdmVJbnB1dF8oKTtcbiAgICBjb25zdCBzaG91bGRSZW1vdmVMYWJlbEZsb2F0ID0gIWlucHV0LnZhbHVlICYmICF0aGlzLmlzQmFkSW5wdXRfKCk7XG4gICAgY29uc3QgaXNWYWxpZCA9IHRoaXMuaXNWYWxpZCgpO1xuICAgIHRoaXMuc3R5bGVWYWxpZGl0eV8oaXNWYWxpZCk7XG4gICAgdGhpcy5zdHlsZUZvY3VzZWRfKHRoaXMuaXNGb2N1c2VkXyk7XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaGFzTGFiZWwoKSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zaGFrZUxhYmVsKHRoaXMuc2hvdWxkU2hha2UpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5mbG9hdExhYmVsKHRoaXMuc2hvdWxkRmxvYXQpO1xuICAgICAgdGhpcy5ub3RjaE91dGxpbmUodGhpcy5zaG91bGRGbG9hdCk7XG4gICAgfVxuICAgIGlmIChzaG91bGRSZW1vdmVMYWJlbEZsb2F0KSB7XG4gICAgICB0aGlzLnJlY2VpdmVkVXNlcklucHV0XyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQgRWxlbWVudC5cbiAgICovXG4gIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZUlucHV0XygpLnZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0IG9uIHRoZSBpbnB1dCBFbGVtZW50LlxuICAgKi9cbiAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLmdldE5hdGl2ZUlucHV0XygpLnZhbHVlID0gdmFsdWU7XG4gICAgY29uc3QgaXNWYWxpZCA9IHRoaXMuaXNWYWxpZCgpO1xuICAgIHRoaXMuc3R5bGVWYWxpZGl0eV8oaXNWYWxpZCk7XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaGFzTGFiZWwoKSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zaGFrZUxhYmVsKHRoaXMuc2hvdWxkU2hha2UpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5mbG9hdExhYmVsKHRoaXMuc2hvdWxkRmxvYXQpO1xuICAgICAgdGhpcy5ub3RjaE91dGxpbmUodGhpcy5zaG91bGRGbG9hdCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IElmIGEgY3VzdG9tIHZhbGlkaXR5IGlzIHNldCwgcmV0dXJucyB0aGF0IHZhbHVlLlxuICAgKiAgICAgT3RoZXJ3aXNlLCByZXR1cm5zIHRoZSByZXN1bHQgb2YgbmF0aXZlIHZhbGlkaXR5IGNoZWNrcy5cbiAgICovXG4gIGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudXNlQ3VzdG9tVmFsaWRpdHlDaGVja2luZ19cbiAgICAgID8gdGhpcy5pc1ZhbGlkXyA6IHRoaXMuaXNOYXRpdmVJbnB1dFZhbGlkXygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNWYWxpZCBTZXRzIHRoZSB2YWxpZGl0eSBzdGF0ZSBvZiB0aGUgVGV4dCBGaWVsZC5cbiAgICovXG4gIHNldFZhbGlkKGlzVmFsaWQpIHtcbiAgICB0aGlzLnVzZUN1c3RvbVZhbGlkaXR5Q2hlY2tpbmdfID0gdHJ1ZTtcbiAgICB0aGlzLmlzVmFsaWRfID0gaXNWYWxpZDtcbiAgICAvLyBSZXRyaWV2ZSBmcm9tIHRoZSBnZXR0ZXIgdG8gZW5zdXJlIGNvcnJlY3QgbG9naWMgaXMgYXBwbGllZC5cbiAgICBpc1ZhbGlkID0gdGhpcy5pc1ZhbGlkKCk7XG4gICAgdGhpcy5zdHlsZVZhbGlkaXR5Xyhpc1ZhbGlkKTtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5oYXNMYWJlbCgpKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNoYWtlTGFiZWwodGhpcy5zaG91bGRTaGFrZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIFRleHQgRmllbGQgaXMgZGlzYWJsZWQuXG4gICAqL1xuICBpc0Rpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmdldE5hdGl2ZUlucHV0XygpLmRpc2FibGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWQgU2V0cyB0aGUgdGV4dC1maWVsZCBkaXNhYmxlZCBvciBlbmFibGVkLlxuICAgKi9cbiAgc2V0RGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICB0aGlzLmdldE5hdGl2ZUlucHV0XygpLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgdGhpcy5zdHlsZURpc2FibGVkXyhkaXNhYmxlZCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgU2V0cyB0aGUgY29udGVudCBvZiB0aGUgaGVscGVyIHRleHQuXG4gICAqL1xuICBzZXRIZWxwZXJUZXh0Q29udGVudChjb250ZW50KSB7XG4gICAgaWYgKHRoaXMuaGVscGVyVGV4dF8pIHtcbiAgICAgIHRoaXMuaGVscGVyVGV4dF8uc2V0Q29udGVudChjb250ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgYXJpYSBsYWJlbCBvZiB0aGUgaWNvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsXG4gICAqL1xuICBzZXRJY29uQXJpYUxhYmVsKGxhYmVsKSB7XG4gICAgaWYgKHRoaXMuaWNvbl8pIHtcbiAgICAgIHRoaXMuaWNvbl8uc2V0QXJpYUxhYmVsKGxhYmVsKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBpY29uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICAgKi9cbiAgc2V0SWNvbkNvbnRlbnQoY29udGVudCkge1xuICAgIGlmICh0aGlzLmljb25fKSB7XG4gICAgICB0aGlzLmljb25fLnNldENvbnRlbnQoY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIFRleHQgRmllbGQgaW5wdXQgZmFpbHMgaW4gY29udmVydGluZyB0aGVcbiAgICogICAgIHVzZXItc3VwcGxpZWQgdmFsdWUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc0JhZElucHV0XygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVJbnB1dF8oKS52YWxpZGl0eS5iYWRJbnB1dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgcmVzdWx0IG9mIG5hdGl2ZSB2YWxpZGl0eSBjaGVja2luZ1xuICAgKiAgICAgKFZhbGlkaXR5U3RhdGUudmFsaWQpLlxuICAgKi9cbiAgaXNOYXRpdmVJbnB1dFZhbGlkXygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVJbnB1dF8oKS52YWxpZGl0eS52YWxpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdHlsZXMgdGhlIGNvbXBvbmVudCBiYXNlZCBvbiB0aGUgdmFsaWRpdHkgc3RhdGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNWYWxpZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3R5bGVWYWxpZGl0eV8oaXNWYWxpZCkge1xuICAgIGNvbnN0IHtJTlZBTElEfSA9IE1EQ1RleHRGaWVsZEZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhJTlZBTElEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhJTlZBTElEKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGVscGVyVGV4dF8pIHtcbiAgICAgIHRoaXMuaGVscGVyVGV4dF8uc2V0VmFsaWRpdHkoaXNWYWxpZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0eWxlcyB0aGUgY29tcG9uZW50IGJhc2VkIG9uIHRoZSBmb2N1c2VkIHN0YXRlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRm9jdXNlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3R5bGVGb2N1c2VkXyhpc0ZvY3VzZWQpIHtcbiAgICBjb25zdCB7Rk9DVVNFRH0gPSBNRENUZXh0RmllbGRGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgaWYgKGlzRm9jdXNlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhGT0NVU0VEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhGT0NVU0VEKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3R5bGVzIHRoZSBjb21wb25lbnQgYmFzZWQgb24gdGhlIGRpc2FibGVkIHN0YXRlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRGlzYWJsZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0eWxlRGlzYWJsZWRfKGlzRGlzYWJsZWQpIHtcbiAgICBjb25zdCB7RElTQUJMRUQsIElOVkFMSUR9ID0gTURDVGV4dEZpZWxkRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIGlmIChpc0Rpc2FibGVkKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKERJU0FCTEVEKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoSU5WQUxJRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoRElTQUJMRUQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pY29uXykge1xuICAgICAgdGhpcy5pY29uXy5zZXREaXNhYmxlZChpc0Rpc2FibGVkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IUVsZW1lbnR8IU5hdGl2ZUlucHV0VHlwZX0gVGhlIG5hdGl2ZSB0ZXh0IGlucHV0IGZyb20gdGhlXG4gICAqIGhvc3QgZW52aXJvbm1lbnQsIG9yIGEgZHVtbXkgaWYgbm9uZSBleGlzdHMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXROYXRpdmVJbnB1dF8oKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uZ2V0TmF0aXZlSW5wdXQoKSB8fFxuICAgIC8qKiBAdHlwZSB7IU5hdGl2ZUlucHV0VHlwZX0gKi8gKHtcbiAgICAgIHZhbHVlOiAnJyxcbiAgICAgIGRpc2FibGVkOiBmYWxzZSxcbiAgICAgIHZhbGlkaXR5OiB7XG4gICAgICAgIGJhZElucHV0OiBmYWxzZSxcbiAgICAgICAgdmFsaWQ6IHRydWUsXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1RleHRGaWVsZEZvdW5kYXRpb247XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXZcbiAgICA6c3R5bGU9XCJ7d2lkdGg6ZnVsbHdpZHRoPycxMDAlJzp1bmRlZmluZWR9XCJcbiAgICA6aWQ9XCJpZFwiXG4gICAgY2xhc3M9XCJtZGMtdGV4dGZpZWxkLXdyYXBwZXJcIj5cblxuICAgIDxkaXZcbiAgICAgIHJlZj1cInJvb3RcIlxuICAgICAgOmNsYXNzPVwicm9vdENsYXNzZXNcIj5cblxuICAgICAgPGlcbiAgICAgICAgdi1pZj1cIiEhaGFzTGVhZGluZ0ljb25cIlxuICAgICAgICByZWY9XCJpY29uXCJcbiAgICAgICAgOmNsYXNzPVwiaGFzTGVhZGluZ0ljb24uY2xhc3Nlc1wiXG4gICAgICAgIHRhYmluZGV4PVwiMFwiXG4gICAgICAgIGNsYXNzPVwibWRjLXRleHQtZmllbGRfX2ljb25cIj5cbiAgICAgICAgPHNsb3QgbmFtZT1cImxlYWRpbmctaWNvblwiPnt7IGhhc0xlYWRpbmdJY29uLmNvbnRlbnQgfX08L3Nsb3Q+XG4gICAgICA8L2k+XG5cbiAgICAgIDwhLS0gd29ya2Fycm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy9yb2xsdXAtcGx1Z2luLXZ1ZS9pc3N1ZXMvMTc0IC0tPlxuICAgICAgPCEtLSBlc2xpbnQtZGlzYWJsZSB2dWUvaHRtbC1zZWxmLWNsb3NpbmcgLS0+XG4gICAgICA8dGV4dGFyZWFcbiAgICAgICAgdi1pZj1cIm11bHRpbGluZVwiXG4gICAgICAgIHJlZj1cImlucHV0XCJcbiAgICAgICAgdi1iaW5kPVwiJGF0dHJzXCJcbiAgICAgICAgOmlkPVwidm1hX3VpZF9cIlxuICAgICAgICA6Y2xhc3M9XCJpbnB1dENsYXNzZXNcIlxuICAgICAgICA6bWlubGVuZ3RoPVwibWlubGVuZ3RoXCJcbiAgICAgICAgOm1heGxlbmd0aD1cIm1heGxlbmd0aFwiXG4gICAgICAgIDpwbGFjZWhvbGRlcj1cImlucHV0UGxhY2VIb2xkZXJcIlxuICAgICAgICA6YXJpYS1sYWJlbD1cImlucHV0UGxhY2VIb2xkZXJcIlxuICAgICAgICA6YXJpYS1jb250cm9scz1cImlucHV0QXJpYUNvbnRyb2xzXCJcbiAgICAgICAgOnJvd3M9XCJyb3dzXCJcbiAgICAgICAgOmNvbHM9XCJjb2xzXCJcbiAgICAgICAgdi1vbj1cIiRsaXN0ZW5lcnNcIlxuICAgICAgICBAaW5wdXQ9XCJ1cGRhdGVWYWx1ZSgkZXZlbnQudGFyZ2V0LnZhbHVlKVwiXG4gICAgICA+PC90ZXh0YXJlYT5cblxuICAgICAgPGlucHV0XG4gICAgICAgIHYtZWxzZVxuICAgICAgICByZWY9XCJpbnB1dFwiXG4gICAgICAgIHYtYmluZD1cIiRhdHRyc1wiXG4gICAgICAgIDppZD1cInZtYV91aWRfXCJcbiAgICAgICAgOmNsYXNzPVwiaW5wdXRDbGFzc2VzXCJcbiAgICAgICAgOnR5cGU9XCJ0eXBlXCJcbiAgICAgICAgOm1pbmxlbmd0aD1cIm1pbmxlbmd0aFwiXG4gICAgICAgIDptYXhsZW5ndGg9XCJtYXhsZW5ndGhcIlxuICAgICAgICA6cGxhY2Vob2xkZXI9XCJpbnB1dFBsYWNlSG9sZGVyXCJcbiAgICAgICAgOmFyaWEtbGFiZWw9XCJpbnB1dFBsYWNlSG9sZGVyXCJcbiAgICAgICAgOmFyaWEtY29udHJvbHM9XCJpbnB1dEFyaWFDb250cm9sc1wiXG4gICAgICAgIHYtb249XCIkbGlzdGVuZXJzXCJcbiAgICAgICAgQGlucHV0PVwidXBkYXRlVmFsdWUoJGV2ZW50LnRhcmdldC52YWx1ZSlcIlxuICAgICAgPlxuXG4gICAgICA8bGFiZWxcbiAgICAgICAgdi1pZj1cImhhc0xhYmVsXCJcbiAgICAgICAgcmVmPVwibGFiZWxcIlxuICAgICAgICA6Y2xhc3M9XCJsYWJlbENsYXNzZXNVcGdyYWRlZFwiXG4gICAgICAgIDpmb3I9XCJ2bWFfdWlkX1wiPlxuICAgICAgICB7eyBsYWJlbCB9fVxuICAgICAgPC9sYWJlbD5cblxuICAgICAgPGlcbiAgICAgICAgdi1pZj1cIiEhaGFzVHJhaWxpbmdJY29uXCJcbiAgICAgICAgcmVmPVwiaWNvblwiXG4gICAgICAgIDpjbGFzcz1cImhhc1RyYWlsaW5nSWNvbi5jbGFzc2VzXCJcbiAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgY2xhc3M9XCJtZGMtdGV4dC1maWVsZF9faWNvblwiPlxuICAgICAgICA8c2xvdCBuYW1lPVwidHJhaWxpbmctaWNvblwiPnt7IGhhc1RyYWlsaW5nSWNvbi5jb250ZW50IH19PC9zbG90PlxuICAgICAgPC9pPlxuXG4gICAgICA8ZGl2XG4gICAgICAgIHYtaWY9XCJoYXNPdXRsaW5lXCJcbiAgICAgICAgcmVmPVwib3V0bGluZVwiXG4gICAgICAgIDpjbGFzcz1cIm91dGxpbmVDbGFzc2VzXCJcbiAgICAgICAgY2xhc3M9XCJtZGMtbm90Y2hlZC1vdXRsaW5lXCI+XG4gICAgICAgIDxzdmc+XG4gICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgIDpkPVwib3V0bGluZVBhdGhBdHRyXCJcbiAgICAgICAgICAgIGNsYXNzPVwibWRjLW5vdGNoZWQtb3V0bGluZV9fcGF0aFwiIC8+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgPC9kaXY+XG4gICAgICA8ZGl2XG4gICAgICAgIHYtaWY9XCJoYXNPdXRsaW5lXCJcbiAgICAgICAgcmVmPVwib3V0bGluZUlkbGVcIlxuICAgICAgICBjbGFzcz1cIm1kYy1ub3RjaGVkLW91dGxpbmVfX2lkbGVcIi8+XG4gICAgICA8ZGl2XG4gICAgICAgIHYtaWY9XCJoYXNMaW5lUmlwcGxlXCJcbiAgICAgICAgcmVmPVwibGluZVJpcHBsZVwiXG4gICAgICAgIDpjbGFzcz1cImxpbmVSaXBwbGVDbGFzc2VzXCJcbiAgICAgICAgOnN0eWxlPVwibGluZVJpcHBsZVN0eWxlc1wiLz5cblxuICAgIDwvZGl2PlxuXG4gICAgPHBcbiAgICAgIHYtaWY9XCJoZWxwdGV4dFwiXG4gICAgICByZWY9XCJoZWxwXCJcbiAgICAgIDppZD1cIidoZWxwLScrdm1hX3VpZF9cIlxuICAgICAgOmNsYXNzPVwiaGVscENsYXNzZXNcIlxuICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCI+XG4gICAgICB7eyBoZWxwdGV4dCB9fVxuICAgIDwvcD5cblxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDVGV4dGZpZWxkRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvdGV4dGZpZWxkL2ZvdW5kYXRpb24nXG5pbXBvcnQgTURDTGluZVJpcHBsZUZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2xpbmUtcmlwcGxlL2ZvdW5kYXRpb24nXG5pbXBvcnQgTURDVGV4dEZpZWxkSGVscGVyVGV4dEZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3RleHRmaWVsZC9oZWxwZXItdGV4dC9mb3VuZGF0aW9uJ1xuaW1wb3J0IE1EQ1RleHRGaWVsZEljb25Gb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC90ZXh0ZmllbGQvaWNvbi9mb3VuZGF0aW9uJ1xuaW1wb3J0IE1EQ0Zsb2F0aW5nTGFiZWxGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9mbG9hdGluZy1sYWJlbC9mb3VuZGF0aW9uJ1xuaW1wb3J0IE1EQ05vdGNoZWRPdXRsaW5lRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvbm90Y2hlZC1vdXRsaW5lL2ZvdW5kYXRpb24nXG5cbmltcG9ydCB7XG4gIGV4dHJhY3RJY29uUHJvcCxcbiAgRGlzcGF0Y2hGb2N1c01peGluLFxuICBDdXN0b21FbGVtZW50TWl4aW4sXG4gIFZNQVVuaXF1ZUlkTWl4aW4sXG4gIGFwcGx5UGFzc2l2ZVxufSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IHsgUmlwcGxlQmFzZSB9IGZyb20gJy4uL3JpcHBsZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXRleHRmaWVsZCcsXG4gIG1peGluczogW0N1c3RvbUVsZW1lbnRNaXhpbiwgRGlzcGF0Y2hGb2N1c01peGluLCBWTUFVbmlxdWVJZE1peGluXSxcbiAgaW5oZXJpdEF0dHJzOiBmYWxzZSxcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAndmFsdWUnLFxuICAgIGV2ZW50OiAnbW9kZWwnXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgdmFsdWU6IFN0cmluZyxcbiAgICB0eXBlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAndGV4dCcsXG4gICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJ3RleHQnLFxuICAgICAgICAgICAgJ2VtYWlsJyxcbiAgICAgICAgICAgICdzZWFyY2gnLFxuICAgICAgICAgICAgJ3Bhc3N3b3JkJyxcbiAgICAgICAgICAgICd0ZWwnLFxuICAgICAgICAgICAgJ3VybCcsXG4gICAgICAgICAgICAnbnVtYmVyJ1xuICAgICAgICAgIF0uaW5kZXhPZih2YWx1ZSkgIT09IC0xXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlbnNlOiBCb29sZWFuLFxuICAgIGxhYmVsOiBTdHJpbmcsXG4gICAgaGVscHRleHQ6IFN0cmluZyxcbiAgICBoZWxwdGV4dFBlcnNpc3RlbnQ6IEJvb2xlYW4sXG4gICAgaGVscHRleHRWYWxpZGF0aW9uOiBCb29sZWFuLFxuICAgIGJveDogQm9vbGVhbixcbiAgICBvdXRsaW5lOiBCb29sZWFuLFxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgIHJlcXVpcmVkOiBCb29sZWFuLFxuICAgIHZhbGlkOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IHVuZGVmaW5lZCB9LFxuICAgIGZ1bGx3aWR0aDogQm9vbGVhbixcbiAgICBtdWx0aWxpbmU6IEJvb2xlYW4sXG4gICAgbGVhZGluZ0ljb246IFtTdHJpbmcsIEFycmF5LCBPYmplY3RdLFxuICAgIHRyYWlsaW5nSWNvbjogW1N0cmluZywgQXJyYXksIE9iamVjdF0sXG4gICAgc2l6ZTogeyB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLCBkZWZhdWx0OiAyMCB9LFxuICAgIG1pbmxlbmd0aDogeyB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLCBkZWZhdWx0OiB1bmRlZmluZWQgfSxcbiAgICBtYXhsZW5ndGg6IHsgdHlwZTogW051bWJlciwgU3RyaW5nXSwgZGVmYXVsdDogdW5kZWZpbmVkIH0sXG4gICAgcm93czogeyB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLCBkZWZhdWx0OiA4IH0sXG4gICAgY29sczogeyB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLCBkZWZhdWx0OiA0MCB9LFxuICAgIGlkOiB7IHR5cGU6IFN0cmluZyB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0OiB0aGlzLnZhbHVlLFxuICAgICAgcm9vdENsYXNzZXM6IHtcbiAgICAgICAgJ21kYy10ZXh0ZmllbGQnOiB0cnVlLFxuICAgICAgICAnbWRjLXRleHQtZmllbGQnOiB0cnVlLFxuICAgICAgICAnbWRjLXRleHQtZmllbGQtLXVwZ3JhZGVkJzogdHJ1ZSxcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkLS1kaXNhYmxlZCc6IHRoaXMuZGlzYWJsZWQsXG4gICAgICAgICdtZGMtdGV4dC1maWVsZC0tZGVuc2UnOiB0aGlzLmRlbnNlLFxuICAgICAgICAnbWRjLXRleHQtZmllbGQtLWZ1bGx3aWR0aCc6IHRoaXMuZnVsbHdpZHRoLFxuICAgICAgICAnbWRjLXRleHQtZmllbGQtLXRleHRhcmVhJzogdGhpcy5tdWx0aWxpbmUsXG4gICAgICAgICdtZGMtdGV4dC1maWVsZC0tYm94JzogIXRoaXMuZnVsbHdpZHRoICYmIHRoaXMuYm94LFxuICAgICAgICAnbWRjLXRleHQtZmllbGQtLW91dGxpbmVkJzogIXRoaXMuZnVsbHdpZHRoICYmIHRoaXMub3V0bGluZVxuICAgICAgfSxcbiAgICAgIGlucHV0Q2xhc3Nlczoge1xuICAgICAgICAnbWRjLXRleHQtZmllbGRfX2lucHV0JzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGxhYmVsQ2xhc3Nlczoge1xuICAgICAgICAnbWRjLWZsb2F0aW5nLWxhYmVsJzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGxpbmVSaXBwbGVDbGFzc2VzOiB7XG4gICAgICAgICdtZGMtbGluZS1yaXBwbGUnOiB0cnVlXG4gICAgICB9LFxuICAgICAgbGluZVJpcHBsZVN0eWxlczoge30sXG4gICAgICBoZWxwQ2xhc3Nlczoge1xuICAgICAgICAnbWRjLXRleHQtZmllbGQtaGVscGVyLXRleHQnOiB0cnVlLFxuICAgICAgICAnbWRjLXRleHQtZmllbGQtaGVscGVyLXRleHQtLXBlcnNpc3RlbnQnOiB0aGlzLmhlbHB0ZXh0UGVyc2lzdGVudCxcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkLWhlbHBlci10ZXh0LS12YWxpZGF0aW9uLW1zZyc6IHRoaXMuaGVscHRleHRWYWxpZGF0aW9uXG4gICAgICB9LFxuICAgICAgb3V0bGluZUNsYXNzZXM6IHt9LFxuICAgICAgb3V0bGluZVBhdGhBdHRyOiB1bmRlZmluZWRcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaW5wdXRQbGFjZUhvbGRlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZ1bGx3aWR0aCA/IHRoaXMubGFiZWwgOiB1bmRlZmluZWRcbiAgICB9LFxuICAgIGlucHV0QXJpYUNvbnRyb2xzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaGVscCA/ICdoZWxwLScgKyB0aGlzLnZtYV91aWRfIDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICBoYXNMYWJlbCgpIHtcbiAgICAgIHJldHVybiAhdGhpcy5mdWxsd2lkdGggJiYgdGhpcy5sYWJlbFxuICAgIH0sXG4gICAgaGFzT3V0bGluZSgpIHtcbiAgICAgIHJldHVybiAhdGhpcy5mdWxsd2lkdGggJiYgdGhpcy5vdXRsaW5lXG4gICAgfSxcbiAgICBoYXNMaW5lUmlwcGxlKCkge1xuICAgICAgcmV0dXJuICF0aGlzLmhhc091dGxpbmUgJiYgIXRoaXMubXVsdGlsaW5lXG4gICAgfSxcbiAgICBoYXNMZWFkaW5nSWNvbigpIHtcbiAgICAgIGlmIChcbiAgICAgICAgKHRoaXMubGVhZGluZ0ljb24gfHwgdGhpcy4kc2xvdHNbJ2xlYWRpbmctaWNvbiddKSAmJlxuICAgICAgICAhKHRoaXMudHJhaWxpbmdJY29uIHx8IHRoaXMuJHNsb3RzWyd0cmFpbGluZy1pY29uJ10pXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVhZGluZ0ljb24gPyBleHRyYWN0SWNvblByb3AodGhpcy5sZWFkaW5nSWNvbikgOiB7fVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSxcbiAgICBoYXNUcmFpbGluZ0ljb24oKSB7XG4gICAgICBpZiAodGhpcy50cmFpbGluZ0ljb24gfHwgdGhpcy4kc2xvdHNbJ3RyYWlsaW5nLWljb24nXSkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFpbGluZ0ljb24gPyBleHRyYWN0SWNvblByb3AodGhpcy50cmFpbGluZ0ljb24pIDoge31cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0sXG4gICAgbGFiZWxDbGFzc2VzVXBncmFkZWQoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih0aGlzLmxhYmVsQ2xhc3Nlcywge1xuICAgICAgICAnbWRjLWZsb2F0aW5nLWxhYmVsLS1mbG9hdC1hYm92ZSc6IHRoaXMudmFsdWVcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIGRpc2FibGVkKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5zZXREaXNhYmxlZCh0aGlzLmRpc2FibGVkKVxuICAgIH0sXG4gICAgcmVxdWlyZWQoKSB7XG4gICAgICB0aGlzLiRyZWZzLmlucHV0ICYmICh0aGlzLiRyZWZzLmlucHV0LnJlcXVpcmVkID0gdGhpcy5yZXF1aXJlZClcbiAgICB9LFxuICAgIHZhbGlkKCkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLnZhbGlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLnNldFZhbGlkKHRoaXMudmFsaWQpXG4gICAgICB9XG4gICAgfSxcbiAgICBkZW5zZSgpIHtcbiAgICAgIHRoaXMuJHNldCh0aGlzLnJvb3RDbGFzc2VzLCAnbWRjLXRleHQtZmllbGQtLWRlbnNlJywgdGhpcy5kZW5zZSlcbiAgICB9LFxuICAgIGhlbHB0ZXh0UGVyc2lzdGVudCgpIHtcbiAgICAgIHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24gJiZcbiAgICAgICAgdGhpcy5oZWxwZXJUZXh0Rm91bmRhdGlvbi5zZXRQZXJzaXN0ZW50KHRoaXMuaGVscHRleHRQZXJzaXN0ZW50KVxuICAgIH0sXG4gICAgaGVscHRleHRWYWxpZGF0aW9uKCkge1xuICAgICAgdGhpcy5oZWxwZXJUZXh0Rm91bmRhdGlvbiAmJlxuICAgICAgICB0aGlzLmhlbHBlclRleHRGb3VuZGF0aW9uLnNldFZhbGlkYXRpb24odGhpcy5oZWxwdGV4dFZhbGlkYXRpb24pXG4gICAgfSxcbiAgICB2YWx1ZSh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuZm91bmRhdGlvbikge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuZm91bmRhdGlvbi5nZXRWYWx1ZSgpKSB7XG4gICAgICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldFZhbHVlKHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIGlmICh0aGlzLiRyZWZzLmxpbmVSaXBwbGUpIHtcbiAgICAgIHRoaXMubGluZVJpcHBsZUZvdW5kYXRpb24gPSBuZXcgTURDTGluZVJpcHBsZUZvdW5kYXRpb24oe1xuICAgICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgICB0aGlzLiRzZXQodGhpcy5saW5lUmlwcGxlQ2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmVDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5saW5lUmlwcGxlQ2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgICB9LFxuICAgICAgICBoYXNDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgICB0aGlzLiRyZWZzLmxpbmVSaXBwbGUuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSlcbiAgICAgICAgfSxcbiAgICAgICAgc2V0U3R5bGU6IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIHRoaXMuJHNldCh0aGlzLmxpbmVSaXBwbGVTdHlsZXMsIG5hbWUsIHZhbHVlKVxuICAgICAgICB9LFxuICAgICAgICByZWdpc3RlckV2ZW50SGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICB0aGlzLiRyZWZzLmxpbmVSaXBwbGUuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxuICAgICAgICB9LFxuICAgICAgICBkZXJlZ2lzdGVyRXZlbnRIYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMubGluZVJpcHBsZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICB0aGlzLmxpbmVSaXBwbGVGb3VuZGF0aW9uLmluaXQoKVxuICAgIH1cblxuICAgIGlmICh0aGlzLiRyZWZzLmhlbHApIHtcbiAgICAgIHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24gPSBuZXcgTURDVGV4dEZpZWxkSGVscGVyVGV4dEZvdW5kYXRpb24oe1xuICAgICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgICB0aGlzLiRzZXQodGhpcy5oZWxwQ2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmVDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5oZWxwQ2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgICB9LFxuICAgICAgICBoYXNDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5oZWxwLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpXG4gICAgICAgIH0sXG4gICAgICAgIHNldEF0dHI6IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMuaGVscC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpXG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUF0dHI6IG5hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMuaGVscC5yZW1vdmVBdHRyaWJ1dGUobmFtZSlcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Q29udGVudDogKC8qY29udGVudCovKSA9PiB7XG4gICAgICAgICAgLy8gaGVscCB0ZXh0IGdldCdzIHVwZGF0ZWQgZnJvbSB7e2hlbHB0ZXh0fX1cbiAgICAgICAgICAvLyB0aGlzLiRyZWZzLmhlbHAudGV4dENvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgdGhpcy5oZWxwZXJUZXh0Rm91bmRhdGlvbi5pbml0KClcbiAgICB9XG5cbiAgICBpZiAodGhpcy4kcmVmcy5pY29uKSB7XG4gICAgICBpZiAodGhpcy5oYXNMZWFkaW5nSWNvbikge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5yb290Q2xhc3NlcywgJ21kYy10ZXh0LWZpZWxkLS13aXRoLWxlYWRpbmctaWNvbicsIHRydWUpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaGFzVHJhaWxpbmdJY29uKSB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnJvb3RDbGFzc2VzLCAnbWRjLXRleHQtZmllbGQtLXdpdGgtdHJhaWxpbmctaWNvbicsIHRydWUpXG4gICAgICB9XG5cbiAgICAgIHRoaXMuaWNvbkZvdW5kYXRpb24gPSBuZXcgTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb24oe1xuICAgICAgICBzZXRBdHRyOiAoYXR0ciwgdmFsdWUpID0+IHRoaXMuJHJlZnMuaWNvbi5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpLFxuICAgICAgICBnZXRBdHRyOiBhdHRyID0+IHRoaXMuJHJlZnMuaWNvbi5nZXRBdHRyaWJ1dGUoYXR0ciksXG4gICAgICAgIHJlbW92ZUF0dHI6IGF0dHIgPT4gdGhpcy4kcmVmcy5pY29uLnJlbW92ZUF0dHJpYnV0ZShhdHRyKSxcbiAgICAgICAgc2V0Q29udGVudDogKC8qY29udGVudCovKSA9PiB7XG4gICAgICAgICAgLy8gaWNvbiB0ZXh0IGdldCdzIHVwZGF0ZWQgZnJvbSB7e3t7IGhhc1RyYWlsaW5nSWNvbi5jb250ZW50IH19fX1cbiAgICAgICAgICAvLyB0aGlzLiRyZWZzLmljb24udGV4dENvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB9LFxuICAgICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICB0aGlzLiRyZWZzLmljb24uYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxuICAgICAgICB9LFxuICAgICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMuaWNvbi5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpXG4gICAgICAgIH0sXG4gICAgICAgIG5vdGlmeUljb25BY3Rpb246ICgpID0+IHRoaXMuJGVtaXQoJ2ljb24tYWN0aW9uJylcbiAgICAgIH0pXG4gICAgICB0aGlzLmljb25Gb3VuZGF0aW9uLmluaXQoKVxuICAgIH1cblxuICAgIGlmICh0aGlzLiRyZWZzLmxhYmVsKSB7XG4gICAgICB0aGlzLmxhYmVsRm91bmRhdGlvbiA9IG5ldyBNRENGbG9hdGluZ0xhYmVsRm91bmRhdGlvbih7XG4gICAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJHNldCh0aGlzLmxhYmVsQ2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmVDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5sYWJlbENsYXNzZXMsIGNsYXNzTmFtZSlcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0V2lkdGg6ICgpID0+IHRoaXMuJHJlZnMubGFiZWwub2Zmc2V0V2lkdGgsXG4gICAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMubGFiZWwuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxuICAgICAgICB9LFxuICAgICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMubGFiZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgdGhpcy5sYWJlbEZvdW5kYXRpb24uaW5pdCgpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuJHJlZnMub3V0bGluZSkge1xuICAgICAgdGhpcy5vdXRsaW5lRm91bmRhdGlvbiA9IG5ldyBNRENOb3RjaGVkT3V0bGluZUZvdW5kYXRpb24oe1xuICAgICAgICBnZXRXaWR0aDogKCkgPT4gdGhpcy4kcmVmcy5vdXRsaW5lLm9mZnNldFdpZHRoLFxuICAgICAgICBnZXRIZWlnaHQ6ICgpID0+IHRoaXMuJHJlZnMub3V0bGluZS5vZmZzZXRIZWlnaHQsXG4gICAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJHNldCh0aGlzLm91dGxpbmVDbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLm91dGxpbmVDbGFzc2VzLCBjbGFzc05hbWUpXG4gICAgICAgIH0sXG4gICAgICAgIHNldE91dGxpbmVQYXRoQXR0cjogdmFsdWUgPT4ge1xuICAgICAgICAgIHRoaXMub3V0bGluZVBhdGhBdHRyID0gdmFsdWVcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0SWRsZU91dGxpbmVTdHlsZVZhbHVlOiBwcm9wZXJ0eU5hbWUgPT4ge1xuICAgICAgICAgIGNvbnN0IGlkbGVPdXRsaW5lRWxlbWVudCA9IHRoaXMuJHJlZnMub3V0bGluZUlkbGVcbiAgICAgICAgICBpZiAoaWRsZU91dGxpbmVFbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gd2luZG93XG4gICAgICAgICAgICAgIC5nZXRDb21wdXRlZFN0eWxlKGlkbGVPdXRsaW5lRWxlbWVudClcbiAgICAgICAgICAgICAgLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHlOYW1lKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHRoaXMub3V0bGluZUZvdW5kYXRpb24uaW5pdCgpXG4gICAgfVxuXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ1RleHRmaWVsZEZvdW5kYXRpb24oXG4gICAgICB7XG4gICAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJHNldCh0aGlzLnJvb3RDbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLnJvb3RDbGFzc2VzLCBjbGFzc05hbWUpXG4gICAgICAgIH0sXG4gICAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMucm9vdC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKVxuICAgICAgICB9LFxuICAgICAgICByZWdpc3RlclRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICB0aGlzLiRyZWZzLnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxuICAgICAgICB9LFxuICAgICAgICBkZXJlZ2lzdGVyVGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMucm9vdC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpXG4gICAgICAgIH0sXG4gICAgICAgIGlzRm9jdXNlZDogKCkgPT4ge1xuICAgICAgICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLiRyZWZzLmlucHV0XG4gICAgICAgIH0sXG4gICAgICAgIGlzUnRsOiAoKSA9PlxuICAgICAgICAgIHdpbmRvd1xuICAgICAgICAgICAgLmdldENvbXB1dGVkU3R5bGUodGhpcy4kcmVmcy5yb290KVxuICAgICAgICAgICAgLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpID09PSAncnRsJyxcbiAgICAgICAgZGVhY3RpdmF0ZUxpbmVSaXBwbGU6ICgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5saW5lUmlwcGxlRm91bmRhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5saW5lUmlwcGxlRm91bmRhdGlvbi5kZWFjdGl2YXRlKClcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFjdGl2YXRlTGluZVJpcHBsZTogKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmxpbmVSaXBwbGVGb3VuZGF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmVSaXBwbGVGb3VuZGF0aW9uLmFjdGl2YXRlKClcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldExpbmVSaXBwbGVUcmFuc2Zvcm1PcmlnaW46IG5vcm1hbGl6ZWRYID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5saW5lUmlwcGxlRm91bmRhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5saW5lUmlwcGxlRm91bmRhdGlvbi5zZXRSaXBwbGVDZW50ZXIobm9ybWFsaXplZFgpXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMuaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyLCBhcHBseVBhc3NpdmUoKSlcbiAgICAgICAgfSxcbiAgICAgICAgZGVyZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMuaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyLCBhcHBseVBhc3NpdmUoKSlcbiAgICAgICAgfSxcbiAgICAgICAgcmVnaXN0ZXJWYWxpZGF0aW9uQXR0cmlidXRlQ2hhbmdlSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgICAgY29uc3QgZ2V0QXR0cmlidXRlc0xpc3QgPSBtdXRhdGlvbnNMaXN0ID0+XG4gICAgICAgICAgICBtdXRhdGlvbnNMaXN0Lm1hcChtdXRhdGlvbiA9PiBtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lKVxuICAgICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zTGlzdCA9PlxuICAgICAgICAgICAgaGFuZGxlcihnZXRBdHRyaWJ1dGVzTGlzdChtdXRhdGlvbnNMaXN0KSlcbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRoaXMuJHJlZnMuaW5wdXRcbiAgICAgICAgICBjb25zdCBjb25maWcgPSB7IGF0dHJpYnV0ZXM6IHRydWUgfVxuICAgICAgICAgIG9ic2VydmVyLm9ic2VydmUodGFyZ2V0Tm9kZSwgY29uZmlnKVxuICAgICAgICAgIHJldHVybiBvYnNlcnZlclxuICAgICAgICB9LFxuICAgICAgICBkZXJlZ2lzdGVyVmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXI6IG9ic2VydmVyID0+IHtcbiAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICAgICAgfSxcbiAgICAgICAgc2hha2VMYWJlbDogc2hvdWxkU2hha2UgPT4ge1xuICAgICAgICAgIHRoaXMubGFiZWxGb3VuZGF0aW9uLnNoYWtlKHNob3VsZFNoYWtlKVxuICAgICAgICB9LFxuICAgICAgICBmbG9hdExhYmVsOiBzaG91bGRGbG9hdCA9PiB7XG4gICAgICAgICAgdGhpcy5sYWJlbEZvdW5kYXRpb24uZmxvYXQoc2hvdWxkRmxvYXQpXG4gICAgICAgIH0sXG4gICAgICAgIGhhc0xhYmVsOiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuICEhdGhpcy4kcmVmcy5sYWJlbFxuICAgICAgICB9LFxuICAgICAgICBnZXRMYWJlbFdpZHRoOiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxGb3VuZGF0aW9uLmdldFdpZHRoKClcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TmF0aXZlSW5wdXQ6ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5pbnB1dFxuICAgICAgICB9LFxuICAgICAgICBoYXNPdXRsaW5lOiAoKSA9PiAhIXRoaXMuaGFzT3V0bGluZSxcbiAgICAgICAgbm90Y2hPdXRsaW5lOiAobm90Y2hXaWR0aCwgaXNSdGwpID0+XG4gICAgICAgICAgdGhpcy5vdXRsaW5lRm91bmRhdGlvbi5ub3RjaChub3RjaFdpZHRoLCBpc1J0bCksXG4gICAgICAgIGNsb3NlT3V0bGluZTogKCkgPT4gdGhpcy5vdXRsaW5lRm91bmRhdGlvbi5jbG9zZU5vdGNoKClcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGhlbHBlclRleHQ6IHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24sXG4gICAgICAgIGljb246IHRoaXMuaWNvbkZvdW5kYXRpb25cbiAgICAgIH1cbiAgICApXG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldFZhbHVlKHRoaXMudmFsdWUpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHRoaXMuZGlzYWJsZWQpXG4gICAgdGhpcy4kcmVmcy5pbnB1dCAmJiAodGhpcy4kcmVmcy5pbnB1dC5yZXF1aXJlZCA9IHRoaXMucmVxdWlyZWQpXG4gICAgaWYgKHR5cGVvZiB0aGlzLnZhbGlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldFZhbGlkKHRoaXMudmFsaWQpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMudGV4dGJveCkge1xuICAgICAgdGhpcy5yaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzKVxuICAgICAgdGhpcy5yaXBwbGUuaW5pdCgpXG4gICAgfVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gICAgdGhpcy5saW5lUmlwcGxlRm91bmRhdGlvbiAmJiB0aGlzLmxpbmVSaXBwbGVGb3VuZGF0aW9uLmRlc3Ryb3koKVxuICAgIHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24gJiYgdGhpcy5oZWxwZXJUZXh0Rm91bmRhdGlvbi5kZXN0cm95KClcbiAgICB0aGlzLmljb25Gb3VuZGF0aW9uICYmIHRoaXMuaWNvbkZvdW5kYXRpb24uZGVzdHJveSgpXG4gICAgdGhpcy5sYWJlbEZvdW5kYXRpb24gJiYgdGhpcy5sYWJlbEZvdW5kYXRpb24uZGVzdHJveSgpXG4gICAgdGhpcy5vdXRsaW5lRm91bmRhdGlvbiAmJiB0aGlzLm91dGxpbmVGb3VuZGF0aW9uLmRlc3Ryb3koKVxuICAgIHRoaXMucmlwcGxlICYmIHRoaXMucmlwcGxlLmRlc3Ryb3koKVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgdXBkYXRlVmFsdWUodmFsdWUpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ21vZGVsJywgdmFsdWUpXG4gICAgfSxcbiAgICBmb2N1cygpIHtcbiAgICAgIHRoaXMuJHJlZnMuaW5wdXQgJiYgdGhpcy4kcmVmcy5pbnB1dC5mb2N1cygpXG4gICAgfSxcbiAgICBibHVyKCkge1xuICAgICAgdGhpcy4kcmVmcy5pbnB1dCAmJiB0aGlzLiRyZWZzLmlucHV0LmJsdXIoKVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNUZXh0RmllbGQgZnJvbSAnLi9tZGMtdGV4dGZpZWxkLnZ1ZSdcblxuZXhwb3J0IHsgbWRjVGV4dEZpZWxkIH1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY1RleHRGaWVsZFxufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPGN1c3RvbS1lbGVtZW50IFxuICAgIDp0YWc9XCJ0YWdcIiBcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCJcbiAgICBjbGFzcz1cIm1kYy10aGVtZVwiPlxuICAgIDxzbG90IC8+XG4gIDwvY3VzdG9tLWVsZW1lbnQ+XG48L3RlbXBsYXRlPlxuXG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBDdXN0b21FbGVtZW50IH0gZnJvbSAnLi4vYmFzZSdcblxuY29uc3QgVEhFTUVfQ09MT1JTID0gW1xuICAncHJpbWFyeScsXG4gICdzZWNvbmRhcnknLFxuICAnYmFja2dyb3VuZCcsXG4gICdwcmltYXJ5LWxpZ2h0JyxcbiAgJ3NlY29uZGFyeS1saWdodCcsXG4gICdzZWNvbmRhcnktZGFyaycsXG4gICdwcmltYXJ5LWRhcmsnXG5dXG5cbmNvbnN0IFRIRU1FX1NUWUxFUyA9IFtcbiAgJ3RleHQtcHJpbWFyeScsXG4gICd0ZXh0LXNlY29uZGFyeScsXG4gICd0ZXh0LWhpbnQnLFxuICAndGV4dC1pY29uJyxcbiAgJ3RleHQtZGlzYWJsZWQnXG5dXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10aGVtZScsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBDdXN0b21FbGVtZW50XG4gIH0sXG4gIHByb3BzOiB7XG4gICAgdGFnOiB7IHR5cGU6IFN0cmluZywgZGVmYXVsdDogJ2RpdicgfSxcbiAgICBjb2xvcjogU3RyaW5nLFxuICAgIGJhY2tncm91bmQ6IFN0cmluZ1xuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMoKSB7XG4gICAgICBsZXQgY2xhc3NlcyA9IHt9XG5cbiAgICAgIGlmICh0aGlzLmNvbG9yICYmIFRIRU1FX0NPTE9SUy5pbmRleE9mKHRoaXMuY29sb3IpICE9PSAtMSkge1xuICAgICAgICBjbGFzc2VzW2BtZGMtdGhlbWUtLSR7dGhpcy5jb2xvcn1gXSA9IHRydWVcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYmFja2dyb3VuZCAmJiBUSEVNRV9DT0xPUlMuaW5kZXhPZih0aGlzLmJhY2tncm91bmQpICE9PSAtMSkge1xuICAgICAgICBjbGFzc2VzW2BtZGMtdGhlbWUtLSR7dGhpcy5iYWNrZ3JvdW5kfS1iZ2BdID0gdHJ1ZVxuXG4gICAgICAgIGlmICh0aGlzLmNvbG9yICYmIFRIRU1FX1NUWUxFUy5pbmRleE9mKHRoaXMuY29sb3IpICE9PSAtMSkge1xuICAgICAgICAgIGNsYXNzZXNbYG1kYy10aGVtZS0tJHt0aGlzLmNvbG9yfS1vbi0ke3RoaXMuYmFja2dyb3VuZH1gXSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNsYXNzZXNcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjVGhlbWUgZnJvbSAnLi9tZGMtdGhlbWUudnVlJ1xuXG5leHBvcnQgeyBtZGNUaGVtZSB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNUaGVtZVxufSlcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xuICBGSVhFRDogJ21kYy10b29sYmFyLS1maXhlZCcsXG4gIEZJWEVEX0xBU1RST1c6ICdtZGMtdG9vbGJhci0tZml4ZWQtbGFzdHJvdy1vbmx5JyxcbiAgRklYRURfQVRfTEFTVF9ST1c6ICdtZGMtdG9vbGJhci0tZml4ZWQtYXQtbGFzdC1yb3cnLFxuICBUT09MQkFSX1JPV19GTEVYSUJMRTogJ21kYy10b29sYmFyLS1mbGV4aWJsZScsXG4gIEZMRVhJQkxFX0RFRkFVTFRfQkVIQVZJT1I6ICdtZGMtdG9vbGJhci0tZmxleGlibGUtZGVmYXVsdC1iZWhhdmlvcicsXG4gIEZMRVhJQkxFX01BWDogJ21kYy10b29sYmFyLS1mbGV4aWJsZS1zcGFjZS1tYXhpbWl6ZWQnLFxuICBGTEVYSUJMRV9NSU46ICdtZGMtdG9vbGJhci0tZmxleGlibGUtc3BhY2UtbWluaW1pemVkJyxcbn07XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBUSVRMRV9TRUxFQ1RPUjogJy5tZGMtdG9vbGJhcl9fdGl0bGUnLFxuICBJQ09OX1NFTEVDVE9SOiAnLm1kYy10b29sYmFyX19pY29uJyxcbiAgRklSU1RfUk9XX1NFTEVDVE9SOiAnLm1kYy10b29sYmFyX19yb3c6Zmlyc3QtY2hpbGQnLFxuICBDSEFOR0VfRVZFTlQ6ICdNRENUb29sYmFyOmNoYW5nZScsXG59O1xuXG5leHBvcnQgY29uc3QgbnVtYmVycyA9IHtcbiAgTUFYX1RJVExFX1NJWkU6IDIuMTI1LFxuICBNSU5fVElUTEVfU0laRTogMS4yNSxcbiAgVE9PTEJBUl9ST1dfSEVJR0hUOiA2NCxcbiAgVE9PTEJBUl9ST1dfTU9CSUxFX0hFSUdIVDogNTYsXG4gIFRPT0xCQVJfTU9CSUxFX0JSRUFLUE9JTlQ6IDYwMCxcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURDVG9vbGJhckZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIHJldHVybiBudW1iZXJzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaGFzQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4gLyogYm9vbGVhbiAqLyBmYWxzZSxcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZWdpc3RlclNjcm9sbEhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJTY3JvbGxIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBnZXRWaWV3cG9ydFdpZHRoOiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIGdldFZpZXdwb3J0U2Nyb2xsWTogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBnZXRPZmZzZXRIZWlnaHQ6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgZ2V0Rmlyc3RSb3dFbGVtZW50T2Zmc2V0SGVpZ2h0OiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIG5vdGlmeUNoYW5nZTogKC8qIGV2dERhdGE6IHtmbGV4aWJsZUV4cGFuc2lvblJhdGlvOiBudW1iZXJ9ICovKSA9PiB7fSxcbiAgICAgIHNldFN0eWxlOiAoLyogcHJvcGVydHk6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXRTdHlsZUZvclRpdGxlRWxlbWVudDogKC8qIHByb3BlcnR5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgc2V0U3R5bGVGb3JGbGV4aWJsZVJvd0VsZW1lbnQ6ICgvKiBwcm9wZXJ0eTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldFN0eWxlRm9yRml4ZWRBZGp1c3RFbGVtZW50OiAoLyogcHJvcGVydHk6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG4gICAgdGhpcy5yZXNpemVIYW5kbGVyXyA9ICgpID0+IHRoaXMuY2hlY2tSb3dIZWlnaHRfKCk7XG4gICAgdGhpcy5zY3JvbGxIYW5kbGVyXyA9ICgpID0+IHRoaXMudXBkYXRlVG9vbGJhclN0eWxlc18oKTtcbiAgICB0aGlzLmNoZWNrUm93SGVpZ2h0RnJhbWVfID0gMDtcbiAgICB0aGlzLnNjcm9sbEZyYW1lXyA9IDA7XG4gICAgdGhpcy5leGVjdXRlZExhc3RDaGFuZ2VfID0gZmFsc2U7XG5cbiAgICB0aGlzLmNhbGN1bGF0aW9uc18gPSB7XG4gICAgICB0b29sYmFyUm93SGVpZ2h0OiAwLFxuICAgICAgLy8gQ2FsY3VsYXRlZCBIZWlnaHQgcmF0aW8uIFdlIHVzZSByYXRpbyB0byBjYWxjdWxhdGUgY29ycmVzcG9uZGluZyBoZWlnaHRzIGluIHJlc2l6ZSBldmVudC5cbiAgICAgIHRvb2xiYXJSYXRpbzogMCwgLy8gVGhlIHJhdGlvIG9mIHRvb2xiYXIgaGVpZ2h0IHRvIHJvdyBoZWlnaHRcbiAgICAgIGZsZXhpYmxlRXhwYW5zaW9uUmF0aW86IDAsIC8vIFRoZSByYXRpbyBvZiBmbGV4aWJsZSBzcGFjZSBoZWlnaHQgdG8gcm93IGhlaWdodFxuICAgICAgbWF4VHJhbnNsYXRlWVJhdGlvOiAwLCAvLyBUaGUgcmF0aW8gb2YgbWF4IHRvb2xiYXIgbW92ZSB1cCBkaXN0YW5jZSB0byByb3cgaGVpZ2h0XG4gICAgICBzY3JvbGxUaHJlc2hvbGRSYXRpbzogMCwgLy8gVGhlIHJhdGlvIG9mIG1heCBzY3JvbGxUb3AgdGhhdCB3ZSBzaG91bGQgbGlzdGVuIHRvIHRvIHJvdyBoZWlnaHRcbiAgICAgIC8vIERlcml2ZWQgSGVpZ2h0cyBiYXNlZCBvbiB0aGUgYWJvdmUga2V5IHJhdGlvcy5cbiAgICAgIHRvb2xiYXJIZWlnaHQ6IDAsXG4gICAgICBmbGV4aWJsZUV4cGFuc2lvbkhlaWdodDogMCwgLy8gRmxleGlibGUgcm93IG1pbnVzIHRvb2xiYXIgaGVpZ2h0IChkZXJpdmVkKVxuICAgICAgbWF4VHJhbnNsYXRlWURpc3RhbmNlOiAwLCAvLyBXaGVuIHRvb2xiYXIgb25seSBmaXggbGFzdCByb3cgKGRlcml2ZWQpXG4gICAgICBzY3JvbGxUaHJlc2hvbGQ6IDAsXG4gICAgfTtcbiAgICAvLyBUb29sYmFyIGZpeGVkIGJlaGF2aW9yXG4gICAgLy8gSWYgdG9vbGJhciBpcyBmaXhlZFxuICAgIHRoaXMuZml4ZWRfID0gZmFsc2U7XG4gICAgLy8gSWYgZml4ZWQgaXMgdGFyZ2V0ZWQgb25seSBhdCB0aGUgbGFzdCByb3dcbiAgICB0aGlzLmZpeGVkTGFzdHJvd18gPSBmYWxzZTtcbiAgICAvLyBUb29sYmFyIGZsZXhpYmxlIGJlaGF2aW9yXG4gICAgLy8gSWYgdGhlIGZpcnN0IHJvdyBpcyBmbGV4aWJsZVxuICAgIHRoaXMuaGFzRmxleGlibGVSb3dfID0gZmFsc2U7XG4gICAgLy8gSWYgdXNlIHRoZSBkZWZhdWx0IGJlaGF2aW9yXG4gICAgdGhpcy51c2VGbGV4RGVmYXVsdEJlaGF2aW9yXyA9IGZhbHNlO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmZpeGVkXyA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoTURDVG9vbGJhckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GSVhFRCk7XG4gICAgdGhpcy5maXhlZExhc3Ryb3dfID0gdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhNRENUb29sYmFyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkZJWEVEX0xBU1RST1cpICYgdGhpcy5maXhlZF87XG4gICAgdGhpcy5oYXNGbGV4aWJsZVJvd18gPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuVE9PTEJBUl9ST1dfRkxFWElCTEUpO1xuICAgIGlmICh0aGlzLmhhc0ZsZXhpYmxlUm93Xykge1xuICAgICAgdGhpcy51c2VGbGV4RGVmYXVsdEJlaGF2aW9yXyA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoTURDVG9vbGJhckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GTEVYSUJMRV9ERUZBVUxUX0JFSEFWSU9SKTtcbiAgICB9XG4gICAgdGhpcy5pbml0S2V5UmF0aW9fKCk7XG4gICAgdGhpcy5zZXRLZXlIZWlnaHRzXygpO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJTY3JvbGxIYW5kbGVyKHRoaXMuc2Nyb2xsSGFuZGxlcl8pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclNjcm9sbEhhbmRsZXIodGhpcy5zY3JvbGxIYW5kbGVyXyk7XG4gIH1cblxuICB1cGRhdGVBZGp1c3RFbGVtZW50U3R5bGVzKCkge1xuICAgIGlmICh0aGlzLmZpeGVkXykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZUZvckZpeGVkQWRqdXN0RWxlbWVudCgnbWFyZ2luLXRvcCcsIGAke3RoaXMuY2FsY3VsYXRpb25zXy50b29sYmFySGVpZ2h0fXB4YCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0RmxleGlibGVFeHBhbnNpb25SYXRpb18oc2Nyb2xsVG9wKSB7XG4gICAgLy8gVG8gcHJldmVudCBkaXZpc2lvbiBieSB6ZXJvIHdoZW4gdGhlcmUgaXMgbm8gZmxleGlibGVFeHBhbnNpb25IZWlnaHRcbiAgICBjb25zdCBkZWx0YSA9IDAuMDAwMTtcbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgMSAtIHNjcm9sbFRvcCAvICh0aGlzLmNhbGN1bGF0aW9uc18uZmxleGlibGVFeHBhbnNpb25IZWlnaHQgKyBkZWx0YSkpO1xuICB9XG5cbiAgY2hlY2tSb3dIZWlnaHRfKCkge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuY2hlY2tSb3dIZWlnaHRGcmFtZV8pO1xuICAgIHRoaXMuY2hlY2tSb3dIZWlnaHRGcmFtZV8gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5zZXRLZXlIZWlnaHRzXygpKTtcbiAgfVxuXG4gIHNldEtleUhlaWdodHNfKCkge1xuICAgIGNvbnN0IG5ld1Rvb2xiYXJSb3dIZWlnaHQgPSB0aGlzLmdldFJvd0hlaWdodF8oKTtcbiAgICBpZiAobmV3VG9vbGJhclJvd0hlaWdodCAhPT0gdGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJSb3dIZWlnaHQpIHtcbiAgICAgIHRoaXMuY2FsY3VsYXRpb25zXy50b29sYmFyUm93SGVpZ2h0ID0gbmV3VG9vbGJhclJvd0hlaWdodDtcbiAgICAgIHRoaXMuY2FsY3VsYXRpb25zXy50b29sYmFySGVpZ2h0ID0gdGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJSYXRpbyAqIHRoaXMuY2FsY3VsYXRpb25zXy50b29sYmFyUm93SGVpZ2h0O1xuICAgICAgdGhpcy5jYWxjdWxhdGlvbnNfLmZsZXhpYmxlRXhwYW5zaW9uSGVpZ2h0ID1cbiAgICAgICAgdGhpcy5jYWxjdWxhdGlvbnNfLmZsZXhpYmxlRXhwYW5zaW9uUmF0aW8gKiB0aGlzLmNhbGN1bGF0aW9uc18udG9vbGJhclJvd0hlaWdodDtcbiAgICAgIHRoaXMuY2FsY3VsYXRpb25zXy5tYXhUcmFuc2xhdGVZRGlzdGFuY2UgPVxuICAgICAgICB0aGlzLmNhbGN1bGF0aW9uc18ubWF4VHJhbnNsYXRlWVJhdGlvICogdGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJSb3dIZWlnaHQ7XG4gICAgICB0aGlzLmNhbGN1bGF0aW9uc18uc2Nyb2xsVGhyZXNob2xkID1cbiAgICAgICAgdGhpcy5jYWxjdWxhdGlvbnNfLnNjcm9sbFRocmVzaG9sZFJhdGlvICogdGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJSb3dIZWlnaHQ7XG4gICAgICB0aGlzLnVwZGF0ZUFkanVzdEVsZW1lbnRTdHlsZXMoKTtcbiAgICAgIHRoaXMudXBkYXRlVG9vbGJhclN0eWxlc18oKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVUb29sYmFyU3R5bGVzXygpIHtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnNjcm9sbEZyYW1lXyk7XG4gICAgdGhpcy5zY3JvbGxGcmFtZV8gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgY29uc3Qgc2Nyb2xsVG9wID0gdGhpcy5hZGFwdGVyXy5nZXRWaWV3cG9ydFNjcm9sbFkoKTtcbiAgICAgIGNvbnN0IGhhc1Njcm9sbGVkT3V0T2ZUaHJlc2hvbGQgPSB0aGlzLnNjcm9sbGVkT3V0T2ZUaHJlc2hvbGRfKHNjcm9sbFRvcCk7XG5cbiAgICAgIGlmIChoYXNTY3JvbGxlZE91dE9mVGhyZXNob2xkICYmIHRoaXMuZXhlY3V0ZWRMYXN0Q2hhbmdlXykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGZsZXhpYmxlRXhwYW5zaW9uUmF0aW8gPSB0aGlzLmdldEZsZXhpYmxlRXhwYW5zaW9uUmF0aW9fKHNjcm9sbFRvcCk7XG5cbiAgICAgIHRoaXMudXBkYXRlVG9vbGJhckZsZXhpYmxlU3RhdGVfKGZsZXhpYmxlRXhwYW5zaW9uUmF0aW8pO1xuICAgICAgaWYgKHRoaXMuZml4ZWRMYXN0cm93Xykge1xuICAgICAgICB0aGlzLnVwZGF0ZVRvb2xiYXJGaXhlZFN0YXRlXyhzY3JvbGxUb3ApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaGFzRmxleGlibGVSb3dfKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRmxleGlibGVSb3dFbGVtZW50U3R5bGVzXyhmbGV4aWJsZUV4cGFuc2lvblJhdGlvKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZXhlY3V0ZWRMYXN0Q2hhbmdlXyA9IGhhc1Njcm9sbGVkT3V0T2ZUaHJlc2hvbGQ7XG4gICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUNoYW5nZSh7ZmxleGlibGVFeHBhbnNpb25SYXRpbzogZmxleGlibGVFeHBhbnNpb25SYXRpb30pO1xuICAgIH0pO1xuICB9XG5cbiAgc2Nyb2xsZWRPdXRPZlRocmVzaG9sZF8oc2Nyb2xsVG9wKSB7XG4gICAgcmV0dXJuIHNjcm9sbFRvcCA+IHRoaXMuY2FsY3VsYXRpb25zXy5zY3JvbGxUaHJlc2hvbGQ7XG4gIH1cblxuICBpbml0S2V5UmF0aW9fKCkge1xuICAgIGNvbnN0IHRvb2xiYXJSb3dIZWlnaHQgPSB0aGlzLmdldFJvd0hlaWdodF8oKTtcbiAgICBjb25zdCBmaXJzdFJvd01heFJhdGlvID0gdGhpcy5hZGFwdGVyXy5nZXRGaXJzdFJvd0VsZW1lbnRPZmZzZXRIZWlnaHQoKSAvIHRvb2xiYXJSb3dIZWlnaHQ7XG4gICAgdGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJSYXRpbyA9IHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0SGVpZ2h0KCkgLyB0b29sYmFyUm93SGVpZ2h0O1xuICAgIHRoaXMuY2FsY3VsYXRpb25zXy5mbGV4aWJsZUV4cGFuc2lvblJhdGlvID0gZmlyc3RSb3dNYXhSYXRpbyAtIDE7XG4gICAgdGhpcy5jYWxjdWxhdGlvbnNfLm1heFRyYW5zbGF0ZVlSYXRpbyA9XG4gICAgICB0aGlzLmZpeGVkTGFzdHJvd18gPyB0aGlzLmNhbGN1bGF0aW9uc18udG9vbGJhclJhdGlvIC0gZmlyc3RSb3dNYXhSYXRpbyA6IDA7XG4gICAgdGhpcy5jYWxjdWxhdGlvbnNfLnNjcm9sbFRocmVzaG9sZFJhdGlvID1cbiAgICAgICh0aGlzLmZpeGVkTGFzdHJvd18gPyB0aGlzLmNhbGN1bGF0aW9uc18udG9vbGJhclJhdGlvIDogZmlyc3RSb3dNYXhSYXRpbykgLSAxO1xuICB9XG5cbiAgZ2V0Um93SGVpZ2h0XygpIHtcbiAgICBjb25zdCBicmVha3BvaW50ID0gTURDVG9vbGJhckZvdW5kYXRpb24ubnVtYmVycy5UT09MQkFSX01PQklMRV9CUkVBS1BPSU5UO1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmdldFZpZXdwb3J0V2lkdGgoKSA8IGJyZWFrcG9pbnQgP1xuICAgICAgTURDVG9vbGJhckZvdW5kYXRpb24ubnVtYmVycy5UT09MQkFSX1JPV19NT0JJTEVfSEVJR0hUIDogTURDVG9vbGJhckZvdW5kYXRpb24ubnVtYmVycy5UT09MQkFSX1JPV19IRUlHSFQ7XG4gIH1cblxuICB1cGRhdGVUb29sYmFyRmxleGlibGVTdGF0ZV8oZmxleGlibGVFeHBhbnNpb25SYXRpbykge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDVG9vbGJhckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GTEVYSUJMRV9NQVgpO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDVG9vbGJhckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GTEVYSUJMRV9NSU4pO1xuICAgIGlmIChmbGV4aWJsZUV4cGFuc2lvblJhdGlvID09PSAxKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuRkxFWElCTEVfTUFYKTtcbiAgICB9IGVsc2UgaWYgKGZsZXhpYmxlRXhwYW5zaW9uUmF0aW8gPT09IDApIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDVG9vbGJhckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GTEVYSUJMRV9NSU4pO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZVRvb2xiYXJGaXhlZFN0YXRlXyhzY3JvbGxUb3ApIHtcbiAgICBjb25zdCB0cmFuc2xhdGVEaXN0YW5jZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKFxuICAgICAgc2Nyb2xsVG9wIC0gdGhpcy5jYWxjdWxhdGlvbnNfLmZsZXhpYmxlRXhwYW5zaW9uSGVpZ2h0LFxuICAgICAgdGhpcy5jYWxjdWxhdGlvbnNfLm1heFRyYW5zbGF0ZVlEaXN0YW5jZSkpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGUoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGVZKCR7LXRyYW5zbGF0ZURpc3RhbmNlfXB4KWApO1xuXG4gICAgaWYgKHRyYW5zbGF0ZURpc3RhbmNlID09PSB0aGlzLmNhbGN1bGF0aW9uc18ubWF4VHJhbnNsYXRlWURpc3RhbmNlKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuRklYRURfQVRfTEFTVF9ST1cpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuRklYRURfQVRfTEFTVF9ST1cpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUZsZXhpYmxlUm93RWxlbWVudFN0eWxlc18oZmxleGlibGVFeHBhbnNpb25SYXRpbykge1xuICAgIGlmICh0aGlzLmZpeGVkXykge1xuICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5jYWxjdWxhdGlvbnNfLmZsZXhpYmxlRXhwYW5zaW9uSGVpZ2h0ICogZmxleGlibGVFeHBhbnNpb25SYXRpbztcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGVGb3JGbGV4aWJsZVJvd0VsZW1lbnQoJ2hlaWdodCcsXG4gICAgICAgIGAke2hlaWdodCArIHRoaXMuY2FsY3VsYXRpb25zXy50b29sYmFyUm93SGVpZ2h0fXB4YCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnVzZUZsZXhEZWZhdWx0QmVoYXZpb3JfKSB7XG4gICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRTdHlsZXNEZWZhdWx0QmVoYXZpb3JfKGZsZXhpYmxlRXhwYW5zaW9uUmF0aW8pO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUVsZW1lbnRTdHlsZXNEZWZhdWx0QmVoYXZpb3JfKGZsZXhpYmxlRXhwYW5zaW9uUmF0aW8pIHtcbiAgICBjb25zdCBtYXhUaXRsZVNpemUgPSBNRENUb29sYmFyRm91bmRhdGlvbi5udW1iZXJzLk1BWF9USVRMRV9TSVpFO1xuICAgIGNvbnN0IG1pblRpdGxlU2l6ZSA9IE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLm51bWJlcnMuTUlOX1RJVExFX1NJWkU7XG4gICAgY29uc3QgY3VycmVudFRpdGxlU2l6ZSA9IChtYXhUaXRsZVNpemUgLSBtaW5UaXRsZVNpemUpICogZmxleGlibGVFeHBhbnNpb25SYXRpbyArIG1pblRpdGxlU2l6ZTtcblxuICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGVGb3JUaXRsZUVsZW1lbnQoJ2ZvbnQtc2l6ZScsIGAke2N1cnJlbnRUaXRsZVNpemV9cmVtYCk7XG4gIH1cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgPGhlYWRlciBjbGFzcz1cIm1kYy10b29sYmFyLXdyYXBwZXJcIj5cbiAgICA8IS0tVG9vbGJhci0tPlxuICAgIDxkaXYgXG4gICAgICByZWY9XCJyb290XCIgXG4gICAgICA6Y2xhc3M9XCJyb290Q2xhc3Nlc1wiIFxuICAgICAgOnN0eWxlPVwicm9vdFN0eWxlc1wiPlxuICAgICAgPHNsb3QvPlxuICAgIDwvZGl2PlxuICAgIDwhLS0gRml4ZWQgQWRqdXN0IEVsZW1lbnQtLT5cbiAgICA8ZGl2IFxuICAgICAgdi1pZj1cImZpeGVkIHx8IHdhdGVyZmFsbCB8fCBmaXhlZExhc3Ryb3dcIiBcbiAgICAgIHJlZj1cImZpeGVkLWFkanVzdFwiIFxuICAgICAgOnN0eWxlPVwiYWRqdXN0U3R5bGVzXCJcbiAgICAgIGNsYXNzPVwibWRjLXRvb2xiYXItZml4ZWQtYWRqdXN0XCIvPlxuICA8L2hlYWRlcj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDVG9vbGJhckZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3Rvb2xiYXIvZm91bmRhdGlvbidcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXRvb2xiYXInLFxuICBwcm9wczoge1xuICAgIGZpeGVkOiBCb29sZWFuLFxuICAgIHdhdGVyZmFsbDogQm9vbGVhbixcbiAgICAnZml4ZWQtbGFzdHJvdyc6IEJvb2xlYW4sXG4gICAgZmxleGlibGU6IEJvb2xlYW4sXG4gICAgJ2ZsZXhpYmxlLWRlZmF1bHQnOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IHRydWUgfVxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICByb290Q2xhc3Nlczoge1xuICAgICAgICAnbWRjLXRvb2xiYXInOiB0cnVlLFxuICAgICAgICAnbWRjLXRvb2xiYXItLWZpeGVkJzogdGhpcy5maXhlZCB8fCB0aGlzLndhdGVyZmFsbCB8fCB0aGlzLmZpeGVkTGFzdHJvdyxcbiAgICAgICAgJ21kYy10b29sYmFyLS13YXRlcmZhbGwnOiB0aGlzLndhdGVyZmFsbCxcbiAgICAgICAgJ21kYy10b29sYmFyLS1maXhlZC1sYXN0cm93LW9ubHknOiB0aGlzLmZpeGVkTGFzdHJvdyxcbiAgICAgICAgJ21kYy10b29sYmFyLS1mbGV4aWJsZSc6IHRoaXMuZmxleGlibGUsXG4gICAgICAgICdtZGMtdG9vbGJhci0tZmxleGlibGUtZGVmYXVsdC1iZWhhdmlvcic6XG4gICAgICAgICAgdGhpcy5mbGV4aWJsZSAmJiB0aGlzLmZsZXhpYmxlRGVmYXVsdFxuICAgICAgfSxcbiAgICAgIHJvb3RTdHlsZXM6IHt9LFxuICAgICAgYWRqdXN0U3R5bGVzOiB7XG4gICAgICAgIC8vIHRvIGF2b2lkIHRvcCBtYXJnaW4gY29sbGFwc2Ugd2l0aCA6YWZ0ZXIgZWxcbiAgICAgICAgLy8gMC4xIHB4IHNob3VsZCBiZSByb3VuZGVkIHRvIDBweFxuICAgICAgICAvLyBUT0RPOiBmaW5kIGEgYmV0dGVyIHRyaWNrXG4gICAgICAgIC8vIGhlaWdodDogJzAuMXB4J1xuICAgICAgfSxcbiAgICAgIGZvdW5kYXRpb246IG51bGxcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ1Rvb2xiYXJGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5yb290Q2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgfSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5yb290Q2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5yb290LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJTY3JvbGxIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlclNjcm9sbEhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGdldFZpZXdwb3J0V2lkdGg6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5pbm5lcldpZHRoXG4gICAgICB9LFxuICAgICAgZ2V0Vmlld3BvcnRTY3JvbGxZOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB3aW5kb3cucGFnZVlPZmZzZXRcbiAgICAgIH0sXG4gICAgICBnZXRPZmZzZXRIZWlnaHQ6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMucm9vdC5vZmZzZXRIZWlnaHRcbiAgICAgIH0sXG4gICAgICBnZXRGaXJzdFJvd0VsZW1lbnRPZmZzZXRIZWlnaHQ6ICgpID0+IHtcbiAgICAgICAgbGV0IGVsID0gdGhpcy4kcmVmcy5yb290LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgTURDVG9vbGJhckZvdW5kYXRpb24uc3RyaW5ncy5GSVJTVF9ST1dfU0VMRUNUT1JcbiAgICAgICAgKVxuICAgICAgICByZXR1cm4gZWwgPyBlbC5vZmZzZXRIZWlnaHQgOiB1bmRlZmluZWRcbiAgICAgIH0sXG4gICAgICBub3RpZnlDaGFuZ2U6IGV2dERhdGEgPT4ge1xuICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBldnREYXRhKVxuICAgICAgfSxcbiAgICAgIHNldFN0eWxlOiAocHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnJvb3RTdHlsZXMsIHByb3BlcnR5LCB2YWx1ZSlcbiAgICAgIH0sXG4gICAgICBzZXRTdHlsZUZvclRpdGxlRWxlbWVudDogKHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBsZXQgZWwgPSB0aGlzLiRyZWZzLnJvb3QucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICBNRENUb29sYmFyRm91bmRhdGlvbi5zdHJpbmdzLlRJVExFX1NFTEVDVE9SXG4gICAgICAgIClcbiAgICAgICAgaWYgKGVsKSBlbC5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpXG4gICAgICB9LFxuICAgICAgc2V0U3R5bGVGb3JGbGV4aWJsZVJvd0VsZW1lbnQ6IChwcm9wZXJ0eSwgdmFsdWUpID0+IHtcbiAgICAgICAgbGV0IGVsID0gdGhpcy4kcmVmcy5yb290LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgTURDVG9vbGJhckZvdW5kYXRpb24uc3RyaW5ncy5GSVJTVF9ST1dfU0VMRUNUT1JcbiAgICAgICAgKVxuICAgICAgICBpZiAoZWwpIGVsLnN0eWxlLnNldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSlcbiAgICAgIH0sXG4gICAgICBzZXRTdHlsZUZvckZpeGVkQWRqdXN0RWxlbWVudDogKHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5hZGp1c3RTdHlsZXMsIHByb3BlcnR5LCB2YWx1ZSlcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwibWRjLXRvb2xiYXItcm93IG1kYy10b29sYmFyX19yb3dcIj5cbiAgICA8c2xvdC8+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10b29sYmFyLXJvdydcbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8c2VjdGlvbiBcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgXG4gICAgY2xhc3M9XCJtZGMtdG9vbGJhci1zZWN0aW9uIG1kYy10b29sYmFyX19zZWN0aW9uXCI+XG4gICAgPHNsb3QvPlxuICA8L3NlY3Rpb24+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXRvb2xiYXItc2VjdGlvbicsXG4gIHByb3BzOiB7XG4gICAgJ2FsaWduLXN0YXJ0JzogQm9vbGVhbixcbiAgICAnYWxpZ24tZW5kJzogQm9vbGVhbixcbiAgICAnc2hyaW5rLXRvLWZpdCc6IEJvb2xlYW5cbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge1xuICAgICAgICAnbWRjLXRvb2xiYXJfX3NlY3Rpb24tLWFsaWduLXN0YXJ0JzogdGhpcy5hbGlnblN0YXJ0LFxuICAgICAgICAnbWRjLXRvb2xiYXJfX3NlY3Rpb24tLWFsaWduLWVuZCc6IHRoaXMuYWxpZ25FbmQsXG4gICAgICAgICdtZGMtdG9vbGJhcl9fc2VjdGlvbi0tc2hyaW5rLXRvLWZpdCc6IHRoaXMuc2hyaW5rVG9GaXRcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8YSBcbiAgICA6Y2xhc3M9XCJ7J21hdGVyaWFsLWljb25zJzohIWljb259XCJcbiAgICBjbGFzcz1cIm1kYy10b29sYmFyLW1lbnUtaWNvbiBtZGMtdG9vbGJhcl9fbWVudS1pY29uXCJcbiAgICB2LW9uPVwibGlzdGVuZXJzXCI+XG4gICAgPHNsb3Q+e3sgaWNvbiB9fTwvc2xvdD5cbiAgPC9hPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7IERpc3BhdGNoRXZlbnRNaXhpbiB9IGZyb20gJy4uL2Jhc2UnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10b29sYmFyLW1lbnUtaWNvbicsXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbl0sXG4gIHByb3BzOiB7XG4gICAgaWNvbjogeyB0eXBlOiBTdHJpbmcsIGRlZmF1bHQ6ICdtZW51JyB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8YSBcbiAgICBjbGFzcz1cIm1kYy10b29sYmFyLXRpdGxlIG1kYy10b29sYmFyX190aXRsZVwiIFxuICAgIHYtb249XCJsaXN0ZW5lcnNcIj5cbiAgICA8c2xvdC8+XG4gIDwvYT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBEaXNwYXRjaEV2ZW50TWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtdG9vbGJhci10aXRsZScsXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbl1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8YSBcbiAgICA6Y2xhc3M9XCJ7J21hdGVyaWFsLWljb25zJzohIWljb259XCIgXG4gICAgY2xhc3M9XCJtZGMtdG9vbGJhci1pY29uIG1kYy10b29sYmFyX19pY29uXCJcbiAgICB2LW9uPVwibGlzdGVuZXJzXCI+XG4gICAgPHNsb3Q+e3sgaWNvbiB9fTwvc2xvdD5cbiAgPC9hPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7IERpc3BhdGNoRXZlbnRNaXhpbiB9IGZyb20gJy4uL2Jhc2UnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10b29sYmFyLWljb24nLFxuICBtaXhpbnM6IFtEaXNwYXRjaEV2ZW50TWl4aW5dLFxuICBwcm9wczoge1xuICAgIGljb246IFN0cmluZ1xuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY1Rvb2xiYXIgZnJvbSAnLi9tZGMtdG9vbGJhci52dWUnXG5pbXBvcnQgbWRjVG9vbGJhclJvdyBmcm9tICcuL21kYy10b29sYmFyLXJvdy52dWUnXG5pbXBvcnQgbWRjVG9vbGJhclNlY3Rpb24gZnJvbSAnLi9tZGMtdG9vbGJhci1zZWN0aW9uLnZ1ZSdcbmltcG9ydCBtZGNUb29sYmFyTWVudUljb24gZnJvbSAnLi9tZGMtdG9vbGJhci1tZW51LWljb24udnVlJ1xuaW1wb3J0IG1kY1Rvb2xiYXJUaXRsZSBmcm9tICcuL21kYy10b29sYmFyLXRpdGxlLnZ1ZSdcbmltcG9ydCBtZGNUb29sYmFySWNvbiBmcm9tICcuL21kYy10b29sYmFyLWljb24udnVlJ1xuXG5leHBvcnQge1xuICBtZGNUb29sYmFyLFxuICBtZGNUb29sYmFyUm93LFxuICBtZGNUb29sYmFyU2VjdGlvbixcbiAgbWRjVG9vbGJhck1lbnVJY29uLFxuICBtZGNUb29sYmFyVGl0bGUsXG4gIG1kY1Rvb2xiYXJJY29uXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNUb29sYmFyLFxuICBtZGNUb29sYmFyUm93LFxuICBtZGNUb29sYmFyU2VjdGlvbixcbiAgbWRjVG9vbGJhck1lbnVJY29uLFxuICBtZGNUb29sYmFyVGl0bGUsXG4gIG1kY1Rvb2xiYXJJY29uXG59KVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgRklYRURfQ0xBU1M6ICdtZGMtdG9wLWFwcC1iYXItLWZpeGVkJyxcbiAgRklYRURfU0NST0xMRURfQ0xBU1M6ICdtZGMtdG9wLWFwcC1iYXItLWZpeGVkLXNjcm9sbGVkJyxcbiAgU0hPUlRfQ0xBU1M6ICdtZGMtdG9wLWFwcC1iYXItLXNob3J0JyxcbiAgU0hPUlRfSEFTX0FDVElPTl9JVEVNX0NMQVNTOiAnbWRjLXRvcC1hcHAtYmFyLS1zaG9ydC1oYXMtYWN0aW9uLWl0ZW0nLFxuICBTSE9SVF9DT0xMQVBTRURfQ0xBU1M6ICdtZGMtdG9wLWFwcC1iYXItLXNob3J0LWNvbGxhcHNlZCcsXG59O1xuXG4vKiogQGVudW0ge251bWJlcn0gKi9cbmNvbnN0IG51bWJlcnMgPSB7XG4gIERFQk9VTkNFX1RIUk9UVExFX1JFU0laRV9USU1FX01TOiAxMDAsXG4gIE1BWF9UT1BfQVBQX0JBUl9IRUlHSFQ6IDEyOCxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgQUNUSU9OX0lURU1fU0VMRUNUT1I6ICcubWRjLXRvcC1hcHAtYmFyX19hY3Rpb24taXRlbScsXG4gIE5BVklHQVRJT05fRVZFTlQ6ICdNRENUb3BBcHBCYXI6bmF2JyxcbiAgTkFWSUdBVElPTl9JQ09OX1NFTEVDVE9SOiAnLm1kYy10b3AtYXBwLWJhcl9fbmF2aWdhdGlvbi1pY29uJyxcbiAgUk9PVF9TRUxFQ1RPUjogJy5tZGMtdG9wLWFwcC1iYXInLFxuICBUSVRMRV9TRUxFQ1RPUjogJy5tZGMtdG9wLWFwcC1iYXJfX3RpdGxlJyxcbn07XG5cbmV4cG9ydCB7c3RyaW5ncywgY3NzQ2xhc3NlcywgbnVtYmVyc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFRvcCBBcHAgQmFyXG4gKlxuICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIGFkYXB0ZXIgZXhwZWN0ZWQgYnkgdGhlIGZvdW5kYXRpb24uIEltcGxlbWVudCB0aGlzXG4gKiBhZGFwdGVyIHRvIGludGVncmF0ZSB0aGUgVG9wIEFwcCBCYXIgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1RvcEFwcEJhckFkYXB0ZXIge1xuICAvKipcbiAgICogQWRkcyBhIGNsYXNzIHRvIHRoZSByb290IEVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNsYXNzIGZyb20gdGhlIHJvb3QgRWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJvb3QgRWxlbWVudCBjb250YWlucyB0aGUgZ2l2ZW4gY2xhc3MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogU2V0cyB0aGUgc3BlY2lmaWVkIGlubGluZSBzdHlsZSBwcm9wZXJ0eSBvbiB0aGUgcm9vdCBFbGVtZW50IHRvIHRoZSBnaXZlbiB2YWx1ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0U3R5bGUocHJvcGVydHksIHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBoZWlnaHQgb2YgdGhlIHRvcCBhcHAgYmFyLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRUb3BBcHBCYXJIZWlnaHQoKSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgbmF2aWdhdGlvbiBpY29uIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3Rlck5hdmlnYXRpb25JY29uSW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgb24gdGhlIG5hdmlnYXRpb24gaWNvbiBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3Rlck5hdmlnYXRpb25JY29uSW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIG5hdmlnYXRpb24gaWNvbiBpcyBjbGlja2VkLlxuICAgKi9cbiAgbm90aWZ5TmF2aWdhdGlvbkljb25DbGlja2VkKCkge31cblxuICAvKiogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpfSBoYW5kbGVyICovXG4gIHJlZ2lzdGVyU2Nyb2xsSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCl9IGhhbmRsZXIgKi9cbiAgZGVyZWdpc3RlclNjcm9sbEhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKiogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpfSBoYW5kbGVyICovXG4gIHJlZ2lzdGVyUmVzaXplSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCl9IGhhbmRsZXIgKi9cbiAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKiogQHJldHVybiB7bnVtYmVyfSAqL1xuICBnZXRWaWV3cG9ydFNjcm9sbFkoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtudW1iZXJ9ICovXG4gIGdldFRvdGFsQWN0aW9uSXRlbXMoKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUb3BBcHBCYXJBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7c3RyaW5ncywgY3NzQ2xhc3NlcywgbnVtYmVyc30gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IE1EQ1RvcEFwcEJhckFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENUb3BBcHBCYXJBZGFwdGVyPn1cbiAqL1xuY2xhc3MgTURDVG9wQXBwQmFyQmFzZUZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge251bWJlcn0gKi9cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIHJldHVybiBudW1iZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIE1EQ1RvcEFwcEJhckFkYXB0ZXJ9IGZvciB0eXBpbmcgaW5mb3JtYXRpb24gb24gcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAqIHR5cGVzLlxuICAgKiBAcmV0dXJuIHshTURDVG9wQXBwQmFyQWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RvcEFwcEJhckFkYXB0ZXJ9ICovICh7XG4gICAgICBoYXNDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXRTdHlsZTogKC8qIHByb3BlcnR5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgZ2V0VG9wQXBwQmFySGVpZ2h0OiAoKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyTmF2aWdhdGlvbkljb25JbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3Rlck5hdmlnYXRpb25JY29uSW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIG5vdGlmeU5hdmlnYXRpb25JY29uQ2xpY2tlZDogKCkgPT4ge30sXG4gICAgICByZWdpc3RlclNjcm9sbEhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJTY3JvbGxIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBnZXRWaWV3cG9ydFNjcm9sbFk6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgZ2V0VG90YWxBY3Rpb25JdGVtczogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDVG9wQXBwQmFyQWRhcHRlcn0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoLyoqIEB0eXBlIHshTURDVG9wQXBwQmFyQWRhcHRlcn0gKi8gYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDVG9wQXBwQmFyQmFzZUZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIHRoaXMubmF2Q2xpY2tIYW5kbGVyXyA9ICgpID0+IHRoaXMuYWRhcHRlcl8ubm90aWZ5TmF2aWdhdGlvbkljb25DbGlja2VkKCk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJOYXZpZ2F0aW9uSWNvbkludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLm5hdkNsaWNrSGFuZGxlcl8pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJOYXZpZ2F0aW9uSWNvbkludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLm5hdkNsaWNrSGFuZGxlcl8pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1RvcEFwcEJhckJhc2VGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCBNRENUb3BBcHBCYXJBZGFwdGVyIGZyb20gJy4uL2FkYXB0ZXInO1xuaW1wb3J0IE1EQ1RvcEFwcEJhckJhc2VGb3VuZGF0aW9uIGZyb20gJy4uL2ZvdW5kYXRpb24nO1xuaW1wb3J0IHtjc3NDbGFzc2VzfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENUb3BBcHBCYXJCYXNlRm91bmRhdGlvbjwhTURDU2hvcnRUb3BBcHBCYXJGb3VuZGF0aW9uPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENTaG9ydFRvcEFwcEJhckZvdW5kYXRpb24gZXh0ZW5kcyBNRENUb3BBcHBCYXJCYXNlRm91bmRhdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENUb3BBcHBCYXJBZGFwdGVyfSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoYWRhcHRlcik7XG4gICAgLy8gU3RhdGUgdmFyaWFibGUgZm9yIHRoZSBjdXJyZW50IHRvcCBhcHAgYmFyIHN0YXRlXG4gICAgdGhpcy5pc0NvbGxhcHNlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5zY3JvbGxIYW5kbGVyXyA9ICgpID0+IHRoaXMuc2hvcnRBcHBCYXJTY3JvbGxIYW5kbGVyXygpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBzdXBlci5pbml0KCk7XG4gICAgY29uc3QgaXNBbHdheXNDb2xsYXBzZWQgPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuU0hPUlRfQ09MTEFQU0VEX0NMQVNTKTtcblxuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmdldFRvdGFsQWN0aW9uSXRlbXMoKSA+IDApIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5TSE9SVF9IQVNfQUNUSU9OX0lURU1fQ0xBU1MpO1xuICAgIH1cblxuICAgIGlmICghaXNBbHdheXNDb2xsYXBzZWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJTY3JvbGxIYW5kbGVyKHRoaXMuc2Nyb2xsSGFuZGxlcl8pO1xuICAgICAgdGhpcy5zaG9ydEFwcEJhclNjcm9sbEhhbmRsZXJfKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyU2Nyb2xsSGFuZGxlcih0aGlzLnNjcm9sbEhhbmRsZXJfKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIFNjcm9sbCBoYW5kbGVyIGZvciBhcHBseWluZy9yZW1vdmluZyB0aGUgY29sbGFwc2VkIG1vZGlmaWVyIGNsYXNzXG4gICAqIG9uIHRoZSBzaG9ydCB0b3AgYXBwIGJhci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNob3J0QXBwQmFyU2Nyb2xsSGFuZGxlcl8oKSB7XG4gICAgY29uc3QgY3VycmVudFNjcm9sbCA9IHRoaXMuYWRhcHRlcl8uZ2V0Vmlld3BvcnRTY3JvbGxZKCk7XG5cbiAgICBpZiAoY3VycmVudFNjcm9sbCA8PSAwKSB7XG4gICAgICBpZiAodGhpcy5pc0NvbGxhcHNlZCkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuU0hPUlRfQ09MTEFQU0VEX0NMQVNTKTtcbiAgICAgICAgdGhpcy5pc0NvbGxhcHNlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMuaXNDb2xsYXBzZWQpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLlNIT1JUX0NPTExBUFNFRF9DTEFTUyk7XG4gICAgICAgIHRoaXMuaXNDb2xsYXBzZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENTaG9ydFRvcEFwcEJhckZvdW5kYXRpb247XG4iLCI8dGVtcGxhdGU+XG4gIDxoZWFkZXJcbiAgICByZWY9XCJyb290XCJcbiAgICA6Y2xhc3M9XCJyb290Q2xhc3Nlc1wiXG4gICAgOnN0eWxlPVwicm9vdFN0eWxlc1wiXG4gICAgdi1vbj1cIiRsaXN0ZW5lcnNcIj5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLXRvcC1hcHAtYmFyX19yb3dcIj5cbiAgICAgIDxzZWN0aW9uIGNsYXNzPVwibWRjLXRvcC1hcHAtYmFyX19zZWN0aW9uIG1kYy10b3AtYXBwLWJhcl9fc2VjdGlvbi0tYWxpZ24tc3RhcnRcIj5cbiAgICAgICAgPGFcbiAgICAgICAgICB2LWlmPVwiaGF2ZU5hdmlnYXRpb25JY29uXCJcbiAgICAgICAgICByZWY9XCJuYXZpZ2F0aW9uSWNvblwiXG4gICAgICAgICAgOmNsYXNzPVwibmF2aWNvbkNsYXNzZXNcIlxuICAgICAgICAgIGhyZWY9XCIjXCJcbiAgICAgICAgICB2LW9uPVwibGlzdGVuZXJzXCI+e3sgaWNvbiB9fTwvYT5cbiAgICAgICAgPHNwYW5cbiAgICAgICAgICB2LWlmPVwiISF0aXRsZVwiXG4gICAgICAgICAgY2xhc3M9XCJtZGMtdG9wLWFwcC1iYXJfX3RpdGxlXCI+e3sgdGl0bGUgfX08L3NwYW4+XG4gICAgICA8L3NlY3Rpb24+XG4gICAgICA8c2VjdGlvblxuICAgICAgICB2LWlmPVwiJHNsb3RzLmRlZmF1bHRcIlxuICAgICAgICBjbGFzcz1cIm1kYy10b3AtYXBwLWJhcl9fc2VjdGlvbiBtZGMtdG9wLWFwcC1iYXJfX3NlY3Rpb24tLWFsaWduLWVuZFwiPlxuICAgICAgICA8c2xvdC8+XG4gICAgICA8L3NlY3Rpb24+XG4gICAgPC9kaXY+XG4gICAgPGRpdlxuICAgICAgdi1pZj1cIiRzbG90cy50YWJzXCJcbiAgICAgIGNsYXNzPVwibWRjLXRvcC1hcHAtYmFyX19yb3dcIj5cbiAgICAgIDxzbG90IG5hbWU9XCJ0YWJzXCIvPlxuICAgIDwvZGl2PlxuICA8L2hlYWRlcj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDVG9wQXBwQmFyRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvdG9wLWFwcC1iYXIvZm91bmRhdGlvbidcbmltcG9ydCBNRENTaG9ydFRvcEFwcEJhckZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3RvcC1hcHAtYmFyL3Nob3J0L2ZvdW5kYXRpb24nXG5pbXBvcnQgeyBEaXNwYXRjaEV2ZW50TWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtdG9wLWFwcC1iYXInLFxuICBtaXhpbnM6IFtEaXNwYXRjaEV2ZW50TWl4aW5dLFxuICBwcm9wczoge1xuICAgIHNob3J0OiBCb29sZWFuLFxuICAgIHNob3J0Q29sbGFwc2VkOiBCb29sZWFuLFxuICAgIHByb21pbmVudDogQm9vbGVhbixcbiAgICBmaXhlZDogQm9vbGVhbixcbiAgICB0aXRsZTogU3RyaW5nLFxuICAgIGljb246IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdtZW51J1xuICAgIH0sXG4gICAgaWNvbkNsYXNzZXM6IE9iamVjdCxcbiAgICBkZW5zZTogQm9vbGVhblxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICByb290U3R5bGVzOiB7fSxcbiAgICAgIHJvb3RDbGFzc2VzOiB7XG4gICAgICAgICdtZGMtdG9wLWFwcC1iYXInOiB0cnVlLFxuICAgICAgICAnbWRjLXRvcC1hcHAtYmFyLS1kZW5zZSc6IHRoaXMuZGVuc2UsXG4gICAgICAgICdtZGMtdG9wLWFwcC1iYXItLXNob3J0JzogdGhpcy5zaG9ydCxcbiAgICAgICAgJ21kYy10b3AtYXBwLWJhci0tc2hvcnQtY29sbGFwc2VkJzogdGhpcy5zaG9ydENvbGxhcHNlZCxcbiAgICAgICAgJ21kYy10b3AtYXBwLWJhci0tcHJvbWluZW50JzogdGhpcy5wcm9taW5lbnQsXG4gICAgICAgICdtZGMtdG9wLWFwcC1iYXItLWZpeGVkJzogdGhpcy5maXhlZFxuICAgICAgfSxcbiAgICAgIGZvdW5kYXRpb246IG51bGxcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaGF2ZU5hdmlnYXRpb25JY29uKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5pY29uIHx8IHRoaXMuaWNvbkNsYXNzZXNcbiAgICB9LFxuICAgIG5hdmljb25DbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21kYy10b3AtYXBwLWJhcl9fbmF2aWdhdGlvbi1pY29uJzogdHJ1ZSxcbiAgICAgICAgJ21hdGVyaWFsLWljb25zJzogISF0aGlzLmljb24sXG4gICAgICAgIC4uLnRoaXMuaWNvbkNsYXNzZXNcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgY29uc3QgYWRhcHRlciA9IHtcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5yb290Q2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgfSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5yb290Q2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5yb290LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgc2V0U3R5bGU6IChwcm9wZXJ0eSwgdmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMucm9vdFN0eWxlcywgcHJvcGVydHksIHZhbHVlKVxuICAgICAgfSxcbiAgICAgIGdldFRvcEFwcEJhckhlaWdodDogKCkgPT4gdGhpcy4kZWwuY2xpZW50SGVpZ2h0LFxuICAgICAgcmVnaXN0ZXJOYXZpZ2F0aW9uSWNvbkludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuJHJlZnMubmF2aWdhdGlvbkljb24pIHtcbiAgICAgICAgICB0aGlzLiRyZWZzLm5hdmlnYXRpb25JY29uLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJOYXZpZ2F0aW9uSWNvbkludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuJHJlZnMubmF2aWdhdGlvbkljb24pIHtcbiAgICAgICAgICB0aGlzLiRyZWZzLm5hdmlnYXRpb25JY29uLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG5vdGlmeU5hdmlnYXRpb25JY29uQ2xpY2tlZDogKCkgPT4ge1xuICAgICAgICB0aGlzLiRlbWl0KCduYXYnKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyU2Nyb2xsSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJTY3JvbGxIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiBoYW5kbGVyID0+XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiBoYW5kbGVyID0+XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKSxcblxuICAgICAgZ2V0Vmlld3BvcnRTY3JvbGxZOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB3aW5kb3cucGFnZVlPZmZzZXRcbiAgICAgIH0sXG4gICAgICBnZXRUb3RhbEFjdGlvbkl0ZW1zOiAoKSA9PlxuICAgICAgICB0aGlzLiRyZWZzLnJvb3QucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICAgICBNRENUb3BBcHBCYXJGb3VuZGF0aW9uLnN0cmluZ3MuQUNUSU9OX0lURU1fU0VMRUNUT1JcbiAgICAgICAgKS5sZW5ndGhcbiAgICB9XG5cbiAgICB0aGlzLmZvdW5kYXRpb24gPSB0aGlzLnNob3J0XG4gICAgICA/IG5ldyBNRENTaG9ydFRvcEFwcEJhckZvdW5kYXRpb24oYWRhcHRlcilcbiAgICAgIDogbmV3IE1EQ1RvcEFwcEJhckZvdW5kYXRpb24oYWRhcHRlcilcblxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8YVxuICAgIDpjbGFzcz1cImFjdGlvbmljb25DbGFzc2VzXCJcbiAgICBocmVmPVwiI1wiXG4gICAgY2xhc3M9XCJtZGMtdG9wLWFwcC1iYXItYWN0aW9uIG1kYy10b3AtYXBwLWJhci0tYWN0aW9uIG1kYy10b3AtYXBwLWJhcl9fYWN0aW9uLWl0ZW1cIlxuICAgIHYtb249XCJsaXN0ZW5lcnNcIj5cbiAgICA8c2xvdD57eyBpY29uIH19PC9zbG90PlxuICA8L2E+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgRGlzcGF0Y2hFdmVudE1peGluIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCB7IFJpcHBsZU1peGluIH0gZnJvbSAnLi4vcmlwcGxlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtdG9wLWFwcC1iYXItYWN0aW9uJyxcbiAgbWl4aW5zOiBbRGlzcGF0Y2hFdmVudE1peGluLCBSaXBwbGVNaXhpbl0sXG4gIHByb3BzOiB7XG4gICAgaWNvbjogU3RyaW5nLFxuICAgIGljb25DbGFzc2VzOiBPYmplY3RcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBhY3Rpb25pY29uQ2xhc3NlcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdtYXRlcmlhbC1pY29ucyc6ICEhdGhpcy5pY29uLFxuICAgICAgICAuLi50aGlzLmljb25DbGFzc2VzXG4gICAgICB9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY1RvcEFwcEJhciBmcm9tICcuL21kYy10b3AtYXBwLWJhci52dWUnXG5pbXBvcnQgbWRjVG9wQXBwQmFyQWN0aW9uIGZyb20gJy4vbWRjLXRvcC1hcHAtYmFyLWFjdGlvbi52dWUnXG5cbmV4cG9ydCB7IG1kY1RvcEFwcEJhciwgbWRjVG9wQXBwQmFyQWN0aW9uIH1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY1RvcEFwcEJhcixcbiAgbWRjVG9wQXBwQmFyQWN0aW9uXG59KVxuIiwiY29uc3QgdHlwb3MgPSBbXG4gICdoZWFkbGluZTEnLFxuICAnaGVhZGxpbmUyJyxcbiAgJ2hlYWRsaW5lMycsXG4gICdoZWFkbGluZTQnLFxuICAnaGVhZGxpbmU1JyxcbiAgJ2hlYWRsaW5lNicsXG4gICdzdWJ0aXRsZTEnLFxuICAnc3VidGl0bGUyJyxcbiAgJ2JvZHkxJyxcbiAgJ2JvZHkyJyxcbiAgJ2NhcHRpb24nLFxuICAnYnV0dG9uJyxcbiAgJ292ZXJsaW5lJ1xuXVxuXG5leHBvcnQgY29uc3QgbWRjVHlwb01peGluID0gbmFtZSA9PiB7XG4gIHJldHVybiB7XG4gICAgcmVuZGVyKGNyZWF0ZUVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KFxuICAgICAgICB0aGlzLnRhZyxcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzOiB7XG4gICAgICAgICAgICAnbWRjLXR5cG8nOiB0cnVlLFxuICAgICAgICAgICAgW25hbWVdOiB0cnVlLFxuICAgICAgICAgICAgW2BtZGMtdHlwb2dyYXBoeS0tJHt0aGlzLnR5cG99YF06IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIGF0dHJzOiB0aGlzLiRhdHRycyxcbiAgICAgICAgICBvbjogdGhpcy4kbGlzdGVuZXJzXG4gICAgICAgIH0sXG4gICAgICAgIHRoaXMuJHNsb3RzLmRlZmF1bHRcbiAgICAgIClcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1kY1R5cG9Qcm9wTWl4aW4oZGVmYXVsdFRhZywgZGVmYXVsdFR5cG8sIHZhbGlkVHlwb3MpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9wczoge1xuICAgICAgdGFnOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogZGVmYXVsdFRhZ1xuICAgICAgfSxcbiAgICAgIHR5cG86IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBkZWZhdWx0OiBkZWZhdWx0VHlwbyxcbiAgICAgICAgdmFsaWRhdG9yOiB2YWx1ZSA9PiB2YWxpZFR5cG9zLmluZGV4T2YodmFsdWUpICE9PSAtMVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgbWRjVGV4dFNlY3Rpb24gPSB7XG4gIG5hbWU6ICdtZGMtdGV4dC1zZWN0aW9uJyxcbiAgcHJvcHM6IHtcbiAgICB0YWc6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIGRlZmF1bHQ6ICdzZWN0aW9uJ1xuICAgIH1cbiAgfSxcbiAgcmVuZGVyKGNyZWF0ZUVsZW1lbnQpIHtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudChcbiAgICAgIHRoaXMudGFnLFxuICAgICAge1xuICAgICAgICBjbGFzczoge1xuICAgICAgICAgICdtZGMtdHlwb2dyYXBoeSc6IHRydWUsXG4gICAgICAgICAgJ21kYy10ZXh0LXNlY3Rpb24nOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGF0dHJzOiB0aGlzLiRhdHRycyxcbiAgICAgICAgb246IHRoaXMuJGxpc3RlbmVyc1xuICAgICAgfSxcbiAgICAgIHRoaXMuJHNsb3RzLmRlZmF1bHRcbiAgICApXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG1kY1RleHQgPSB7XG4gIG5hbWU6ICdtZGMtdGV4dCcsXG4gIG1peGluczogW21kY1R5cG9NaXhpbignbWRjLXRleHQnKSwgbWRjVHlwb1Byb3BNaXhpbigncCcsICdib2R5MScsIHR5cG9zKV1cbn1cblxuZXhwb3J0IGNvbnN0IG1kY0Rpc3BsYXkgPSB7XG4gIG5hbWU6ICdtZGMtZGlzcGxheScsXG4gIG1peGluczogW1xuICAgIG1kY1R5cG9NaXhpbignbWRjLWRpc3BsYXknKSxcbiAgICBtZGNUeXBvUHJvcE1peGluKCdoMScsICdoZWFkbGluZTQnLCBbXG4gICAgICAnaGVhZGxpbmU0JyxcbiAgICAgICdoZWFkbGluZTMnLFxuICAgICAgJ2hlYWRsaW5lMicsXG4gICAgICAnaGVhZGxpbmUxJ1xuICAgIF0pXG4gIF1cbn1cblxuZXhwb3J0IGNvbnN0IG1kY0hlYWRsaW5lID0ge1xuICBuYW1lOiAnbWRjLWhlYWRsaW5lJyxcbiAgbWl4aW5zOiBbXG4gICAgbWRjVHlwb01peGluKCdtZGMtaGVhZGxpbmUnKSxcbiAgICBtZGNUeXBvUHJvcE1peGluKCdoMicsICdoZWFkbGluZTUnLCBbJ2hlYWRsaW5lNSddKVxuICBdXG59XG5cbmV4cG9ydCBjb25zdCBtZGNUaXRsZSA9IHtcbiAgbmFtZTogJ21kYy10aXRsZScsXG4gIG1peGluczogW1xuICAgIG1kY1R5cG9NaXhpbignbWRjLXRpdGxlJyksXG4gICAgbWRjVHlwb1Byb3BNaXhpbignaDMnLCAnaGVhZGxpbmU2JywgWydoZWFkbGluZTYnXSlcbiAgXVxufVxuXG5leHBvcnQgY29uc3QgbWRjU3ViSGVhZGluZyA9IHtcbiAgbmFtZTogJ21kYy1zdWJoZWFkaW5nJyxcbiAgbWl4aW5zOiBbXG4gICAgbWRjVHlwb01peGluKCdtZGMtc3ViaGVhZGluZycpLFxuICAgIG1kY1R5cG9Qcm9wTWl4aW4oJ2g0JywgJ3N1YnRpdGxlMicsIFsnc3VidGl0bGUxJywgJ3N1YnRpdGxlMiddKVxuICBdXG59XG5cbmV4cG9ydCBjb25zdCBtZGNCb2R5ID0ge1xuICBuYW1lOiAnbWRjLWJvZHknLFxuICBtaXhpbnM6IFtcbiAgICBtZGNUeXBvTWl4aW4oJ21kYy1ib2R5JyksXG4gICAgbWRjVHlwb1Byb3BNaXhpbigncCcsICdib2R5MScsIFsnYm9keTEnLCAnYm9keTInXSlcbiAgXVxufVxuXG5leHBvcnQgY29uc3QgbWRjQ2FwdGlvbiA9IHtcbiAgbmFtZTogJ21kYy1jYXB0aW9uJyxcbiAgbWl4aW5zOiBbXG4gICAgbWRjVHlwb01peGluKCdtZGMtY2FwdGlvbicpLFxuICAgIG1kY1R5cG9Qcm9wTWl4aW4oJ3NwYW4nLCAnY2FwdGlvbicsIFsnY2FwdGlvbiddKVxuICBdXG59XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCB7XG4gIG1kY1RleHRTZWN0aW9uLFxuICBtZGNUZXh0LFxuICBtZGNCb2R5LFxuICBtZGNDYXB0aW9uLFxuICBtZGNEaXNwbGF5LFxuICBtZGNIZWFkbGluZSxcbiAgbWRjU3ViSGVhZGluZyxcbiAgbWRjVGl0bGVcbn0gZnJvbSAnLi9tZGMtdHlwb2dyYXBoeS5qcydcblxuZXhwb3J0IHtcbiAgbWRjVGV4dFNlY3Rpb24sXG4gIG1kY1RleHQsXG4gIG1kY0JvZHksXG4gIG1kY0NhcHRpb24sXG4gIG1kY0Rpc3BsYXksXG4gIG1kY0hlYWRsaW5lLFxuICBtZGNTdWJIZWFkaW5nLFxuICBtZGNUaXRsZVxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjVGV4dFNlY3Rpb24sXG4gIG1kY1RleHQsXG4gIG1kY0JvZHksXG4gIG1kY0NhcHRpb24sXG4gIG1kY0Rpc3BsYXksXG4gIG1kY0hlYWRsaW5lLFxuICBtZGNTdWJIZWFkaW5nLFxuICBtZGNUaXRsZVxufSlcbiIsIi8vXG4vLyB2dWUgUGx1Z0luXG4vL1xuaW1wb3J0IFZ1ZU1EQ0J1dHRvbiBmcm9tICcuL2J1dHRvbidcbmltcG9ydCBWdWVNRENDYXJkIGZyb20gJy4vY2FyZCdcbmltcG9ydCBWdWVNRENDaGVja2JveCBmcm9tICcuL2NoZWNrYm94J1xuaW1wb3J0IFZ1ZU1EQ0NoaXBTZXQgZnJvbSAnLi9jaGlwcydcbmltcG9ydCBWdWVNRENEaWFsb2cgZnJvbSAnLi9kaWFsb2cnXG5pbXBvcnQgVnVlTURDRHJhd2VyIGZyb20gJy4vZHJhd2VyJ1xuaW1wb3J0IFZ1ZU1EQ0VsZXZhdGlvbiBmcm9tICcuL2VsZXZhdGlvbidcbmltcG9ydCBWdWVNRENGYWIgZnJvbSAnLi9mYWInXG5pbXBvcnQgVnVlTURDR3JpZExpc3QgZnJvbSAnLi9ncmlkLWxpc3QnXG5pbXBvcnQgVnVlTURDSWNvbiBmcm9tICcuL2ljb24nXG5pbXBvcnQgVnVlTURDSWNvblRvZ2dsZSBmcm9tICcuL2ljb24tdG9nZ2xlJ1xuaW1wb3J0IFZ1ZU1EQ0xheW91dEFwcCBmcm9tICcuL2xheW91dC1hcHAnXG5pbXBvcnQgVnVlTURDTGF5b3V0R3JpZCBmcm9tICcuL2xheW91dC1ncmlkJ1xuaW1wb3J0IFZ1ZU1EQ0xpbmVhclByb2dyZXNzIGZyb20gJy4vbGluZWFyLXByb2dyZXNzJ1xuaW1wb3J0IFZ1ZU1EQ0xpc3QgZnJvbSAnLi9saXN0J1xuaW1wb3J0IFZ1ZU1EQ01lbnUgZnJvbSAnLi9tZW51J1xuaW1wb3J0IFZ1ZU1EQ1JhZGlvIGZyb20gJy4vcmFkaW8nXG5pbXBvcnQgVnVlTURDUmlwcGxlIGZyb20gJy4vcmlwcGxlJ1xuaW1wb3J0IFZ1ZU1EQ1NlbGVjdCBmcm9tICcuL3NlbGVjdCdcbmltcG9ydCBWdWVNRENTbGlkZXIgZnJvbSAnLi9zbGlkZXInXG5pbXBvcnQgVnVlTURDU25hY2tiYXIgZnJvbSAnLi9zbmFja2JhcidcbmltcG9ydCBWdWVNRENTd2l0Y2ggZnJvbSAnLi9zd2l0Y2gnXG5pbXBvcnQgVnVlTURDVGFicyBmcm9tICcuL3RhYnMnXG5pbXBvcnQgVnVlTURDVGV4dGZpZWxkIGZyb20gJy4vdGV4dGZpZWxkJ1xuaW1wb3J0IFZ1ZU1EQ1RoZW1lIGZyb20gJy4vdGhlbWUnXG5pbXBvcnQgVnVlTURDVG9vbGJhciBmcm9tICcuL3Rvb2xiYXInXG5pbXBvcnQgVnVlTURDVG9wQXBwQmFyIGZyb20gJy4vdG9wLWFwcC1iYXInXG5pbXBvcnQgVnVlTURDVHlwb2dyYXBoeSBmcm9tICcuL3R5cG9ncmFwaHknXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgdmVyc2lvbjogJ19fVkVSU0lPTl9fJyxcbiAgaW5zdGFsbCh2bSkge1xuICAgIHZtLnVzZShWdWVNRENCdXR0b24pXG4gICAgdm0udXNlKFZ1ZU1EQ0NhcmQpXG4gICAgdm0udXNlKFZ1ZU1EQ0NoZWNrYm94KVxuICAgIHZtLnVzZShWdWVNRENDaGlwU2V0KVxuICAgIHZtLnVzZShWdWVNRENEaWFsb2cpXG4gICAgdm0udXNlKFZ1ZU1EQ0RyYXdlcilcbiAgICB2bS51c2UoVnVlTURDRWxldmF0aW9uKVxuICAgIHZtLnVzZShWdWVNRENGYWIpXG4gICAgdm0udXNlKFZ1ZU1EQ0dyaWRMaXN0KVxuICAgIHZtLnVzZShWdWVNRENJY29uKVxuICAgIHZtLnVzZShWdWVNRENJY29uVG9nZ2xlKVxuICAgIHZtLnVzZShWdWVNRENMYXlvdXRBcHApXG4gICAgdm0udXNlKFZ1ZU1EQ0xheW91dEdyaWQpXG4gICAgdm0udXNlKFZ1ZU1EQ0xpbmVhclByb2dyZXNzKVxuICAgIHZtLnVzZShWdWVNRENMaXN0KVxuICAgIHZtLnVzZShWdWVNRENNZW51KVxuICAgIHZtLnVzZShWdWVNRENSYWRpbylcbiAgICB2bS51c2UoVnVlTURDUmlwcGxlKVxuICAgIHZtLnVzZShWdWVNRENTZWxlY3QpXG4gICAgdm0udXNlKFZ1ZU1EQ1NsaWRlcilcbiAgICB2bS51c2UoVnVlTURDU25hY2tiYXIpXG4gICAgdm0udXNlKFZ1ZU1EQ1N3aXRjaClcbiAgICB2bS51c2UoVnVlTURDVGFicylcbiAgICB2bS51c2UoVnVlTURDVGV4dGZpZWxkKVxuICAgIHZtLnVzZShWdWVNRENUaGVtZSlcbiAgICB2bS51c2UoVnVlTURDVG9vbGJhcilcbiAgICB2bS51c2UoVnVlTURDVG9wQXBwQmFyKVxuICAgIHZtLnVzZShWdWVNRENUeXBvZ3JhcGh5KVxuICB9XG59XG4iLCJpbXBvcnQgJy4vc3R5bGVzLnNjc3MnXG5pbXBvcnQgeyBhdXRvSW5pdCB9IGZyb20gJy4vYmFzZSdcbmltcG9ydCBwbHVnaW4gZnJvbSAnLi9pbmRleC5qcydcbmV4cG9ydCBkZWZhdWx0IHBsdWdpblxuXG5hdXRvSW5pdChwbHVnaW4pXG4iXSwibmFtZXMiOlsic3VwcG9ydHNQYXNzaXZlXyIsImFwcGx5UGFzc2l2ZSIsImdsb2JhbE9iaiIsIndpbmRvdyIsImZvcmNlUmVmcmVzaCIsInVuZGVmaW5lZCIsImlzU3VwcG9ydGVkIiwiZG9jdW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwicGFzc2l2ZSIsImUiLCJhdXRvSW5pdCIsInBsdWdpbiIsIl9WdWUiLCJWdWUiLCJnbG9iYWwiLCJ1c2UiLCJCYXNlUGx1Z2luIiwiY29tcG9uZW50cyIsInZlcnNpb24iLCJpbnN0YWxsIiwia2V5IiwiY29tcG9uZW50Iiwidm0iLCJuYW1lIiwiQ3VzdG9tRWxlbWVudCIsImZ1bmN0aW9uYWwiLCJyZW5kZXIiLCJjcmVhdGVFbGVtZW50IiwiY29udGV4dCIsInByb3BzIiwiaXMiLCJ0YWciLCJkYXRhIiwiY2hpbGRyZW4iLCJDdXN0b21FbGVtZW50TWl4aW4iLCJDdXN0b21MaW5rIiwidHlwZSIsIlN0cmluZyIsImRlZmF1bHQiLCJsaW5rIiwiT2JqZWN0IiwiaCIsImVsZW1lbnQiLCJiYWJlbEhlbHBlcnMuZXh0ZW5kcyIsInBhcmVudCIsIiRyb3V0ZXIiLCIkcm9vdCIsIiRvcHRpb25zIiwib24iLCJjbGljayIsIm5hdGl2ZU9uIiwiQ3VzdG9tTGlua01peGluIiwidG8iLCJleGFjdCIsIkJvb2xlYW4iLCJhcHBlbmQiLCJyZXBsYWNlIiwiYWN0aXZlQ2xhc3MiLCJleGFjdEFjdGl2ZUNsYXNzIiwiY29tcHV0ZWQiLCJlbWl0Q3VzdG9tRXZlbnQiLCJlbCIsImV2dFR5cGUiLCJldnREYXRhIiwic2hvdWxkQnViYmxlIiwiZXZ0IiwiQ3VzdG9tRXZlbnQiLCJkZXRhaWwiLCJidWJibGVzIiwiY3JlYXRlRXZlbnQiLCJpbml0Q3VzdG9tRXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwiQ3VzdG9tQnV0dG9uIiwiYXR0cnMiLCJyb2xlIiwiaHJlZiIsIkN1c3RvbUJ1dHRvbk1peGluIiwiZGlzYWJsZWQiLCJleHRyYWN0SWNvblByb3AiLCJpY29uUHJvcCIsImNsYXNzZXMiLCJjb250ZW50IiwiQXJyYXkiLCJyZWR1Y2UiLCJyZXN1bHQiLCJ2YWx1ZSIsImNsYXNzTmFtZSIsInNwbGl0IiwidGV4dENvbnRlbnQiLCJEaXNwYXRjaEV2ZW50TWl4aW4iLCJldmVudCIsIm1ldGhvZHMiLCIkZW1pdCIsInRhcmdldCIsImV2ZW50VGFyZ2V0IiwiYXJncyIsImV2ZW50QXJncyIsImxpc3RlbmVycyIsIiRsaXN0ZW5lcnMiLCJEaXNwYXRjaEZvY3VzTWl4aW4iLCJoYXNGb2N1cyIsIm9uTW91c2VEb3duIiwiX2FjdGl2ZSIsIm9uTW91c2VVcCIsIm9uRm9jdXNFdmVudCIsInNldFRpbWVvdXQiLCJkaXNwYXRjaEZvY3VzRXZlbnQiLCJvbkJsdXJFdmVudCIsIiRlbCIsImFjdGl2ZUVsZW1lbnQiLCJjb250YWlucyIsIm1vdW50ZWQiLCJiZWZvcmVEZXN0cm95IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInNjb3BlIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwidG9TdHJpbmciLCJWTUFVbmlxdWVJZE1peGluIiwiYmVmb3JlQ3JlYXRlIiwidm1hX3VpZF8iLCJfdWlkIiwiTURDRm91bmRhdGlvbiIsImFkYXB0ZXIiLCJhZGFwdGVyXyIsIk1EQ1JpcHBsZUFkYXB0ZXIiLCJoYW5kbGVyIiwidmFyTmFtZSIsImNzc0NsYXNzZXMiLCJST09UIiwiVU5CT1VOREVEIiwiQkdfRk9DVVNFRCIsIkZHX0FDVElWQVRJT04iLCJGR19ERUFDVElWQVRJT04iLCJzdHJpbmdzIiwiVkFSX0xFRlQiLCJWQVJfVE9QIiwiVkFSX0ZHX1NJWkUiLCJWQVJfRkdfU0NBTEUiLCJWQVJfRkdfVFJBTlNMQVRFX1NUQVJUIiwiVkFSX0ZHX1RSQU5TTEFURV9FTkQiLCJudW1iZXJzIiwiUEFERElORyIsIklOSVRJQUxfT1JJR0lOX1NDQUxFIiwiREVBQ1RJVkFUSU9OX1RJTUVPVVRfTVMiLCJGR19ERUFDVElWQVRJT05fTVMiLCJUQVBfREVMQVlfTVMiLCJzdXBwb3J0c0Nzc1ZhcmlhYmxlc18iLCJkZXRlY3RFZGdlUHNldWRvVmFyQnVnIiwid2luZG93T2JqIiwibm9kZSIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImNvbXB1dGVkU3R5bGUiLCJnZXRDb21wdXRlZFN0eWxlIiwiaGFzUHNldWRvVmFyQnVnIiwiYm9yZGVyVG9wU3R5bGUiLCJyZW1vdmUiLCJzdXBwb3J0c0Nzc1ZhcmlhYmxlcyIsInN1cHBvcnRzRnVuY3Rpb25QcmVzZW50IiwiQ1NTIiwic3VwcG9ydHMiLCJleHBsaWNpdGx5U3VwcG9ydHNDc3NWYXJzIiwid2VBcmVGZWF0dXJlRGV0ZWN0aW5nU2FmYXJpMTBwbHVzIiwiZ2V0TWF0Y2hlc1Byb3BlcnR5IiwiSFRNTEVsZW1lbnRQcm90b3R5cGUiLCJmaWx0ZXIiLCJwIiwicG9wIiwiZ2V0Tm9ybWFsaXplZEV2ZW50Q29vcmRzIiwiZXYiLCJwYWdlT2Zmc2V0IiwiY2xpZW50UmVjdCIsIngiLCJ5IiwiZG9jdW1lbnRYIiwibGVmdCIsImRvY3VtZW50WSIsInRvcCIsIm5vcm1hbGl6ZWRYIiwibm9ybWFsaXplZFkiLCJjaGFuZ2VkVG91Y2hlcyIsInBhZ2VYIiwicGFnZVkiLCJBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTIiwiUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVMiLCJhY3RpdmF0ZWRUYXJnZXRzIiwiTURDUmlwcGxlRm91bmRhdGlvbiIsImJyb3dzZXJTdXBwb3J0c0Nzc1ZhcnMiLCJpc1VuYm91bmRlZCIsImlzU3VyZmFjZUFjdGl2ZSIsImlzU3VyZmFjZURpc2FibGVkIiwiYWRkQ2xhc3MiLCJyZW1vdmVDbGFzcyIsImNvbnRhaW5zRXZlbnRUYXJnZXQiLCJyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIiLCJyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyIiwiZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyIiwicmVnaXN0ZXJSZXNpemVIYW5kbGVyIiwiZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXIiLCJ1cGRhdGVDc3NWYXJpYWJsZSIsImNvbXB1dGVCb3VuZGluZ1JlY3QiLCJnZXRXaW5kb3dQYWdlT2Zmc2V0IiwiZGVmYXVsdEFkYXB0ZXIiLCJsYXlvdXRGcmFtZV8iLCJmcmFtZV8iLCJ3aWR0aCIsImhlaWdodCIsImFjdGl2YXRpb25TdGF0ZV8iLCJkZWZhdWx0QWN0aXZhdGlvblN0YXRlXyIsImluaXRpYWxTaXplXyIsIm1heFJhZGl1c18iLCJhY3RpdmF0ZUhhbmRsZXJfIiwiYWN0aXZhdGVfIiwiZGVhY3RpdmF0ZUhhbmRsZXJfIiwiZGVhY3RpdmF0ZV8iLCJmb2N1c0hhbmRsZXJfIiwiaGFuZGxlRm9jdXMiLCJibHVySGFuZGxlcl8iLCJoYW5kbGVCbHVyIiwicmVzaXplSGFuZGxlcl8iLCJsYXlvdXQiLCJ1bmJvdW5kZWRDb29yZHNfIiwiZmdTY2FsZV8iLCJhY3RpdmF0aW9uVGltZXJfIiwiZmdEZWFjdGl2YXRpb25SZW1vdmFsVGltZXJfIiwiYWN0aXZhdGlvbkFuaW1hdGlvbkhhc0VuZGVkXyIsImFjdGl2YXRpb25UaW1lckNhbGxiYWNrXyIsInJ1bkRlYWN0aXZhdGlvblVYTG9naWNJZlJlYWR5XyIsInByZXZpb3VzQWN0aXZhdGlvbkV2ZW50XyIsImlzQWN0aXZhdGVkIiwiaGFzRGVhY3RpdmF0aW9uVVhSdW4iLCJ3YXNBY3RpdmF0ZWRCeVBvaW50ZXIiLCJ3YXNFbGVtZW50TWFkZUFjdGl2ZSIsImFjdGl2YXRpb25FdmVudCIsImlzUHJvZ3JhbW1hdGljIiwiaXNTdXBwb3J0ZWRfIiwicmVnaXN0ZXJSb290SGFuZGxlcnNfIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibGF5b3V0SW50ZXJuYWxfIiwiY2xlYXJUaW1lb3V0IiwiZGVyZWdpc3RlclJvb3RIYW5kbGVyc18iLCJkZXJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfIiwicmVtb3ZlQ3NzVmFyc18iLCJmb3JFYWNoIiwia2V5cyIsImsiLCJpbmRleE9mIiwiYWN0aXZhdGlvblN0YXRlIiwicHJldmlvdXNBY3RpdmF0aW9uRXZlbnQiLCJpc1NhbWVJbnRlcmFjdGlvbiIsImhhc0FjdGl2YXRlZENoaWxkIiwibGVuZ3RoIiwic29tZSIsInJlc2V0QWN0aXZhdGlvblN0YXRlXyIsInB1c2giLCJyZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXyIsImNoZWNrRWxlbWVudE1hZGVBY3RpdmVfIiwiYW5pbWF0ZUFjdGl2YXRpb25fIiwia2V5Q29kZSIsInRyYW5zbGF0ZVN0YXJ0IiwidHJhbnNsYXRlRW5kIiwiZ2V0RmdUcmFuc2xhdGlvbkNvb3JkaW5hdGVzXyIsInN0YXJ0UG9pbnQiLCJlbmRQb2ludCIsInJtQm91bmRlZEFjdGl2YXRpb25DbGFzc2VzXyIsImFjdGl2YXRpb25IYXNFbmRlZCIsInN0YXRlIiwiZXZ0T2JqZWN0IiwiYW5pbWF0ZURlYWN0aXZhdGlvbl8iLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIm1heERpbSIsIm1heCIsImdldEJvdW5kZWRSYWRpdXMiLCJoeXBvdGVudXNlIiwic3FydCIsInBvdyIsInVwZGF0ZUxheW91dENzc1ZhcnNfIiwicm91bmQiLCJ1bmJvdW5kZWQiLCJSaXBwbGVCYXNlIiwicmVmIiwiTUFUQ0hFUyIsIl9tYXRjaGVzIiwiSFRNTEVsZW1lbnQiLCJwcm90b3R5cGUiLCJvcHRpb25zIiwiJHNldCIsIiRkZWxldGUiLCJkb2N1bWVudEVsZW1lbnQiLCJzdHlsZXMiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJwYWdlWE9mZnNldCIsInBhZ2VZT2Zmc2V0IiwiUmlwcGxlTWl4aW4iLCJyaXBwbGUiLCJpbml0IiwiZGVzdHJveSIsIm1peGlucyIsIm1kY1JpcHBsZSIsImV4dGVuZHMiLCJtZGNCdXR0b25CYXNlIiwicmFpc2VkIiwidW5lbGV2YXRlZCIsIm91dGxpbmVkIiwiZGVuc2UiLCJ3YXRjaCIsIm1kY0J1dHRvbiIsInNyYyIsInNxdWFyZSIsImJhY2tncm91bmRJbWFnZSIsInRpdGxlIiwic3VidGl0bGUiLCJsYXJnZSIsImZ1bGxCbGVlZCIsImljb24iLCJtZGNDYXJkIiwibWRjQ2FyZFByaW1hcnlBY3Rpb24iLCJtZGNDYXJkTWVkaWEiLCJtZGNDYXJkSGVhZGVyIiwibWRjQ2FyZFRpdGxlIiwibWRjQ2FyZFN1YnRpdGxlIiwibWRjQ2FyZFRleHQiLCJtZGNDYXJkQWN0aW9ucyIsIm1kY0NhcmRBY3Rpb25CdXR0b25zIiwibWRjQ2FyZEFjdGlvbkJ1dHRvbiIsIm1kY0NhcmRBY3Rpb25JY29ucyIsIm1kY0NhcmRBY3Rpb25JY29uIiwiTURDQ29tcG9uZW50Iiwicm9vdCIsImZvdW5kYXRpb24iLCJyb290XyIsImluaXRpYWxpemUiLCJmb3VuZGF0aW9uXyIsImdldERlZmF1bHRGb3VuZGF0aW9uIiwiaW5pdGlhbFN5bmNXaXRoRE9NIiwiRXJyb3IiLCJNRENSaXBwbGUiLCJ1bmJvdW5kZWRfIiwic2V0VW5ib3VuZGVkIiwiYWN0aXZhdGUiLCJkZWFjdGl2YXRlIiwiY3JlYXRlQWRhcHRlciIsImRhdGFzZXQiLCJzZXRVbmJvdW5kZWRfIiwiaW5zdGFuY2UiLCJ1dGlsIiwiY2xhc3NMaXN0IiwiYWRkIiwic3R5bGUiLCJzZXRQcm9wZXJ0eSIsIk1EQ1NlbGVjdGlvbkNvbnRyb2wiLCJNRENDaGVja2JveEFkYXB0ZXIiLCJhdHRyIiwiVVBHUkFERUQiLCJDSEVDS0VEIiwiSU5ERVRFUk1JTkFURSIsIkRJU0FCTEVEIiwiQU5JTV9VTkNIRUNLRURfQ0hFQ0tFRCIsIkFOSU1fVU5DSEVDS0VEX0lOREVURVJNSU5BVEUiLCJBTklNX0NIRUNLRURfVU5DSEVDS0VEIiwiQU5JTV9DSEVDS0VEX0lOREVURVJNSU5BVEUiLCJBTklNX0lOREVURVJNSU5BVEVfQ0hFQ0tFRCIsIkFOSU1fSU5ERVRFUk1JTkFURV9VTkNIRUNLRUQiLCJOQVRJVkVfQ09OVFJPTF9TRUxFQ1RPUiIsIlRSQU5TSVRJT05fU1RBVEVfSU5JVCIsIlRSQU5TSVRJT05fU1RBVEVfQ0hFQ0tFRCIsIlRSQU5TSVRJT05fU1RBVEVfVU5DSEVDS0VEIiwiVFJBTlNJVElPTl9TVEFURV9JTkRFVEVSTUlOQVRFIiwiQVJJQV9DSEVDS0VEX0FUVFIiLCJBUklBX0NIRUNLRURfSU5ERVRFUk1JTkFURV9WQUxVRSIsIkFOSU1fRU5EX0xBVENIX01TIiwiQ0JfUFJPVE9fUFJPUFMiLCJNRENDaGVja2JveEZvdW5kYXRpb24iLCJzZXROYXRpdmVDb250cm9sQXR0ciIsInJlbW92ZU5hdGl2ZUNvbnRyb2xBdHRyIiwicmVnaXN0ZXJBbmltYXRpb25FbmRIYW5kbGVyIiwiZGVyZWdpc3RlckFuaW1hdGlvbkVuZEhhbmRsZXIiLCJyZWdpc3RlckNoYW5nZUhhbmRsZXIiLCJkZXJlZ2lzdGVyQ2hhbmdlSGFuZGxlciIsImdldE5hdGl2ZUNvbnRyb2wiLCJmb3JjZUxheW91dCIsImlzQXR0YWNoZWRUb0RPTSIsImN1cnJlbnRDaGVja1N0YXRlXyIsImN1cnJlbnRBbmltYXRpb25DbGFzc18iLCJhbmltRW5kTGF0Y2hUaW1lcl8iLCJhbmltRW5kSGFuZGxlcl8iLCJoYW5kbGVBbmltYXRpb25FbmQiLCJjaGFuZ2VIYW5kbGVyXyIsImhhbmRsZUNoYW5nZSIsImRldGVybWluZUNoZWNrU3RhdGVfIiwiZ2V0TmF0aXZlQ29udHJvbF8iLCJ1cGRhdGVBcmlhQ2hlY2tlZF8iLCJpbnN0YWxsUHJvcGVydHlDaGFuZ2VIb29rc18iLCJ1bmluc3RhbGxQcm9wZXJ0eUNoYW5nZUhvb2tzXyIsImNoZWNrZWQiLCJpbmRldGVybWluYXRlIiwidHJhbnNpdGlvbkNoZWNrU3RhdGVfIiwibmF0aXZlQ2IiLCJjYlByb3RvIiwiZ2V0UHJvdG90eXBlT2YiLCJjb250cm9sU3RhdGUiLCJkZXNjIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwidmFsaWREZXNjcmlwdG9yIiwibmF0aXZlQ2JEZXNjIiwiZ2V0Iiwic2V0IiwiY2FsbCIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsIm9sZFN0YXRlIiwibmV3U3RhdGUiLCJnZXRUcmFuc2l0aW9uQW5pbWF0aW9uQ2xhc3NfIiwiaXNJbmRldGVybWluYXRlIiwiaW5wdXRQcm9wRGVzYyIsIk1EQ0Zvcm1GaWVsZEFkYXB0ZXIiLCJMQUJFTF9TRUxFQ1RPUiIsIk1EQ0Zvcm1GaWVsZEZvdW5kYXRpb24iLCJhY3RpdmF0ZUlucHV0UmlwcGxlIiwiZGVhY3RpdmF0ZUlucHV0UmlwcGxlIiwiY2xpY2tIYW5kbGVyXyIsImhhbmRsZUNsaWNrXyIsImV2ZW50VHlwZU1hcCIsIm5vUHJlZml4Iiwid2Via2l0UHJlZml4Iiwic3R5bGVQcm9wZXJ0eSIsImNzc1Byb3BlcnR5TWFwIiwiaGFzUHJvcGVyU2hhcGUiLCJldmVudEZvdW5kSW5NYXBzIiwiZXZlbnRUeXBlIiwiZ2V0SmF2YVNjcmlwdEV2ZW50TmFtZSIsIm1hcCIsImdldEFuaW1hdGlvbk5hbWUiLCJldmVudE5hbWUiLCJ0cmFuc2Zvcm1TdHlsZVByb3BlcnRpZXMiLCJnZXRDb3JyZWN0RXZlbnROYW1lIiwiZ2V0Q29ycmVjdFByb3BlcnR5TmFtZSIsIm1vZGVsIiwicHJvcCIsImxhYmVsIiwiTnVtYmVyIiwiaGFzTGFiZWwiLCIkc2xvdHMiLCJmb3JtRmllbGRDbGFzc2VzIiwiYWxpZ25FbmQiLCJzZXREaXNhYmxlZCIsInNldEluZGV0ZXJtaW5hdGUiLCIkcmVmcyIsImNvbnRyb2wiLCJzZXRBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJvZmZzZXRXaWR0aCIsInBhcmVudE5vZGUiLCJmb3JtRmllbGQiLCJzZXRDaGVja2VkIiwiaXNBcnJheSIsIm9uQ2hhbmdlIiwiaXNDaGVja2VkIiwiaWR4IiwiY29uY2F0Iiwic2xpY2UiLCJtZGNDaGVja2JveCIsIk1EQ0NoaXBBZGFwdGVyIiwicHJvcGVydHlOYW1lIiwiRU5UUllfQU5JTUFUSU9OX05BTUUiLCJJTlRFUkFDVElPTl9FVkVOVCIsIlRSQUlMSU5HX0lDT05fSU5URVJBQ1RJT05fRVZFTlQiLCJSRU1PVkFMX0VWRU5UIiwiQ0hFQ0tNQVJLX1NFTEVDVE9SIiwiTEVBRElOR19JQ09OX1NFTEVDVE9SIiwiVFJBSUxJTkdfSUNPTl9TRUxFQ1RPUiIsIkNIRUNLTUFSSyIsIkNISVBfRVhJVCIsIkhJRERFTl9MRUFESU5HX0lDT04iLCJMRUFESU5HX0lDT04iLCJUUkFJTElOR19JQ09OIiwiU0VMRUNURUQiLCJNRENDaGlwRm91bmRhdGlvbiIsImhhc0NsYXNzIiwiYWRkQ2xhc3NUb0xlYWRpbmdJY29uIiwicmVtb3ZlQ2xhc3NGcm9tTGVhZGluZ0ljb24iLCJldmVudFRhcmdldEhhc0NsYXNzIiwicmVnaXN0ZXJFdmVudEhhbmRsZXIiLCJkZXJlZ2lzdGVyRXZlbnRIYW5kbGVyIiwicmVnaXN0ZXJUcmFpbGluZ0ljb25JbnRlcmFjdGlvbkhhbmRsZXIiLCJkZXJlZ2lzdGVyVHJhaWxpbmdJY29uSW50ZXJhY3Rpb25IYW5kbGVyIiwibm90aWZ5SW50ZXJhY3Rpb24iLCJub3RpZnlUcmFpbGluZ0ljb25JbnRlcmFjdGlvbiIsIm5vdGlmeVJlbW92YWwiLCJnZXRDb21wdXRlZFN0eWxlVmFsdWUiLCJzZXRTdHlsZVByb3BlcnR5Iiwic2hvdWxkUmVtb3ZlT25UcmFpbGluZ0ljb25DbGlja18iLCJpbnRlcmFjdGlvbkhhbmRsZXJfIiwiaGFuZGxlSW50ZXJhY3Rpb24iLCJ0cmFuc2l0aW9uRW5kSGFuZGxlcl8iLCJoYW5kbGVUcmFuc2l0aW9uRW5kIiwidHJhaWxpbmdJY29uSW50ZXJhY3Rpb25IYW5kbGVyXyIsImhhbmRsZVRyYWlsaW5nSWNvbkludGVyYWN0aW9uIiwic2VsZWN0ZWQiLCJzaG91bGRSZW1vdmUiLCJjaGlwV2lkdGgiLCJzdG9wUHJvcGFnYXRpb24iLCJiZWdpbkV4aXQiLCJsZWFkaW5nSWNvbiIsInRyYWlsaW5nSWNvbiIsImxlYWRpbmdJY29uQ2xhc3NlcyIsInRyYWlsaW5nSWNvbkNsYXNzZXMiLCJpbmplY3QiLCJpc0ZpbHRlciIsIm1kY0NoaXBTZXQiLCJoYXZlbGVhZGluZ0ljb24iLCJoYXZldHJhaWxpbmdJY29uIiwibGVhZGluZ0NsYXNzZXMiLCJ0cmFpbGluZ0NsYXNzZXMiLCJjaGlwIiwiZ2V0UHJvcGVydHlWYWx1ZSIsInByb3BlcnR5IiwidG9nZ2xlU2VsZWN0ZWQiLCJpc1NlbGVjdGVkIiwiTURDQ2hpcFNldEFkYXB0ZXIiLCJDSElQX1NFTEVDVE9SIiwiQ0hPSUNFIiwiRklMVEVSIiwiTURDQ2hpcFNldEZvdW5kYXRpb24iLCJyZW1vdmVDaGlwIiwic2VsZWN0ZWRDaGlwc18iLCJjaGlwSW50ZXJhY3Rpb25IYW5kbGVyXyIsImhhbmRsZUNoaXBJbnRlcmFjdGlvbl8iLCJjaGlwUmVtb3ZhbEhhbmRsZXJfIiwiaGFuZGxlQ2hpcFJlbW92YWxfIiwiY2hpcEZvdW5kYXRpb24iLCJkZXNlbGVjdEFsbF8iLCJzZXRTZWxlY3RlZCIsImluZGV4Iiwic3BsaWNlIiwiZGVzZWxlY3QiLCJzZWxlY3QiLCJjaG9pY2UiLCJpbnB1dCIsInByb3ZpZGUiLCIkbmV4dFRpY2siLCIkZGVzdHJveSIsIm1kY0NoaXAiLCJPUEVOIiwiQU5JTUFUSU5HIiwiQkFDS0RST1AiLCJTQ1JPTExfTE9DSyIsIkFDQ0VQVF9CVE4iLCJDQU5DRUxfQlROIiwiT1BFTl9ESUFMT0dfU0VMRUNUT1IiLCJESUFMT0dfU1VSRkFDRV9TRUxFQ1RPUiIsIkFDQ0VQVF9TRUxFQ1RPUiIsIkFDQ0VQVF9FVkVOVCIsIkNBTkNFTF9FVkVOVCIsIk1EQ0RpYWxvZ0ZvdW5kYXRpb24iLCJhZGRCb2R5Q2xhc3MiLCJyZW1vdmVCb2R5Q2xhc3MiLCJyZWdpc3RlclN1cmZhY2VJbnRlcmFjdGlvbkhhbmRsZXIiLCJkZXJlZ2lzdGVyU3VyZmFjZUludGVyYWN0aW9uSGFuZGxlciIsInJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlciIsImRlcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyIiwicmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlciIsImRlcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlciIsIm5vdGlmeUFjY2VwdCIsIm5vdGlmeUNhbmNlbCIsInRyYXBGb2N1c09uU3VyZmFjZSIsInVudHJhcEZvY3VzT25TdXJmYWNlIiwiaXNEaWFsb2ciLCJpc09wZW5fIiwiY29tcG9uZW50Q2xpY2tIYW5kbGVyXyIsImNhbmNlbCIsImRpYWxvZ0NsaWNrSGFuZGxlcl8iLCJoYW5kbGVEaWFsb2dDbGlja18iLCJkb2N1bWVudEtleWRvd25IYW5kbGVyXyIsImhhbmRsZVRyYW5zaXRpb25FbmRfIiwiZW5hYmxlU2Nyb2xsXyIsImRpc2FibGVTY3JvbGxfIiwic2hvdWxkTm90aWZ5IiwiY2xvc2UiLCJhY2NlcHQiLCJtb2R1bGUiLCJlbGVtZW50RG9jdW1lbnQiLCJvd25lckRvY3VtZW50IiwiYmFzaWNUYWJiYWJsZXMiLCJvcmRlcmVkVGFiYmFibGVzIiwiaXNVbmF2YWlsYWJsZSIsImNyZWF0ZUlzVW5hdmFpbGFibGUiLCJjYW5kaWRhdGVTZWxlY3RvcnMiLCJjYW5kaWRhdGVzIiwicXVlcnlTZWxlY3RvckFsbCIsImpvaW4iLCJpbmNsdWRlQ29udGFpbmVyIiwibWF0Y2hlcyIsIkVsZW1lbnQiLCJtc01hdGNoZXNTZWxlY3RvciIsIndlYmtpdE1hdGNoZXNTZWxlY3RvciIsImNhbmRpZGF0ZVNlbGVjdG9yIiwiYXBwbHkiLCJ1bnNoaWZ0IiwiY2FuZGlkYXRlIiwiY2FuZGlkYXRlSW5kZXhBdHRyIiwiY2FuZGlkYXRlSW5kZXgiLCJpIiwibCIsInBhcnNlSW50IiwiZ2V0QXR0cmlidXRlIiwiaXNOYU4iLCJ0YWJJbmRleCIsInRhZ05hbWUiLCJ0YWJiYWJsZU5vZGVzIiwic29ydCIsImEiLCJiIiwiaXNPZmZDYWNoZSIsImlzT2ZmIiwibm9kZUNvbXB1dGVkU3R5bGUiLCJkZWZhdWx0VmlldyIsImRpc3BsYXkiLCJ2aXNpYmlsaXR5IiwibGlzdGVuaW5nRm9jdXNUcmFwIiwiZm9jdXNUcmFwIiwidXNlck9wdGlvbnMiLCJmaXJzdFRhYmJhYmxlTm9kZSIsImxhc3RUYWJiYWJsZU5vZGUiLCJub2RlRm9jdXNlZEJlZm9yZUFjdGl2YXRpb24iLCJhY3RpdmUiLCJwYXVzZWQiLCJ0YWJFdmVudCIsImNvbnRhaW5lciIsInF1ZXJ5U2VsZWN0b3IiLCJjb25maWciLCJyZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZSIsImVzY2FwZURlYWN0aXZhdGVzIiwidHJhcCIsInBhdXNlIiwidW5wYXVzZSIsImFjdGl2YXRlT3B0aW9ucyIsImRlZmF1bHRlZEFjdGl2YXRlT3B0aW9ucyIsIm9uQWN0aXZhdGUiLCJkZWFjdGl2YXRlT3B0aW9ucyIsImRlZmF1bHRlZERlYWN0aXZhdGVPcHRpb25zIiwicmV0dXJuRm9jdXMiLCJvbkRlYWN0aXZhdGUiLCJhZGRMaXN0ZW5lcnMiLCJmaXJzdEZvY3VzTm9kZSIsImNoZWNrRm9jdXMiLCJjaGVja0NsaWNrIiwiY2hlY2tQb2ludGVyRG93biIsImNoZWNrS2V5IiwicmVtb3ZlTGlzdGVuZXJzIiwiZ2V0Tm9kZUZvck9wdGlvbiIsIm9wdGlvbk5hbWUiLCJvcHRpb25WYWx1ZSIsImNsaWNrT3V0c2lkZURlYWN0aXZhdGVzIiwicHJldmVudERlZmF1bHQiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJibHVyIiwiaXNFc2NhcGVFdmVudCIsImhhbmRsZVRhYiIsImhhc0F0dHJpYnV0ZSIsImN1cnJlbnRGb2N1c0luZGV4Iiwic2hpZnRLZXkiLCJ0cnlGb2N1cyIsInVwZGF0ZVRhYmJhYmxlTm9kZXMiLCJ0YWJiYWJsZSIsInJlYWRqdXN0Rm9jdXMiLCJmb2N1cyIsInRvTG93ZXJDYXNlIiwiY3JlYXRlRm9jdXNUcmFwSW5zdGFuY2UiLCJzdXJmYWNlRWwiLCJhY2NlcHRCdXR0b25FbCIsImZvY3VzVHJhcEZhY3RvcnkiLCJjcmVhdGVGb2N1c1RyYXAiLCJpbml0aWFsRm9jdXMiLCJhY2NlcHREaXNhYmxlZCIsImFjY2VudCIsInNjcm9sbGFibGUiLCJvcGVuIiwiZGFyayIsInN1cmZhY2VDbGFzc2VzIiwiYm9keUNsYXNzZXMiLCJzdXJmYWNlIiwib25PcGVuXyIsIm9uQ2FuY2VsIiwibm90aWZ5Iiwib25BY2NlcHQiLCJzaG93IiwibWRjRGlhbG9nIiwiRk9DVVNBQkxFX0VMRU1FTlRTIiwiTURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9uIiwiaGFzTmVjZXNzYXJ5RG9tIiwicmVnaXN0ZXJEcmF3ZXJJbnRlcmFjdGlvbkhhbmRsZXIiLCJkZXJlZ2lzdGVyRHJhd2VySW50ZXJhY3Rpb25IYW5kbGVyIiwic2V0VHJhbnNsYXRlWCIsImdldEZvY3VzYWJsZUVsZW1lbnRzIiwic2F2ZUVsZW1lbnRUYWJTdGF0ZSIsInJlc3RvcmVFbGVtZW50VGFiU3RhdGUiLCJtYWtlRWxlbWVudFVudGFiYmFibGUiLCJub3RpZnlPcGVuIiwibm90aWZ5Q2xvc2UiLCJpc1J0bCIsImdldERyYXdlcldpZHRoIiwicm9vdENzc0NsYXNzIiwiYW5pbWF0aW5nQ3NzQ2xhc3MiLCJvcGVuQ3NzQ2xhc3MiLCJyb290Q3NzQ2xhc3NfIiwiYW5pbWF0aW5nQ3NzQ2xhc3NfIiwib3BlbkNzc0NsYXNzXyIsImluZXJ0XyIsImNvbXBvbmVudFRvdWNoU3RhcnRIYW5kbGVyXyIsImhhbmRsZVRvdWNoU3RhcnRfIiwiY29tcG9uZW50VG91Y2hNb3ZlSGFuZGxlcl8iLCJoYW5kbGVUb3VjaE1vdmVfIiwiY29tcG9uZW50VG91Y2hFbmRIYW5kbGVyXyIsImhhbmRsZVRvdWNoRW5kXyIsImRldGFiaW5hdGVfIiwicmV0YWJpbmF0ZV8iLCJlbGVtZW50cyIsInBvaW50ZXJUeXBlIiwiZGlyZWN0aW9uXyIsImRyYXdlcldpZHRoXyIsInN0YXJ0WF8iLCJ0b3VjaGVzIiwiY3VycmVudFhfIiwidXBkYXRlUmFmXyIsInVwZGF0ZURyYXdlcl8iLCJiaW5kIiwicHJlcGFyZUZvclRvdWNoRW5kXyIsImFicyIsIm5ld1Bvc2l0aW9uXyIsImlzUm9vdFRyYW5zaXRpb25pbmdFdmVudFRhcmdldF8iLCJuZXdQb3MiLCJtaW4iLCJEUkFXRVJfU0VMRUNUT1IiLCJPUEVOX0VWRU5UIiwiQ0xPU0VfRVZFTlQiLCJNRENQZXJzaXN0ZW50RHJhd2VyRm91bmRhdGlvbiIsImlzRHJhd2VyIiwiVEFCX0RBVEEiLCJUQUJfREFUQV9IQU5ETEVEIiwic3RvcmVkVHJhbnNmb3JtUHJvcGVydHlOYW1lXyIsInJlbWFwRXZlbnQiLCJnZXRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWUiLCJ0cmFuc2Zvcm1Qcm9wZXJ0eU5hbWUiLCJzdXBwb3J0c0Nzc0N1c3RvbVByb3BlcnRpZXMiLCJkcmF3ZXIiLCJfcmVmcmVzaCIsIk9QQUNJVFlfVkFSX05BTUUiLCJNRENUZW1wb3JhcnlEcmF3ZXJGb3VuZGF0aW9uIiwibmV3T3BhY2l0eSIsIm1lZGlhIiwiX3NtYWxsIiwibWF0Y2hNZWRpYSIsIl9sYXJnZSIsIm1kY1Blcm1hbmVudERyYXdlciIsIm1kY1BlcnNpc3RlbnREcmF3ZXIiLCJtZGNUZW1wb3JhcnlEcmF3ZXIiLCJwZXJtYW5lbnQiLCJwZXJzaXN0ZW50IiwidGVtcG9yYXJ5IiwiZHJhd2VyVHlwZSIsInZhbGlkYXRvciIsInZhbCIsInRvb2xiYXJTcGFjZXIiLCJ0b2dnbGVPbiIsInRvZ2dsZU9uU291cmNlIiwicmVxdWlyZWQiLCJvcGVuT24iLCJvcGVuT25Tb3VyY2UiLCJjbG9zZU9uIiwiY2xvc2VPblNvdXJjZSIsIm1kY0RyYXdlciIsInNtYWxsIiwib3Blbl8iLCJpc1Blcm1hbmVudCIsImlzUGVyc2lzdGVudCIsImlzVGVtcG9yYXJ5IiwiaXNSZXNwb25zaXZlIiwiY3JlYXRlZCIsInRvZ2dsZU9uRXZlbnRTb3VyY2UiLCIkb24iLCJ0b2dnbGUiLCJvcGVuT25FdmVudFNvdXJjZSIsImNsb3NlT25FdmVudFNvdXJjZSIsImFkZExpc3RlbmVyIiwicmVmcmVzaE1lZGlhIiwicmVtb3ZlTGlzdGVuZXIiLCIkb2ZmIiwiaXNPcGVuIiwic3RhcnRJY29uIiwidGVtcG9yYXJ5Q2xvc2UiLCJhY3RpdmF0ZWQiLCJteWxpc3RlbmVycyIsIml0ZW1DbGFzc2VzIiwiaGFzU3RhcnREZXRhaWwiLCJtZGNEcmF3ZXJMYXlvdXQiLCJtZGNEcmF3ZXJIZWFkZXIiLCJtZGNEcmF3ZXJMaXN0IiwibWRjRHJhd2VySXRlbSIsIm1kY0RyYXdlckRpdmlkZXIiLCJtZGNFbGV2YXRpb24iLCJtaW5pIiwiYWJzb2x1dGUiLCJmaXhlZCIsIm1kY0ZBQiIsIlRJTEVTX1NFTEVDVE9SIiwiVElMRV9TRUxFQ1RPUiIsIk1EQ0dyaWRMaXN0Rm91bmRhdGlvbiIsImdldE9mZnNldFdpZHRoIiwiZ2V0TnVtYmVyT2ZUaWxlcyIsImdldE9mZnNldFdpZHRoRm9yVGlsZUF0SW5kZXgiLCJzZXRTdHlsZUZvclRpbGVzRWxlbWVudCIsImFsaWduQ2VudGVyIiwicmVzaXplRnJhbWVfIiwiYWxpZ25DZW50ZXJfIiwiZ3JpZFdpZHRoIiwiaXRlbVdpZHRoIiwidGlsZXNXaWR0aCIsInJhdGlvIiwiaW50ZXJhY3RpdmUiLCJtZGNHcmlkIiwibmFycm93R3V0dGVyIiwiaGVhZGVyQ2FwdGlvbiIsImljb25BbGlnblN0YXJ0IiwiaWNvbkFsaWduRW5kIiwid2l0aFN1cHBvcnRUZXh0IiwiZGVmYXVsdFdpZHRoIiwiY292ZXIiLCJjbGlja0xpc3RlbmVyIiwiaXNJbnRlcmFjdGl2ZSIsImhhc0VuZERldGFpbCIsImVuZEljb24iLCJhZGRSaXBwbGUiLCJyZW1vdmVSaXBwbGUiLCJtZGNHcmlkTGlzdCIsIm1kY0dyaWRUaWxlIiwibWRjSWNvbiIsIk1EQ0ljb25Ub2dnbGVBZGFwdGVyIiwidGV4dCIsIkRBVEFfVE9HR0xFX09OIiwiREFUQV9UT0dHTEVfT0ZGIiwiQVJJQV9QUkVTU0VEIiwiQVJJQV9ESVNBQkxFRCIsIkFSSUFfTEFCRUwiLCJDSEFOR0VfRVZFTlQiLCJNRENJY29uVG9nZ2xlRm91bmRhdGlvbiIsInNldFRleHQiLCJnZXRUYWJJbmRleCIsInNldFRhYkluZGV4IiwiZ2V0QXR0ciIsInNldEF0dHIiLCJybUF0dHIiLCJub3RpZnlDaGFuZ2UiLCJvbl8iLCJkaXNhYmxlZF8iLCJzYXZlZFRhYkluZGV4XyIsInRvZ2dsZU9uRGF0YV8iLCJ0b2dnbGVPZmZEYXRhXyIsInRvZ2dsZUZyb21FdnRfIiwiaXNIYW5kbGluZ0tleWRvd25fIiwia2V5ZG93bkhhbmRsZXJfIiwiaXNTcGFjZSIsImtleXVwSGFuZGxlcl8iLCJyZWZyZXNoVG9nZ2xlRGF0YSIsInBhcnNlSnNvbkRhdGFBdHRyXyIsImlzT24iLCJjbGFzc1RvUmVtb3ZlIiwiY3NzQ2xhc3MiLCJkYXRhQXR0ciIsIkpTT04iLCJwYXJzZSIsImlzRGlzYWJsZWQiLCJrZXlib2FyZEtleSIsInRvZ2dsZU9mZiIsImljb25DbGFzc2VzIiwidG9nZ2xlT25EYXRhIiwic3RyaW5naWZ5IiwidG9nZ2xlT2ZmRGF0YSIsImlzS2V5Ym9hcmRBY3RpdmF0ZWQiLCJtZGNJQ29uVG9nZ2xlIiwibWRjTGF5b3V0QXBwIiwiZml4ZWRDb2x1bW5XaWR0aCIsImFsaWduTGVmdCIsImFsaWduUmlnaHQiLCJzcGFuT3B0aW9ucyIsIm51bSIsImlzRmluaXRlIiwic3BhbiIsIm9yZGVyIiwicGhvbmUiLCJ0YWJsZXQiLCJkZXNrdG9wIiwiYWxpZ24iLCJtZGNMYXlvdXRHcmlkIiwibWRjTGF5b3V0Q2VsbCIsIm1kY0xheW91dElubmVyR3JpZCIsIkNMT1NFRF9DTEFTUyIsIklOREVURVJNSU5BVEVfQ0xBU1MiLCJSRVZFUlNFRF9DTEFTUyIsIlBSSU1BUllfQkFSX1NFTEVDVE9SIiwiQlVGRkVSX1NFTEVDVE9SIiwiTURDTGluZWFyUHJvZ3Jlc3NGb3VuZGF0aW9uIiwiZ2V0UHJpbWFyeUJhciIsImdldEJ1ZmZlciIsInNldFN0eWxlIiwiZGV0ZXJtaW5hdGVfIiwicmV2ZXJzZV8iLCJwcm9ncmVzc18iLCJpc0RldGVybWluYXRlIiwic2V0U2NhbGVfIiwiaXNSZXZlcnNlZCIsInNjYWxlVmFsdWUiLCJ0cmFuc2Zvcm1TdHlsZVByb3BlcnR5IiwiUHJvZ3Jlc3NQcm9wVHlwZSIsInJldmVyc2UiLCJwcm9ncmVzcyIsImJ1ZmZlciIsInNldFByb2dyZXNzIiwic2V0QnVmZmVyIiwic2V0RGV0ZXJtaW5hdGUiLCJzZXRSZXZlcnNlIiwicHJpbWFyeSIsIm1kY0xpbmVhclByb2dyZXNzIiwiYXZhdGFyTGlzdCIsInR3b0xpbmUiLCJib3JkZXJlZCIsIm1kY0xpc3QiLCJoYXNTZWNvbmRhcnkiLCJpbnNldCIsInBhZGRlZCIsIm1kY0xpc3RJdGVtIiwibWRjTGlzdERpdmlkZXIiLCJtZGNMaXN0R3JvdXAiLCJtZGNMaXN0R3JvdXBIZWFkZXIiLCJtZGNMaXN0R3JvdXBEaXZpZGVyIiwiTURDTWVudUFkYXB0ZXIiLCJhdHRyaWJ1dGVOYW1lIiwib3JpZ2luIiwicG9zaXRpb24iLCJBTklNQVRJTkdfT1BFTiIsIkFOSU1BVElOR19DTE9TRUQiLCJTRUxFQ1RFRF9MSVNUX0lURU0iLCJJVEVNU19TRUxFQ1RPUiIsIlNFTEVDVEVEX0VWRU5UIiwiQVJJQV9ESVNBQkxFRF9BVFRSIiwiU0VMRUNURURfVFJJR0dFUl9ERUxBWSIsIlRSQU5TSVRJT05fT1BFTl9EVVJBVElPTiIsIlRSQU5TSVRJT05fQ0xPU0VfRFVSQVRJT04iLCJNQVJHSU5fVE9fRURHRSIsIkFOQ0hPUl9UT19NRU5VX1dJRFRIX1JBVElPIiwiT0ZGU0VUX1RPX01FTlVfSEVJR0hUX1JBVElPIiwiQ29ybmVyQml0IiwiQk9UVE9NIiwiQ0VOVEVSIiwiUklHSFQiLCJGTElQX1JUTCIsIkNvcm5lciIsIlRPUF9MRUZUIiwiVE9QX1JJR0hUIiwiQk9UVE9NX0xFRlQiLCJCT1RUT01fUklHSFQiLCJUT1BfU1RBUlQiLCJUT1BfRU5EIiwiQk9UVE9NX1NUQVJUIiwiQk9UVE9NX0VORCIsIk1EQ01lbnVGb3VuZGF0aW9uIiwiZ2V0QXR0cmlidXRlRm9yRXZlbnRUYXJnZXQiLCJnZXRJbm5lckRpbWVuc2lvbnMiLCJoYXNBbmNob3IiLCJnZXRBbmNob3JEaW1lbnNpb25zIiwiZ2V0V2luZG93RGltZW5zaW9ucyIsImdldE51bWJlck9mSXRlbXMiLCJyZWdpc3RlckJvZHlDbGlja0hhbmRsZXIiLCJkZXJlZ2lzdGVyQm9keUNsaWNrSGFuZGxlciIsImdldEluZGV4Rm9yRXZlbnRUYXJnZXQiLCJub3RpZnlTZWxlY3RlZCIsInNhdmVGb2N1cyIsInJlc3RvcmVGb2N1cyIsImlzRm9jdXNlZCIsImdldEZvY3VzZWRJdGVtSW5kZXgiLCJmb2N1c0l0ZW1BdEluZGV4Iiwic2V0VHJhbnNmb3JtT3JpZ2luIiwic2V0UG9zaXRpb24iLCJzZXRNYXhIZWlnaHQiLCJzZXRBdHRyRm9yT3B0aW9uQXRJbmRleCIsInJtQXR0ckZvck9wdGlvbkF0SW5kZXgiLCJhZGRDbGFzc0Zvck9wdGlvbkF0SW5kZXgiLCJybUNsYXNzRm9yT3B0aW9uQXRJbmRleCIsImhhbmRsZVBvc3NpYmxlU2VsZWN0ZWRfIiwiaGFuZGxlS2V5Ym9hcmREb3duXyIsImhhbmRsZUtleWJvYXJkVXBfIiwiZG9jdW1lbnRDbGlja0hhbmRsZXJfIiwiaGFuZGxlRG9jdW1lbnRDbGlja18iLCJvcGVuQW5pbWF0aW9uRW5kVGltZXJJZF8iLCJjbG9zZUFuaW1hdGlvbkVuZFRpbWVySWRfIiwic2VsZWN0ZWRUcmlnZ2VyVGltZXJJZF8iLCJhbmltYXRpb25SZXF1ZXN0SWRfIiwiZGltZW5zaW9uc18iLCJpdGVtSGVpZ2h0XyIsImFuY2hvckNvcm5lcl8iLCJhbmNob3JNYXJnaW5fIiwicmlnaHQiLCJib3R0b20iLCJtZWFzdXJlc18iLCJzZWxlY3RlZEluZGV4XyIsInJlbWVtYmVyU2VsZWN0aW9uXyIsInF1aWNrT3Blbl8iLCJrZXlEb3duV2l0aGluTWVudV8iLCJjb3JuZXIiLCJtYXJnaW4iLCJyZW1lbWJlclNlbGVjdGlvbiIsInNldFNlbGVjdGVkSW5kZXgiLCJxdWlja09wZW4iLCJmb2N1c0luZGV4IiwiYWx0S2V5IiwiY3RybEtleSIsIm1ldGFLZXkiLCJpc1RhYiIsImlzQXJyb3dVcCIsImlzQXJyb3dEb3duIiwiaXNFbnRlciIsImZvY3VzZWRJdGVtSW5kZXgiLCJsYXN0SXRlbUluZGV4IiwiaXNFc2NhcGUiLCJ0YXJnZXRJbmRleCIsImFuY2hvclJlY3QiLCJ2aWV3cG9ydCIsInZpZXdwb3J0RGlzdGFuY2UiLCJhbmNob3JIZWlnaHQiLCJhbmNob3JXaWR0aCIsIm1lbnVIZWlnaHQiLCJtZW51V2lkdGgiLCJpc0JvdHRvbUFsaWduZWQiLCJhdmFpbGFibGVUb3AiLCJhdmFpbGFibGVCb3R0b20iLCJ0b3BPdmVyZmxvdyIsImJvdHRvbU92ZXJmbG93IiwiaXNGbGlwUnRsIiwiYXZvaWRIb3Jpem9udGFsT3ZlcmxhcCIsImlzQWxpZ25lZFJpZ2h0IiwiYXZhaWxhYmxlTGVmdCIsImF2YWlsYWJsZVJpZ2h0IiwibGVmdE92ZXJmbG93IiwicmlnaHRPdmVyZmxvdyIsImlzUmlnaHRBbGlnbmVkIiwicmlnaHRPZmZzZXQiLCJsZWZ0T2Zmc2V0IiwiYXZvaWRWZXJ0aWNhbE92ZXJsYXAiLCJjYW5PdmVybGFwVmVydGljYWxseSIsIm1heEhlaWdodCIsImdldEF1dG9MYXlvdXRNZWFzdXJlbWVudHNfIiwiZ2V0T3JpZ2luQ29ybmVyXyIsIm1heE1lbnVIZWlnaHQiLCJnZXRNZW51TWF4SGVpZ2h0XyIsInZlcnRpY2FsQWxpZ25tZW50IiwiaG9yaXpvbnRhbEFsaWdubWVudCIsImhvcml6b250YWxPZmZzZXQiLCJnZXRIb3Jpem9udGFsT3JpZ2luT2Zmc2V0XyIsInZlcnRpY2FsT2Zmc2V0IiwiZ2V0VmVydGljYWxPcmlnaW5PZmZzZXRfIiwidmVydGljYWxPZmZzZXRQZXJjZW50Iiwib3JpZ2luUGVyY2VudCIsImF1dG9Qb3NpdGlvbl8iLCJmb2N1c09uT3Blbl8iLCJ0YXJnZXRJc0Rpc2FibGVkIiwicHJldlNlbGVjdGVkSW5kZXgiLCJpdGVtcyIsIm52Iiwic2V0UXVpY2tPcGVuIiwiYW5jaG9yQ29ybmVyIiwic2V0QW5jaG9yQ29ybmVyIiwiYW5jaG9yTWFyZ2luIiwic2V0QW5jaG9yTWFyZ2luIiwicmVmcmVzaEl0ZW1zIiwic2xvdE9ic2VydmVyIiwiTXV0YXRpb25PYnNlcnZlciIsIm9ic2VydmUiLCJjaGlsZExpc3QiLCJzdWJ0cmVlIiwiX3ByZXZpb3VzRm9jdXMiLCJvZmZzZXRIZWlnaHQiLCJwYXJlbnRFbGVtZW50IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0IiwiaXRlbSIsImRpc2Nvbm5lY3QiLCJoaWRlIiwibWRjTWVudSIsIm1kY01lbnVJdGVtIiwibWRjTWVudURpdmlkZXIiLCJtZGNNZW51QW5jaG9yIiwiTURDUmFkaW9BZGFwdGVyIiwiTURDUmFkaW9Gb3VuZGF0aW9uIiwicGlja2VkIiwic2V0VmFsdWUiLCJnZXRWYWx1ZSIsInN5bmMiLCJtZGNSYWRpbyIsIkJPWCIsIk9VVExJTkVEIiwiTElORV9SSVBQTEVfU0VMRUNUT1IiLCJPVVRMSU5FX1NFTEVDVE9SIiwiTEFCRUxfU0NBTEUiLCJNRENTZWxlY3RGb3VuZGF0aW9uIiwiZmxvYXRMYWJlbCIsImFjdGl2YXRlQm90dG9tTGluZSIsImRlYWN0aXZhdGVCb3R0b21MaW5lIiwiZ2V0U2VsZWN0ZWRJbmRleCIsImdldExhYmVsV2lkdGgiLCJoYXNPdXRsaW5lIiwibm90Y2hPdXRsaW5lIiwiY2xvc2VPdXRsaW5lIiwiaGFuZGxlRm9jdXNfIiwiaGFuZGxlQmx1cl8iLCJzZWxlY3Rpb25IYW5kbGVyXyIsImhhbmRsZVNlbGVjdF8iLCJmbG9hdExhYmVsV2l0aFZhbHVlXyIsIm9wdGlvbkhhc1ZhbHVlIiwib3Blbk5vdGNoIiwibGFiZWxTY2FsZSIsImxhYmVsV2lkdGgiLCJNRENGbG9hdGluZ0xhYmVsQWRhcHRlciIsIkxBQkVMX0ZMT0FUX0FCT1ZFIiwiTEFCRUxfU0hBS0UiLCJNRENGbG9hdGluZ0xhYmVsRm91bmRhdGlvbiIsImdldFdpZHRoIiwic2hha2VBbmltYXRpb25FbmRIYW5kbGVyXyIsImhhbmRsZVNoYWtlQW5pbWF0aW9uRW5kXyIsInNob3VsZFNoYWtlIiwic2hvdWxkRmxvYXQiLCJsYWJlbENsYXNzZXMiLCJNRENMaW5lUmlwcGxlQWRhcHRlciIsIkxJTkVfUklQUExFX0FDVElWRSIsIkxJTkVfUklQUExFX0RFQUNUSVZBVElORyIsIk1EQ0xpbmVSaXBwbGVGb3VuZGF0aW9uIiwieENvb3JkaW5hdGUiLCJpc0RlYWN0aXZhdGluZyIsImxpbmVDbGFzc2VzIiwibGluZVN0eWxlcyIsIk1EQ05vdGNoZWRPdXRsaW5lQWRhcHRlciIsIlBBVEhfU0VMRUNUT1IiLCJJRExFX09VVExJTkVfU0VMRUNUT1IiLCJPVVRMSU5FX05PVENIRUQiLCJNRENOb3RjaGVkT3V0bGluZUZvdW5kYXRpb24iLCJnZXRIZWlnaHQiLCJzZXRPdXRsaW5lUGF0aEF0dHIiLCJnZXRJZGxlT3V0bGluZVN0eWxlVmFsdWUiLCJub3RjaFdpZHRoIiwidXBkYXRlU3ZnUGF0aF8iLCJyYWRpdXNTdHlsZVZhbHVlIiwicmFkaXVzIiwicGFyc2VGbG9hdCIsImNvcm5lcldpZHRoIiwibGVhZGluZ1N0cm9rZUxlbmd0aCIsInBhZGRlZE5vdGNoV2lkdGgiLCJwYXRoTWlkZGxlIiwicGF0aCIsIm91dGxpbmVkQ2xhc3NlcyIsIk1EQ25vdGNoZWRPdXRsaW5lRm91bmRhdGlvbkZvdW5kYXRpb24iLCJvdXRsaW5lZFBhdGgiLCJvdXRsaW5lZElkbGUiLCJTZWxlY3RMYWJlbCIsIlNlbGVjdExpbmVSaXBsZSIsIlNlbGVjdE5vdGNoZWRPdXRsaW5lIiwiaW5oZXJpdEF0dHJzIiwiYm94IiwiaWQiLCJyb290Q2xhc3NlcyIsImNoYW5nZSIsImxpbmUiLCJuYXRpdmVfY29udHJvbCIsInNlbGVjdGVkSW5kZXgiLCJvdXRsaW5lIiwibm90Y2giLCJjbG9zZU5vdGNoIiwiZmxvYXQiLCJyZWZyZXNoSW5kZXgiLCJmaW5kSW5kZXgiLCJtZGNTZWxlY3QiLCJBQ1RJVkUiLCJESVNDUkVURSIsIkZPQ1VTIiwiSU5fVFJBTlNJVCIsIklTX0RJU0NSRVRFIiwiSEFTX1RSQUNLX01BUktFUiIsIlRSQUNLX1NFTEVDVE9SIiwiVFJBQ0tfTUFSS0VSX0NPTlRBSU5FUl9TRUxFQ1RPUiIsIkxBU1RfVFJBQ0tfTUFSS0VSX1NFTEVDVE9SIiwiVEhVTUJfQ09OVEFJTkVSX1NFTEVDVE9SIiwiUElOX1ZBTFVFX01BUktFUl9TRUxFQ1RPUiIsIkFSSUFfVkFMVUVNSU4iLCJBUklBX1ZBTFVFTUFYIiwiQVJJQV9WQUxVRU5PVyIsIlNURVBfREFUQV9BVFRSIiwiSU5QVVRfRVZFTlQiLCJQQUdFX0ZBQ1RPUiIsIk1EQ1NsaWRlckFkYXB0ZXIiLCJudW1NYXJrZXJzIiwiS0VZX0lEUyIsIkFSUk9XX0xFRlQiLCJBUlJPV19SSUdIVCIsIkFSUk9XX1VQIiwiQVJST1dfRE9XTiIsIkhPTUUiLCJFTkQiLCJQQUdFX1VQIiwiUEFHRV9ET1dOIiwiTU9WRV9FVkVOVF9NQVAiLCJET1dOX0VWRU5UUyIsIlVQX0VWRU5UUyIsIk1EQ1NsaWRlckZvdW5kYXRpb24iLCJyZWdpc3RlclRodW1iQ29udGFpbmVySW50ZXJhY3Rpb25IYW5kbGVyIiwiZGVyZWdpc3RlclRodW1iQ29udGFpbmVySW50ZXJhY3Rpb25IYW5kbGVyIiwicmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyIiwiZGVyZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXIiLCJub3RpZnlJbnB1dCIsInNldFRodW1iQ29udGFpbmVyU3R5bGVQcm9wZXJ0eSIsInNldFRyYWNrU3R5bGVQcm9wZXJ0eSIsInNldE1hcmtlclZhbHVlIiwiYXBwZW5kVHJhY2tNYXJrZXJzIiwicmVtb3ZlVHJhY2tNYXJrZXJzIiwic2V0TGFzdFRyYWNrTWFya2Vyc1N0eWxlUHJvcGVydHkiLCJpc1JUTCIsInJlY3RfIiwiTmFOIiwiYWN0aXZlXyIsImluVHJhbnNpdF8iLCJpc0Rpc2NyZXRlXyIsImhhc1RyYWNrTWFya2VyXyIsImhhbmRsaW5nVGh1bWJUYXJnZXRFdnRfIiwibWluXyIsIm1heF8iLCJzdGVwXyIsInZhbHVlXyIsInByZXZlbnRGb2N1c1N0YXRlXyIsInVwZGF0ZVVJRnJhbWVfIiwidGh1bWJDb250YWluZXJQb2ludGVySGFuZGxlcl8iLCJpbnRlcmFjdGlvblN0YXJ0SGFuZGxlcl8iLCJoYW5kbGVEb3duXyIsImhhbmRsZUtleWRvd25fIiwiZXZ0TmFtZSIsImdldFN0ZXAiLCJnZXRNaW4iLCJnZXRNYXgiLCJzdGVwIiwiaW5kaXZpc2libGUiLCJjZWlsIiwibGFzdFN0ZXBSYXRpbyIsImZsZXgiLCJ1cGRhdGVVSUZvckN1cnJlbnRWYWx1ZV8iLCJzZXRWYWx1ZV8iLCJzZXR1cFRyYWNrTWFya2VyIiwidG9nZ2xlQ2xhc3NfIiwic2V0SW5UcmFuc2l0XyIsInNldEFjdGl2ZV8iLCJtb3ZlSGFuZGxlciIsImhhbmRsZU1vdmVfIiwidXBIYW5kbGVyIiwiaGFuZGxlVXBfIiwic2V0VmFsdWVGcm9tRXZ0XyIsInRhcmdldFRvdWNoZXMiLCJnZXRQYWdlWF8iLCJjb21wdXRlVmFsdWVGcm9tUGFnZVhfIiwieFBvcyIsInBjdENvbXBsZXRlIiwia2V5SWQiLCJnZXRLZXlJZF8iLCJnZXRWYWx1ZUZvcktleUlkXyIsImtiZEV2dCIsImRlbHRhIiwidmFsdWVOZWVkc1RvQmVGbGlwcGVkIiwic2hvdWxkRmlyZUlucHV0IiwiZm9yY2UiLCJ2YWx1ZVNldFRvQm91bmRhcnkiLCJxdWFudGl6ZV8iLCJudW1TdGVwcyIsInF1YW50aXplZFZhbCIsInRyYW5zbGF0ZVB4IiwidHJhbnNmb3JtUHJvcCIsInRyYW5zaXRpb25lbmRFdnROYW1lIiwib25UcmFuc2l0aW9uRW5kIiwiaW5UcmFuc2l0Iiwic2hvdWxkQmVQcmVzZW50IiwiZGlzcGxheU1hcmtlcnMiLCJsYXlvdXRPbiIsImxheW91dE9uU291cmNlIiwidHJhY2tTdHlsZXMiLCJsYXN0VHJhY2tNYXJrZXJzU3R5bGVzIiwidGh1bWJTdHlsZXMiLCJtYXJrZXJWYWx1ZSIsImlzRGlzY3JldGUiLCJoYXNNYXJrZXJzIiwic2V0TWluIiwic2V0TWF4Iiwic2V0U3RlcCIsInRodW1iQ29udGFpbmVyIiwibGF5b3V0T25FdmVudFNvdXJjZSIsIm1kY1NsaWRlciIsIlRFWFQiLCJBQ1RJT05fV1JBUFBFUiIsIkFDVElPTl9CVVRUT04iLCJNVUxUSUxJTkUiLCJBQ1RJT05fT05fQk9UVE9NIiwiVEVYVF9TRUxFQ1RPUiIsIkFDVElPTl9XUkFQUEVSX1NFTEVDVE9SIiwiQUNUSU9OX0JVVFRPTl9TRUxFQ1RPUiIsIlNIT1dfRVZFTlQiLCJISURFX0VWRU5UIiwiTUVTU0FHRV9USU1FT1VUIiwiTURDU25hY2tiYXJGb3VuZGF0aW9uIiwic2V0QXJpYUhpZGRlbiIsInVuc2V0QXJpYUhpZGRlbiIsInNldEFjdGlvbkFyaWFIaWRkZW4iLCJ1bnNldEFjdGlvbkFyaWFIaWRkZW4iLCJzZXRBY3Rpb25UZXh0Iiwic2V0TWVzc2FnZVRleHQiLCJzZXRGb2N1cyIsInZpc2liaWxpdHlJc0hpZGRlbiIsInJlZ2lzdGVyQ2FwdHVyZWRCbHVySGFuZGxlciIsImRlcmVnaXN0ZXJDYXB0dXJlZEJsdXJIYW5kbGVyIiwicmVnaXN0ZXJWaXNpYmlsaXR5Q2hhbmdlSGFuZGxlciIsImRlcmVnaXN0ZXJWaXNpYmlsaXR5Q2hhbmdlSGFuZGxlciIsInJlZ2lzdGVyQ2FwdHVyZWRJbnRlcmFjdGlvbkhhbmRsZXIiLCJkZXJlZ2lzdGVyQ2FwdHVyZWRJbnRlcmFjdGlvbkhhbmRsZXIiLCJyZWdpc3RlckFjdGlvbkNsaWNrSGFuZGxlciIsImRlcmVnaXN0ZXJBY3Rpb25DbGlja0hhbmRsZXIiLCJub3RpZnlTaG93Iiwibm90aWZ5SGlkZSIsImFjdGlvbldhc0NsaWNrZWRfIiwiZGlzbWlzc09uQWN0aW9uXyIsImZpcnN0Rm9jdXNfIiwicG9pbnRlckRvd25SZWNvZ25pemVkXyIsInNuYWNrYmFySGFzRm9jdXNfIiwic25hY2tiYXJEYXRhXyIsInF1ZXVlXyIsImFjdGlvbkNsaWNrSGFuZGxlcl8iLCJpbnZva2VBY3Rpb25fIiwidmlzaWJpbGl0eWNoYW5nZUhhbmRsZXJfIiwidGltZW91dElkXyIsImNsZWFudXBfIiwidGltZW91dCIsImhhbmRsZVBvc3NpYmxlVGFiS2V5Ym9hcmRGb2N1c18iLCJkaXNtaXNzT25BY3Rpb24iLCJtZXNzYWdlIiwiYWN0aW9uSGFuZGxlciIsImFjdGlvblRleHQiLCJtdWx0aWxpbmUiLCJhY3Rpb25PbkJvdHRvbSIsImFjdGlvbkhhbmRsZXJfIiwic2V0QWN0aW9uSGlkZGVuXyIsImhpamFja0ZvY3VzIiwic2V0Rm9jdXNPbkFjdGlvbl8iLCJhbGxvd0Rpc21pc3NhbCIsInNob3dOZXh0XyIsInNoaWZ0IiwiaXNIaWRkZW4iLCJzbmFjayIsImFsaWduU3RhcnQiLCJoaWRkZW4iLCJhY3Rpb25IaWRkZW4iLCJidXR0b24iLCJldmVudFNvdXJjZSIsInNldERpc21pc3NPbkFjdGlvbiIsImRpc21pc3Nlc09uQWN0aW9uIiwib25TbmFjayIsIm1kY1NuYWNrYmFyIiwib25DaGFuZ2VkIiwibWRjU3dpdGNoIiwiTURDVGFiRm91bmRhdGlvbiIsImdldE9mZnNldExlZnQiLCJjb21wdXRlZFdpZHRoXyIsImNvbXB1dGVkTGVmdF8iLCJpc0FjdGl2ZV8iLCJwcmV2ZW50RGVmYXVsdE9uQ2xpY2tfIiwiaXNBY3RpdmUiLCJwcmV2ZW50RGVmYXVsdE9uQ2xpY2siLCJoYXNJY29uIiwiaGFzVGV4dCIsIm9mZnNldExlZnQiLCJ0YWIiLCJzZXRBY3RpdmUiLCJnZXRDb21wdXRlZFdpZHRoIiwiZ2V0Q29tcHV0ZWRMZWZ0IiwiaXNEZWZhdWx0UHJldmVudGVkT25DbGljayIsInByZXZlbnRzRGVmYXVsdE9uQ2xpY2siLCJzZXRQcmV2ZW50RGVmYXVsdE9uQ2xpY2siLCJtZWFzdXJlU2VsZiIsIlRBQl9TRUxFQ1RPUiIsIklORElDQVRPUl9TRUxFQ1RPUiIsIk1EQ1RhYkJhckZvdW5kYXRpb24iLCJiaW5kT25NRENUYWJTZWxlY3RlZEV2ZW50IiwidW5iaW5kT25NRENUYWJTZWxlY3RlZEV2ZW50Iiwic2V0U3R5bGVGb3JJbmRpY2F0b3IiLCJnZXRPZmZzZXRXaWR0aEZvckluZGljYXRvciIsImdldE51bWJlck9mVGFicyIsImlzVGFiQWN0aXZlQXRJbmRleCIsInNldFRhYkFjdGl2ZUF0SW5kZXgiLCJpc0RlZmF1bHRQcmV2ZW50ZWRPbkNsaWNrRm9yVGFiQXRJbmRleCIsInNldFByZXZlbnREZWZhdWx0T25DbGlja0ZvclRhYkF0SW5kZXgiLCJtZWFzdXJlVGFiQXRJbmRleCIsImdldENvbXB1dGVkV2lkdGhGb3JUYWJBdEluZGV4IiwiZ2V0Q29tcHV0ZWRMZWZ0Rm9yVGFiQXRJbmRleCIsImlzSW5kaWNhdG9yU2hvd25fIiwiYWN0aXZlVGFiSW5kZXhfIiwiYWN0aXZlVGFiSW5kZXgiLCJmaW5kQWN0aXZlVGFiSW5kZXhfIiwiZm9yRWFjaFRhYkluZGV4XyIsImxheW91dEluZGljYXRvcl8iLCJpc0luZGljYXRvckZpcnN0UmVuZGVyIiwidHJhbnNsYXRlQW10Rm9yQWN0aXZlVGFiTGVmdCIsInNjYWxlQW10Rm9yQWN0aXZlVGFiV2lkdGgiLCJ0cmFuc2Zvcm1WYWx1ZSIsIml0ZXJhdG9yIiwibnVtVGFicyIsInNob3VsZEJyZWFrIiwicHJldkFjdGl2ZVRhYkluZGV4IiwiaW5kaWNhdG9yU3R5bGVzIiwidGFicyIsIm9uU2VsZWN0IiwiaW5kaWNhdG9yIiwicmVzZXRUYWJzIiwidGFiRWxlbWVudHMiLCJfX3Z1ZV9fIiwiZ2V0QWN0aXZlVGFiSW5kZXgiLCJzd2l0Y2hUb1RhYkF0SW5kZXgiLCJtZGNUYWIiLCJtZGNUYWJCYXIiLCJNRENUZXh0RmllbGRIZWxwZXJUZXh0QWRhcHRlciIsIkFSSUFfSElEREVOIiwiUk9MRSIsIkhFTFBFUl9URVhUX1BFUlNJU1RFTlQiLCJIRUxQRVJfVEVYVF9WQUxJREFUSU9OX01TRyIsIk1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9uIiwicmVtb3ZlQXR0ciIsInNldENvbnRlbnQiLCJpc1ZhbGlkYXRpb24iLCJpbnB1dElzVmFsaWQiLCJoZWxwZXJUZXh0SXNQZXJzaXN0ZW50IiwiaGVscGVyVGV4dElzVmFsaWRhdGlvbk1zZyIsInZhbGlkYXRpb25Nc2dOZWVkc0Rpc3BsYXkiLCJoaWRlXyIsIk1EQ1RleHRGaWVsZEljb25BZGFwdGVyIiwiSUNPTl9FVkVOVCIsIklDT05fUk9MRSIsIk1EQ1RleHRGaWVsZEljb25Gb3VuZGF0aW9uIiwibm90aWZ5SWNvbkFjdGlvbiIsIk1EQ1RleHRGaWVsZEFkYXB0ZXIiLCJvYnNlcnZlciIsIkFSSUFfQ09OVFJPTFMiLCJJTlBVVF9TRUxFQ1RPUiIsIklDT05fU0VMRUNUT1IiLCJERU5TRSIsIkZPQ1VTRUQiLCJJTlZBTElEIiwiREVOU0VfTEFCRUxfU0NBTEUiLCJWQUxJREFUSU9OX0FUVFJfV0hJVEVMSVNUIiwiTURDVGV4dEZpZWxkRm91bmRhdGlvbiIsImlzVmFsaWQiLCJpc0ZvY3VzZWRfIiwiaXNCYWRJbnB1dF8iLCJyZWdpc3RlclRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJUZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXIiLCJyZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyIiwiZGVyZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyIiwicmVnaXN0ZXJWYWxpZGF0aW9uQXR0cmlidXRlQ2hhbmdlSGFuZGxlciIsImRlcmVnaXN0ZXJWYWxpZGF0aW9uQXR0cmlidXRlQ2hhbmdlSGFuZGxlciIsImdldE5hdGl2ZUlucHV0IiwiYWN0aXZhdGVMaW5lUmlwcGxlIiwiZGVhY3RpdmF0ZUxpbmVSaXBwbGUiLCJzZXRMaW5lUmlwcGxlVHJhbnNmb3JtT3JpZ2luIiwic2hha2VMYWJlbCIsImZvdW5kYXRpb25NYXAiLCJoZWxwZXJUZXh0XyIsImhlbHBlclRleHQiLCJpY29uXyIsInJlY2VpdmVkVXNlcklucHV0XyIsInVzZUN1c3RvbVZhbGlkaXR5Q2hlY2tpbmdfIiwiaXNWYWxpZF8iLCJpbnB1dEZvY3VzSGFuZGxlcl8iLCJhY3RpdmF0ZUZvY3VzIiwiaW5wdXRCbHVySGFuZGxlcl8iLCJkZWFjdGl2YXRlRm9jdXMiLCJpbnB1dElucHV0SGFuZGxlcl8iLCJhdXRvQ29tcGxldGVGb2N1cyIsInNldFBvaW50ZXJYT2Zmc2V0XyIsInRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcl8iLCJoYW5kbGVUZXh0RmllbGRJbnRlcmFjdGlvbiIsInZhbGlkYXRpb25BdHRyaWJ1dGVDaGFuZ2VIYW5kbGVyXyIsImF0dHJpYnV0ZXNMaXN0IiwiaGFuZGxlVmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZSIsInZhbGlkYXRpb25PYnNlcnZlcl8iLCJzdHlsZVZhbGlkaXR5XyIsImlzRGVuc2UiLCJzdHlsZUZvY3VzZWRfIiwic2hvd1RvU2NyZWVuUmVhZGVyIiwidGFyZ2V0Q2xpZW50UmVjdCIsImV2dENvb3JkcyIsImNsaWVudFgiLCJjbGllbnRZIiwiZ2V0TmF0aXZlSW5wdXRfIiwic2hvdWxkUmVtb3ZlTGFiZWxGbG9hdCIsImlzTmF0aXZlSW5wdXRWYWxpZF8iLCJzdHlsZURpc2FibGVkXyIsInNldEFyaWFMYWJlbCIsInZhbGlkaXR5IiwiYmFkSW5wdXQiLCJ2YWxpZCIsInNldFZhbGlkaXR5IiwiaGVscHRleHQiLCJoZWxwdGV4dFBlcnNpc3RlbnQiLCJoZWxwdGV4dFZhbGlkYXRpb24iLCJmdWxsd2lkdGgiLCJzaXplIiwibWlubGVuZ3RoIiwibWF4bGVuZ3RoIiwicm93cyIsImNvbHMiLCJpbnB1dENsYXNzZXMiLCJsaW5lUmlwcGxlQ2xhc3NlcyIsImxpbmVSaXBwbGVTdHlsZXMiLCJoZWxwQ2xhc3NlcyIsIm91dGxpbmVDbGFzc2VzIiwib3V0bGluZVBhdGhBdHRyIiwiaW5wdXRQbGFjZUhvbGRlciIsImlucHV0QXJpYUNvbnRyb2xzIiwiaGVscCIsImhhc0xpbmVSaXBwbGUiLCJoYXNMZWFkaW5nSWNvbiIsImhhc1RyYWlsaW5nSWNvbiIsImxhYmVsQ2xhc3Nlc1VwZ3JhZGVkIiwic2V0VmFsaWQiLCJoZWxwZXJUZXh0Rm91bmRhdGlvbiIsInNldFBlcnNpc3RlbnQiLCJzZXRWYWxpZGF0aW9uIiwibGluZVJpcHBsZSIsImxpbmVSaXBwbGVGb3VuZGF0aW9uIiwiaWNvbkZvdW5kYXRpb24iLCJsYWJlbEZvdW5kYXRpb24iLCJvdXRsaW5lRm91bmRhdGlvbiIsImlkbGVPdXRsaW5lRWxlbWVudCIsIm91dGxpbmVJZGxlIiwiTURDVGV4dGZpZWxkRm91bmRhdGlvbiIsInNldFJpcHBsZUNlbnRlciIsImdldEF0dHJpYnV0ZXNMaXN0IiwibXV0YXRpb25zTGlzdCIsIm11dGF0aW9uIiwidGFyZ2V0Tm9kZSIsImF0dHJpYnV0ZXMiLCJzaGFrZSIsInRleHRib3giLCJ1cGRhdGVWYWx1ZSIsIm1kY1RleHRGaWVsZCIsIlRIRU1FX0NPTE9SUyIsIlRIRU1FX1NUWUxFUyIsImNvbG9yIiwiYmFja2dyb3VuZCIsIm1kY1RoZW1lIiwiRklYRUQiLCJGSVhFRF9MQVNUUk9XIiwiRklYRURfQVRfTEFTVF9ST1ciLCJUT09MQkFSX1JPV19GTEVYSUJMRSIsIkZMRVhJQkxFX0RFRkFVTFRfQkVIQVZJT1IiLCJGTEVYSUJMRV9NQVgiLCJGTEVYSUJMRV9NSU4iLCJUSVRMRV9TRUxFQ1RPUiIsIkZJUlNUX1JPV19TRUxFQ1RPUiIsIk1BWF9USVRMRV9TSVpFIiwiTUlOX1RJVExFX1NJWkUiLCJUT09MQkFSX1JPV19IRUlHSFQiLCJUT09MQkFSX1JPV19NT0JJTEVfSEVJR0hUIiwiVE9PTEJBUl9NT0JJTEVfQlJFQUtQT0lOVCIsIk1EQ1Rvb2xiYXJGb3VuZGF0aW9uIiwicmVnaXN0ZXJTY3JvbGxIYW5kbGVyIiwiZGVyZWdpc3RlclNjcm9sbEhhbmRsZXIiLCJnZXRWaWV3cG9ydFdpZHRoIiwiZ2V0Vmlld3BvcnRTY3JvbGxZIiwiZ2V0T2Zmc2V0SGVpZ2h0IiwiZ2V0Rmlyc3RSb3dFbGVtZW50T2Zmc2V0SGVpZ2h0Iiwic2V0U3R5bGVGb3JUaXRsZUVsZW1lbnQiLCJzZXRTdHlsZUZvckZsZXhpYmxlUm93RWxlbWVudCIsInNldFN0eWxlRm9yRml4ZWRBZGp1c3RFbGVtZW50IiwiY2hlY2tSb3dIZWlnaHRfIiwic2Nyb2xsSGFuZGxlcl8iLCJ1cGRhdGVUb29sYmFyU3R5bGVzXyIsImNoZWNrUm93SGVpZ2h0RnJhbWVfIiwic2Nyb2xsRnJhbWVfIiwiZXhlY3V0ZWRMYXN0Q2hhbmdlXyIsImNhbGN1bGF0aW9uc18iLCJ0b29sYmFyUm93SGVpZ2h0IiwidG9vbGJhclJhdGlvIiwiZmxleGlibGVFeHBhbnNpb25SYXRpbyIsIm1heFRyYW5zbGF0ZVlSYXRpbyIsInNjcm9sbFRocmVzaG9sZFJhdGlvIiwidG9vbGJhckhlaWdodCIsImZsZXhpYmxlRXhwYW5zaW9uSGVpZ2h0IiwibWF4VHJhbnNsYXRlWURpc3RhbmNlIiwic2Nyb2xsVGhyZXNob2xkIiwiZml4ZWRfIiwiZml4ZWRMYXN0cm93XyIsImhhc0ZsZXhpYmxlUm93XyIsInVzZUZsZXhEZWZhdWx0QmVoYXZpb3JfIiwiaW5pdEtleVJhdGlvXyIsInNldEtleUhlaWdodHNfIiwic2Nyb2xsVG9wIiwibmV3VG9vbGJhclJvd0hlaWdodCIsImdldFJvd0hlaWdodF8iLCJ1cGRhdGVBZGp1c3RFbGVtZW50U3R5bGVzIiwiaGFzU2Nyb2xsZWRPdXRPZlRocmVzaG9sZCIsInNjcm9sbGVkT3V0T2ZUaHJlc2hvbGRfIiwiZ2V0RmxleGlibGVFeHBhbnNpb25SYXRpb18iLCJ1cGRhdGVUb29sYmFyRmxleGlibGVTdGF0ZV8iLCJ1cGRhdGVUb29sYmFyRml4ZWRTdGF0ZV8iLCJ1cGRhdGVGbGV4aWJsZVJvd0VsZW1lbnRTdHlsZXNfIiwiZmlyc3RSb3dNYXhSYXRpbyIsImJyZWFrcG9pbnQiLCJ0cmFuc2xhdGVEaXN0YW5jZSIsInVwZGF0ZUVsZW1lbnRTdHlsZXNEZWZhdWx0QmVoYXZpb3JfIiwibWF4VGl0bGVTaXplIiwibWluVGl0bGVTaXplIiwiY3VycmVudFRpdGxlU2l6ZSIsIndhdGVyZmFsbCIsImZsZXhpYmxlIiwiZml4ZWRMYXN0cm93IiwiZmxleGlibGVEZWZhdWx0Iiwicm9vdFN0eWxlcyIsImFkanVzdFN0eWxlcyIsInNocmlua1RvRml0IiwibWRjVG9vbGJhciIsIm1kY1Rvb2xiYXJSb3ciLCJtZGNUb29sYmFyU2VjdGlvbiIsIm1kY1Rvb2xiYXJNZW51SWNvbiIsIm1kY1Rvb2xiYXJUaXRsZSIsIm1kY1Rvb2xiYXJJY29uIiwiRklYRURfQ0xBU1MiLCJGSVhFRF9TQ1JPTExFRF9DTEFTUyIsIlNIT1JUX0NMQVNTIiwiU0hPUlRfSEFTX0FDVElPTl9JVEVNX0NMQVNTIiwiU0hPUlRfQ09MTEFQU0VEX0NMQVNTIiwiREVCT1VOQ0VfVEhST1RUTEVfUkVTSVpFX1RJTUVfTVMiLCJNQVhfVE9QX0FQUF9CQVJfSEVJR0hUIiwiQUNUSU9OX0lURU1fU0VMRUNUT1IiLCJOQVZJR0FUSU9OX0VWRU5UIiwiTkFWSUdBVElPTl9JQ09OX1NFTEVDVE9SIiwiUk9PVF9TRUxFQ1RPUiIsIk1EQ1RvcEFwcEJhckFkYXB0ZXIiLCJNRENUb3BBcHBCYXJCYXNlRm91bmRhdGlvbiIsImdldFRvcEFwcEJhckhlaWdodCIsInJlZ2lzdGVyTmF2aWdhdGlvbkljb25JbnRlcmFjdGlvbkhhbmRsZXIiLCJkZXJlZ2lzdGVyTmF2aWdhdGlvbkljb25JbnRlcmFjdGlvbkhhbmRsZXIiLCJub3RpZnlOYXZpZ2F0aW9uSWNvbkNsaWNrZWQiLCJnZXRUb3RhbEFjdGlvbkl0ZW1zIiwibmF2Q2xpY2tIYW5kbGVyXyIsIk1EQ1Nob3J0VG9wQXBwQmFyRm91bmRhdGlvbiIsImlzQ29sbGFwc2VkIiwic2hvcnRBcHBCYXJTY3JvbGxIYW5kbGVyXyIsImlzQWx3YXlzQ29sbGFwc2VkIiwiY3VycmVudFNjcm9sbCIsInNob3J0Iiwic2hvcnRDb2xsYXBzZWQiLCJwcm9taW5lbnQiLCJoYXZlTmF2aWdhdGlvbkljb24iLCJuYXZpY29uQ2xhc3NlcyIsImNsaWVudEhlaWdodCIsIm5hdmlnYXRpb25JY29uIiwiTURDVG9wQXBwQmFyRm91bmRhdGlvbiIsImFjdGlvbmljb25DbGFzc2VzIiwibWRjVG9wQXBwQmFyIiwibWRjVG9wQXBwQmFyQWN0aW9uIiwidHlwb3MiLCJtZGNUeXBvTWl4aW4iLCJjbGFzcyIsInR5cG8iLCIkYXR0cnMiLCJtZGNUeXBvUHJvcE1peGluIiwiZGVmYXVsdFRhZyIsImRlZmF1bHRUeXBvIiwidmFsaWRUeXBvcyIsIm1kY1RleHRTZWN0aW9uIiwibWRjVGV4dCIsIm1kY0Rpc3BsYXkiLCJtZGNIZWFkbGluZSIsIm1kY1RpdGxlIiwibWRjU3ViSGVhZGluZyIsIm1kY0JvZHkiLCJtZGNDYXB0aW9uIiwiVnVlTURDQnV0dG9uIiwiVnVlTURDQ2FyZCIsIlZ1ZU1EQ0NoZWNrYm94IiwiVnVlTURDQ2hpcFNldCIsIlZ1ZU1EQ0RpYWxvZyIsIlZ1ZU1EQ0RyYXdlciIsIlZ1ZU1EQ0VsZXZhdGlvbiIsIlZ1ZU1EQ0ZhYiIsIlZ1ZU1EQ0dyaWRMaXN0IiwiVnVlTURDSWNvbiIsIlZ1ZU1EQ0ljb25Ub2dnbGUiLCJWdWVNRENMYXlvdXRBcHAiLCJWdWVNRENMYXlvdXRHcmlkIiwiVnVlTURDTGluZWFyUHJvZ3Jlc3MiLCJWdWVNRENMaXN0IiwiVnVlTURDTWVudSIsIlZ1ZU1EQ1JhZGlvIiwiVnVlTURDUmlwcGxlIiwiVnVlTURDU2VsZWN0IiwiVnVlTURDU2xpZGVyIiwiVnVlTURDU25hY2tiYXIiLCJWdWVNRENTd2l0Y2giLCJWdWVNRENUYWJzIiwiVnVlTURDVGV4dGZpZWxkIiwiVnVlTURDVGhlbWUiLCJWdWVNRENUb29sYmFyIiwiVnVlTURDVG9wQXBwQmFyIiwiVnVlTURDVHlwb2dyYXBoeSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztFQUFBLElBQUlBLHlCQUFKOztFQUVBOzs7Ozs7QUFNQSxFQUFPLFNBQVNDLFlBQVQsR0FBZ0U7RUFBQSxNQUExQ0MsU0FBMEMsdUVBQTlCQyxNQUE4QjtFQUFBLE1BQXRCQyxZQUFzQix1RUFBUCxLQUFPOztFQUNyRSxNQUFJSixxQkFBcUJLLFNBQXJCLElBQWtDRCxZQUF0QyxFQUFvRDtFQUNsRCxRQUFJRSxjQUFjLEtBQWxCO0VBQ0EsUUFBSTtFQUNGSixnQkFBVUssUUFBVixDQUFtQkMsZ0JBQW5CLENBQW9DLE1BQXBDLEVBQTRDLElBQTVDLEVBQWtEO0VBQ2hELFlBQUlDLE9BQUosR0FBYztFQUNaSCx3QkFBYyxFQUFFRyxTQUFTLElBQVgsRUFBZDtFQUNEO0VBSCtDLE9BQWxEO0VBS0QsS0FORCxDQU1FLE9BQU9DLENBQVAsRUFBVTtFQUNWO0VB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
